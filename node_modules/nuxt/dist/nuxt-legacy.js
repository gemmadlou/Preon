/*!
 * nuxt-legacy v2.2.0 (c) 2016-2018
 * - Sebastien Chopin (@Atinux)
 * - Alexandre Chopin (@alexchopin)
 * - Pooya Parsa (@pi0)
 * - Clark Du (@clarkdo)
 * - Jonas Galvez (@galvez)
 * - Alexander Lichter (@manniL}
 * - All the amazing contributors
 * Released under the MIT License.
 * Website: https://nuxtjs.org
*/
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var _ = require('lodash');
var ___default = _interopDefault(_);
var consola = _interopDefault(require('consola'));
var fs = _interopDefault(require('fs'));
var hash = _interopDefault(require('hash-sum'));
var env = _interopDefault(require('std-env'));
var Vue = _interopDefault(require('vue'));
var VueMeta = _interopDefault(require('vue-meta'));
var vueServerRenderer = require('vue-server-renderer');
var LRU = _interopDefault(require('lru-cache'));
var Youch = _interopDefault(require('@nuxtjs/youch'));
var fsExtra = _interopDefault(require('fs-extra'));
var generateETag = _interopDefault(require('etag'));
var fresh = _interopDefault(require('fresh'));
var crypto = _interopDefault(require('crypto'));
var devalue = _interopDefault(require('@nuxtjs/devalue'));
var serveStatic = _interopDefault(require('serve-static'));
var connect = _interopDefault(require('connect'));
var launchMiddleware = _interopDefault(require('launch-editor-middleware'));
var Module = _interopDefault(require('module'));
var https = _interopDefault(require('https'));
var enableDestroy = _interopDefault(require('server-destroy'));
var Chalk = _interopDefault(require('chalk'));
var esm = _interopDefault(require('esm'));
var ip = _interopDefault(require('ip'));
var threadLoader = require('thread-loader');
var createResolver = _interopDefault(require('postcss-import-resolver'));
var MiniCssExtractPlugin = _interopDefault(require('mini-css-extract-plugin'));
var TimeFixPlugin = _interopDefault(require('time-fix-plugin'));
var VueLoader = _interopDefault(require('vue-loader'));
var WebpackBar = _interopDefault(require('webpackbar'));
var webpack = _interopDefault(require('webpack'));
var HTMLPlugin = _interopDefault(require('html-webpack-plugin'));
var BundleAnalyzer = _interopDefault(require('webpack-bundle-analyzer'));
var TerserWebpackPlugin = _interopDefault(require('terser-webpack-plugin'));
var OptimizeCSSAssetsPlugin = _interopDefault(require('optimize-css-assets-webpack-plugin'));
var FriendlyErrorsWebpackPlugin = _interopDefault(require('@nuxtjs/friendly-errors-webpack-plugin'));
var nodeExternals = _interopDefault(require('webpack-node-externals'));
var pify = _interopDefault(require('pify'));
var chokidar = _interopDefault(require('chokidar'));
var serialize = _interopDefault(require('serialize-javascript'));
var MFS = _interopDefault(require('memory-fs'));
var webpackDevMiddleware = _interopDefault(require('webpack-dev-middleware'));
var webpackHotMiddleware = _interopDefault(require('webpack-hot-middleware'));
var Glob = _interopDefault(require('glob'));
var upath = _interopDefault(require('upath'));
var htmlMinifier = _interopDefault(require('html-minifier'));
require('@babel/polyfill');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var encodeHtml = function encodeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
};
var getContext = function getContext(req, res) {
  return {
    req: req,
    res: res
  };
};
var waitFor = function waitFor(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms || 0);
  });
};
var isString = function isString(obj) {
  return typeof obj === 'string' || obj instanceof String;
};
var startsWithAlias = function startsWithAlias(aliasArray) {
  return function (str) {
    return aliasArray.some(function (c) {
      return str.startsWith(c);
    });
  };
};
var startsWithSrcAlias = startsWithAlias(['@', '~']);
var startsWithRootAlias = startsWithAlias(['@@', '~~']);

function promiseFinally(_x, _x2) {
  return _promiseFinally.apply(this, arguments);
}

function _promiseFinally() {
  _promiseFinally = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(fn, finalFn) {
    var result;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            if (!(typeof fn === 'function')) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return fn();

          case 4:
            result = _context.sent;
            _context.next = 10;
            break;

          case 7:
            _context.next = 9;
            return fn;

          case 9:
            result = _context.sent;

          case 10:
            _context.prev = 10;
            finalFn();
            return _context.finish(10);

          case 13:
            return _context.abrupt("return", result);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[0,, 10, 13]]);
  }));
  return _promiseFinally.apply(this, arguments);
}

var timeout = function timeout(fn, ms, msg) {
  var timerId;
  var warpPromise = promiseFinally(fn, function () {
    return clearTimeout(timerId);
  });
  var timerPromise = new Promise(function (resolve, reject) {
    timerId = setTimeout(function () {
      return reject(new Error(msg));
    }, ms);
  });
  return Promise.race([warpPromise, timerPromise]);
};
var urlJoin = function urlJoin() {
  return [].slice.call(arguments).join('/').replace(/\/+/g, '/').replace(':/', '://');
};
var isUrl = function isUrl(url) {
  return ['http', '//'].some(function (str) {
    return url.startsWith(str);
  });
};
var promisifyRoute = function promisifyRoute(fn) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn);
  } // If routes is a function expecting a callback


  if (fn.length === arguments.length) {
    return new Promise(function (resolve, reject) {
      fn.apply(void 0, [function (err, routeParams) {
        if (err) {
          reject(err);
        }

        resolve(routeParams);
      }].concat(args));
    });
  }

  var promise = fn.apply(void 0, args);

  if (!promise || !(promise instanceof Promise) && typeof promise.then !== 'function') {
    promise = Promise.resolve(promise);
  }

  return promise;
};
var sequence = function sequence(tasks, fn) {
  return tasks.reduce(function (promise, task) {
    return promise.then(function () {
      return fn(task);
    });
  }, Promise.resolve());
};
var parallel = function parallel(tasks, fn) {
  return Promise.all(tasks.map(fn));
};
var chainFn = function chainFn(base, fn) {
  /* istanbul ignore if */
  if (typeof fn !== 'function') {
    return base;
  }

  return function () {
    if (typeof base !== 'function') {
      return fn.apply(this, arguments);
    }

    var baseResult = base.apply(this, arguments); // Allow function to mutate the first argument instead of returning the result

    if (baseResult === undefined) {
      baseResult = arguments[0];
    }

    var fnResult = fn.call.apply(fn, [this, baseResult].concat(_toConsumableArray(Array.prototype.slice.call(arguments, 1)))); // Return mutated argument if no result was returned

    if (fnResult === undefined) {
      return baseResult;
    }

    return fnResult;
  };
};
var isPureObject = function isPureObject(o) {
  return !Array.isArray(o) && _typeof(o) === 'object';
};
var isWindows = /^win/.test(process.platform);
var wp = function wp() {
  var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\\/g, '\\\\');
  }

  return p;
};
var wChunk = function wChunk() {
  var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\//g, '_');
  }

  return p;
};
var reqSep = /\//g;

var sysSep = ___default.escapeRegExp(path__default.sep);

var normalize = function normalize(string) {
  return string.replace(reqSep, sysSep);
};

var r = function r() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var lastArg = args[args.length - 1];

  if (startsWithSrcAlias(lastArg)) {
    return wp(lastArg);
  }

  return wp(path__default.resolve.apply(path__default, _toConsumableArray(args.map(normalize))));
};
var relativeTo = function relativeTo() {
  var args = Array.prototype.slice.apply(arguments);
  var dir = args.shift(); // Keep webpack inline loader intact

  if (args[0].includes('!')) {
    var loaders = args.shift().split('!');
    return loaders.concat(relativeTo.apply(void 0, [dir, loaders.pop()].concat(_toConsumableArray(args)))).join('!');
  } // Resolve path


  var _path = r.apply(void 0, _toConsumableArray(args)); // Check if path is an alias


  if (startsWithSrcAlias(_path)) {
    return _path;
  } // Make correct relative path


  var rp = path__default.relative(dir, _path);

  if (rp[0] !== '.') {
    rp = './' + rp;
  }

  return wp(rp);
};
var flatRoutes = function flatRoutes(router) {
  var _path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var routes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  router.forEach(function (r) {
    if ([':', '*'].some(function (c) {
      return r.path.includes(c);
    })) {
      return;
    }
    /* istanbul ignore if */


    if (r.children) {
      if (_path === '' && r.path === '/') {
        routes.push('/');
      }

      return flatRoutes(r.children, _path + r.path + '/', routes);
    }

    _path = _path.replace(/^\/+$/, '/');
    routes.push((r.path === '' && _path[_path.length - 1] === '/' ? _path.slice(0, -1) : _path) + r.path);
  });
  return routes;
};

function cleanChildrenRoutes(routes) {
  var isChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var start = -1;
  var routesIndex = [];
  routes.forEach(function (route) {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      var res = route.name.split('-');
      var s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach(function (route) {
    route.path = isChild ? route.path.replace('/', '') : route.path;

    if (route.path.includes('?')) {
      var names = route.name.split('-');
      var paths = route.path.split('/');

      if (!isChild) {
        paths.shift();
      } // clean first / for parents


      routesIndex.forEach(function (r) {
        var i = r.indexOf('index') - start; //  children names

        if (i < paths.length) {
          for (var a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }

            if (a < i && names[a] !== r[a]) {
              break;
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }

    route.name = route.name.replace(/-index$/, '');

    if (route.children) {
      if (route.children.find(function (child) {
        return child.path === '';
      })) {
        delete route.name;
      }

      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes;
}

var createRoutes = function createRoutes(files, srcDir, pagesDir) {
  var routes = [];
  files.forEach(function (file) {
    var keys = file.replace(RegExp("^".concat(pagesDir)), '').replace(/\.(vue|js)$/, '').replace(/\/{2,}/g, '/').split('/').slice(1);
    var route = {
      name: '',
      path: '',
      component: r(srcDir, file)
    };
    var parent = routes;
    keys.forEach(function (key, i) {
      // remove underscore only, if its the prefix
      var sanitizedKey = key.startsWith('_') ? key.substr(1) : key;
      route.name = route.name ? route.name + '-' + sanitizedKey : sanitizedKey;
      route.name += key === '_' ? 'all' : '';
      route.chunkName = file.replace(/\.(vue|js)$/, '');
      var child = parent.find(function (parentRoute) {
        return parentRoute.name === route.name;
      });

      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = '';
      } else if (key === 'index' && i + 1 === keys.length) {
        route.path += i > 0 ? '' : '/';
      } else {
        route.path += '/' + getRoutePathExtension(key);

        if (key.startsWith('_') && key.length > 1) {
          route.path += '?';
        }
      }
    }); // Order Routes path

    parent.push(route);
    parent.sort(function (a, b) {
      if (!a.path.length) {
        return -1;
      }

      if (!b.path.length) {
        return 1;
      } // Order: /static, /index, /:dynamic
      // Match exact route before index: /login before /index/_slug


      if (a.path === '/') {
        return DYNAMIC_ROUTE_REGEX.test(b.path) ? -1 : 1;
      }

      if (b.path === '/') {
        return DYNAMIC_ROUTE_REGEX.test(a.path) ? 1 : -1;
      }

      var i;
      var res = 0;
      var y = 0;
      var z = 0;

      var _a = a.path.split('/');

      var _b = b.path.split('/');

      for (i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break;
        }

        y = _a[i] === '*' ? 2 : _a[i].includes(':') ? 1 : 0;
        z = _b[i] === '*' ? 2 : _b[i].includes(':') ? 1 : 0;
        res = y - z; // If a.length >= b.length

        if (i === _b.length - 1 && res === 0) {
          // change order if * found
          res = _a[i] === '*' ? -1 : 1;
        }
      }

      return res === 0 ? _a[i - 1] === '*' && _b[i] ? 1 : -1 : res;
    });
  });
  return cleanChildrenRoutes(routes);
}; // Guard dir1 from dir2 which can be indiscriminately removed

var guardDir = function guardDir(options, key1, key2) {
  var dir1 = ___default.get(options, key1, false);

  var dir2 = ___default.get(options, key2, false);

  if (dir1 && dir2 && (dir1 === dir2 || dir1.startsWith(dir2) && !path__default.basename(dir1).startsWith(path__default.basename(dir2)))) {
    var errorMessage = "options.".concat(key2, " cannot be a parent of or same as ").concat(key1);
    consola.fatal(errorMessage);
    throw new Error(errorMessage);
  }
};
var determineGlobals = function determineGlobals(globalName, globals) {
  var _globals = {};

  for (var global in globals) {
    if (typeof globals[global] === 'function') {
      _globals[global] = globals[global](globalName);
    } else {
      _globals[global] = globals[global];
    }
  }

  return _globals;
};

var getRoutePathExtension = function getRoutePathExtension(key) {
  if (key === '_') {
    return '*';
  }

  if (key.startsWith('_')) {
    return ":".concat(key.substr(1));
  }

  return key;
};

var DYNAMIC_ROUTE_REGEX = /^\/(:|\*)/;
/**
 * Wraps value in array if it is not already an array
 *
 * @param  {any} value
 * @return {array}
 */

var wrapArray = function wrapArray(value) {
  return Array.isArray(value) ? value : [value];
};

var Utils = /*#__PURE__*/Object.freeze({
  encodeHtml: encodeHtml,
  getContext: getContext,
  waitFor: waitFor,
  isString: isString,
  startsWithAlias: startsWithAlias,
  startsWithSrcAlias: startsWithSrcAlias,
  startsWithRootAlias: startsWithRootAlias,
  timeout: timeout,
  urlJoin: urlJoin,
  isUrl: isUrl,
  promisifyRoute: promisifyRoute,
  sequence: sequence,
  parallel: parallel,
  chainFn: chainFn,
  isPureObject: isPureObject,
  isWindows: isWindows,
  wp: wp,
  wChunk: wChunk,
  r: r,
  relativeTo: relativeTo,
  flatRoutes: flatRoutes,
  createRoutes: createRoutes,
  guardDir: guardDir,
  determineGlobals: determineGlobals,
  wrapArray: wrapArray
});

var ModuleContainer =
/*#__PURE__*/
function () {
  function ModuleContainer(nuxt) {
    _classCallCheck(this, ModuleContainer);

    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.requiredModules = {};
  }

  _createClass(ModuleContainer, [{
    key: "ready",
    value: function () {
      var _ready = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.nuxt.callHook('modules:before', this, this.options.modules);

              case 2:
                _context.next = 4;
                return sequence(this.options.modules, this.addModule.bind(this));

              case 4:
                _context.next = 6;
                return this.nuxt.callHook('modules:done', this);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function ready() {
        return _ready.apply(this, arguments);
      };
    }()
  }, {
    key: "addVendor",
    value: function addVendor() {
      consola.warn('addVendor has been deprecated due to webpack4 optimization');
    }
  }, {
    key: "addTemplate",
    value: function addTemplate(template) {
      /* istanbul ignore if */
      if (!template) {
        throw new Error('Invalid template:' + JSON.stringify(template));
      } // Validate & parse source


      var src = template.src || template;
      var srcPath = path__default.parse(src);
      /* istanbul ignore if */

      if (typeof src !== 'string' || !fs.existsSync(src)) {
        throw new Error('Template src not found:' + src);
      } // Generate unique and human readable dst filename


      var dst = template.fileName || path__default.basename(srcPath.dir) + ".".concat(srcPath.name, ".").concat(hash(src)) + srcPath.ext; // Add to templates list

      var templateObj = {
        src: src,
        dst: dst,
        options: template.options
      };
      this.options.build.templates.push(templateObj);
      return templateObj;
    }
  }, {
    key: "addPlugin",
    value: function addPlugin(template) {
      var _this$addTemplate = this.addTemplate(template),
          dst = _this$addTemplate.dst; // Add to nuxt plugins


      this.options.plugins.unshift({
        src: path__default.join(this.options.buildDir, dst),
        ssr: template.ssr
      });
    }
  }, {
    key: "addLayout",
    value: function addLayout(template, name) {
      var _this$addTemplate2 = this.addTemplate(template),
          dst = _this$addTemplate2.dst,
          src = _this$addTemplate2.src; // Add to nuxt layouts


      this.options.layouts[name || path__default.parse(src).name] = "./".concat(dst); // If error layout, set ErrorPage

      if (name === 'error') {
        this.addErrorLayout(dst);
      }
    }
  }, {
    key: "addErrorLayout",
    value: function addErrorLayout(dst) {
      var relativeBuildDir = path__default.relative(this.options.rootDir, this.options.buildDir);
      this.options.ErrorPage = "~/".concat(relativeBuildDir, "/").concat(dst);
    }
  }, {
    key: "addServerMiddleware",
    value: function addServerMiddleware(middleware) {
      this.options.serverMiddleware.push(middleware);
    }
  }, {
    key: "extendBuild",
    value: function extendBuild(fn) {
      this.options.build.extend = chainFn(this.options.build.extend, fn);
    }
  }, {
    key: "extendRoutes",
    value: function extendRoutes(fn) {
      this.options.router.extendRoutes = chainFn(this.options.router.extendRoutes, fn);
    }
  }, {
    key: "requireModule",
    value: function requireModule(moduleOpts) {
      return this.addModule(moduleOpts, true
      /* require once */
      );
    }
  }, {
    key: "addModule",
    value: function addModule(moduleOpts, requireOnce) {
      var _this = this;

      var src;
      var options;
      var handler; // Type 1: String

      if (typeof moduleOpts === 'string') {
        src = moduleOpts;
      } else if (Array.isArray(moduleOpts)) {
        // Type 2: Babel style array
        src = moduleOpts[0];
        options = moduleOpts[1];
      } else if (_typeof(moduleOpts) === 'object') {
        // Type 3: Pure object
        src = moduleOpts.src;
        options = moduleOpts.options;
        handler = moduleOpts.handler;
      } // Resolve handler


      if (!handler) {
        handler = this.nuxt.requireModule(src);
      } // Validate handler

      /* istanbul ignore if */


      if (typeof handler !== 'function') {
        throw new Error('Module should export a function: ' + src);
      } // Resolve module meta


      var key = handler.meta && handler.meta.name || handler.name || src; // Update requiredModules

      if (typeof key === 'string') {
        if (requireOnce && this.requiredModules[key]) {
          return;
        }

        this.requiredModules[key] = {
          src: src,
          options: options,
          handler: handler
        };
      } // Default module options to empty object


      if (options === undefined) {
        options = {};
      }

      return new Promise(function (resolve) {
        // Call module with `this` context and pass options
        var result = handler.call(_this, options); // If module send back a promise

        if (result && result.then) {
          return resolve(result);
        } // synchronous


        return resolve();
      });
    }
  }]);

  return ModuleContainer;
}();

var modes = {
  universal: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  spa: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
};

var nuxtDir = fs.existsSync(path__default.resolve(__dirname, '..', 'package.json')) ? path__default.resolve(__dirname, '..') // dist
: path__default.resolve(__dirname, '..', '..'); // src

var defaults = {
  // Information about running environment
  dev: Boolean(env.dev),
  debug: undefined,
  // = dev
  // Mode
  mode: 'universal',
  // Global name
  globalName: "nuxt",
  globals: {
    id: function id(globalName) {
      return "__".concat(globalName);
    },
    nuxt: function nuxt(globalName) {
      return "$".concat(globalName);
    },
    context: function context(globalName) {
      return "__".concat(globalName.toUpperCase(), "__");
    },
    pluginPrefix: function pluginPrefix(globalName) {
      return globalName;
    },
    readyCallback: function readyCallback(globalName) {
      return "on".concat(___default.capitalize(globalName), "Ready");
    },
    loadedCallback: function loadedCallback(globalName) {
      return "_on".concat(___default.capitalize(globalName), "Loaded");
    }
  },
  // Server options
  server: {
    https: false,
    port: process.env.NUXT_PORT || process.env.PORT || process.env.npm_package_config_nuxt_port,
    host: process.env.NUXT_HOST || process.env.HOST || process.env.npm_package_config_nuxt_host
  },
  // Dirs
  srcDir: undefined,
  buildDir: '.nuxt',
  nuxtDir: nuxtDir,
  nuxtAppDir: path__default.resolve(nuxtDir, 'lib', 'app'),
  modulesDir: ['node_modules'],
  // ~> relative to options.rootDir
  // Ignore
  ignorePrefix: '-',
  ignore: ['**/*.test.*', '**/*.spec.*'],
  extensions: [],
  build: {
    quiet: Boolean(env.ci || env.test),
    analyze: false,
    profile: process.argv.includes('--profile'),
    extractCSS: false,
    cssSourceMap: undefined,
    ssr: undefined,
    parallel: false,
    cache: false,
    publicPath: '/_nuxt/',
    filenames: {
      // { isDev, isClient, isServer }
      app: function app(_ref) {
        var isDev = _ref.isDev;
        return isDev ? '[name].js' : '[chunkhash].js';
      },
      chunk: function chunk(_ref2) {
        var isDev = _ref2.isDev;
        return isDev ? '[name].js' : '[chunkhash].js';
      },
      css: function css(_ref3) {
        var isDev = _ref3.isDev;
        return isDev ? '[name].css' : '[contenthash].css';
      },
      img: function img(_ref4) {
        var isDev = _ref4.isDev;
        return isDev ? '[path][name].[ext]' : 'img/[hash:7].[ext]';
      },
      font: function font(_ref5) {
        var isDev = _ref5.isDev;
        return isDev ? '[path][name].[ext]' : 'fonts/[hash:7].[ext]';
      },
      video: function video(_ref6) {
        var isDev = _ref6.isDev;
        return isDev ? '[path][name].[ext]' : 'videos/[hash:7].[ext]';
      }
    },
    loaders: {
      file: {},
      fontUrl: {
        limit: 1000
      },
      imgUrl: {
        limit: 1000
      },
      pugPlain: {},
      vue: {
        transformAssetUrls: {
          video: 'src',
          source: 'src',
          object: 'src',
          embed: 'src'
        }
      },
      css: {},
      cssModules: {
        localIdentName: '[local]_[hash:base64:5]'
      },
      less: {},
      sass: {
        indentedSyntax: true
      },
      scss: {},
      stylus: {},
      vueStyle: {}
    },
    styleResources: {},
    plugins: [],
    terser: {},
    optimizeCSS: undefined,
    optimization: {
      runtimeChunk: 'single',
      minimize: undefined,
      minimizer: undefined,
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '.',
        name: undefined,
        cacheGroups: {}
      }
    },
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    babel: {
      babelrc: false,
      cacheDirectory: undefined
    },
    transpile: [],
    // Name of NPM packages to be transpiled
    postcss: {
      preset: {
        // https://cssdb.org/#staging-process
        stage: 2
      }
    },
    html: {
      minify: {
        collapseBooleanAttributes: true,
        decodeEntities: true,
        minifyCSS: true,
        minifyJS: true,
        processConditionalComments: true,
        removeEmptyAttributes: true,
        removeRedundantAttributes: true,
        trimCustomFragments: true,
        useShortDoctype: true
      }
    },
    templates: [],
    watch: [],
    devMiddleware: {},
    hotMiddleware: {},
    stats: {
      chunks: false,
      children: false,
      modules: false,
      colors: true,
      warnings: true,
      errors: true,
      excludeAssets: [/.map$/, /index\..+\.html$/, /vue-ssr-client-manifest.json/]
    }
  },
  generate: {
    dir: 'dist',
    routes: [],
    concurrency: 500,
    interval: 0,
    subFolders: true,
    fallback: '200.html'
  },
  env: {},
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  plugins: [],
  css: [],
  modules: [],
  layouts: {},
  serverMiddleware: [],
  ErrorPage: null,
  loading: {
    color: 'black',
    failedColor: 'red',
    height: '2px',
    throttle: 200,
    duration: 5000,
    rtl: false
  },
  loadingIndicator: 'default',
  transition: {
    name: 'page',
    mode: 'out-in',
    appear: false,
    appearClass: 'appear',
    appearActiveClass: 'appear-active',
    appearToClass: 'appear-to'
  },
  layoutTransition: {
    name: 'layout',
    mode: 'out-in'
  },
  dir: {
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    pages: 'pages',
    static: 'static',
    store: 'store'
  },
  vue: {
    config: {
      silent: undefined,
      // = !dev
      performance: undefined // = dev

    }
  },
  router: {
    mode: 'history',
    base: '/',
    routes: [],
    middleware: [],
    linkActiveClass: 'nuxt-link-active',
    linkExactActiveClass: 'nuxt-link-exact-active',
    extendRoutes: null,
    scrollBehavior: null,
    parseQuery: false,
    stringifyQuery: false,
    fallback: false
  },
  render: {
    bundleRenderer: {
      shouldPrefetch: function shouldPrefetch() {
        return false;
      }
    },
    resourceHints: true,
    ssr: undefined,
    http2: {
      push: false,
      shouldPush: null
    },
    static: {
      prefix: true
    },
    compressor: {
      threshold: 0
    },
    etag: {
      weak: false
    },
    csp: false,
    dist: {
      // Don't serve index.html template
      index: false,
      // 1 year in production
      maxAge: '1y'
    }
  },
  // User-defined changes
  watch: [],
  watchers: {
    webpack: {},
    chokidar: {
      ignoreInitial: true
    }
  },
  editor: undefined,
  hooks: null,
  messages: {
    loading: 'Loading...',
    error_404: 'This page could not be found',
    server_error: 'Server error',
    nuxtjs: 'Nuxt.js',
    back_to_home: 'Back to the home page',
    server_error_details: 'An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.',
    client_error: 'Error',
    client_error_details: 'An error occurred while rendering the page. Check developer tools console for details.'
  }
};

var hasValue = function hasValue(v) {
  return typeof v === 'string' && v;
};

var Options = {};

Options.from = function (_options) {
  // Clone options to prevent unwanted side-effects
  var options = Object.assign({}, _options); // Normalize options

  if (options.loading === true) {
    delete options.loading;
  }

  if (options.router && options.router.middleware && !Array.isArray(options.router.middleware)) {
    options.router.middleware = [options.router.middleware];
  }

  if (options.router && typeof options.router.base === 'string') {
    options._routerBaseSpecified = true;
  }

  if (typeof options.transition === 'string') {
    options.transition = {
      name: options.transition
    };
  }

  if (typeof options.layoutTransition === 'string') {
    options.layoutTransition = {
      name: options.layoutTransition
    };
  }

  if (typeof options.extensions === 'string') {
    options.extensions = [options.extensions];
  }

  options.globalName = ___default.isString(options.globalName) && /^[a-zA-Z]+$/.test(options.globalName) ? options.globalName.toLowerCase() : 'nuxt'; // Resolve rootDir

  options.rootDir = hasValue(options.rootDir) ? path__default.resolve(options.rootDir) : process.cwd(); // Apply defaults by ${buildDir}/dist/build.config.js
  // TODO: Unsafe operation.
  // const buildDir = options.buildDir || defaults.buildDir
  // const buildConfig = resolve(options.rootDir, buildDir, 'build.config.js')
  // if (existsSync(buildConfig)) {
  //   _.defaultsDeep(options, require(buildConfig))
  // }
  // Apply defaults

  ___default.defaultsDeep(options, defaults); // Check srcDir and generate.dir excistence


  var hasSrcDir = hasValue(options.srcDir);
  var hasGenerateDir = hasValue(options.generate.dir); // Resolve srcDir

  options.srcDir = hasSrcDir ? path__default.resolve(options.rootDir, options.srcDir) : options.rootDir; // Resolve buildDir

  options.buildDir = path__default.resolve(options.rootDir, options.buildDir); // Protect rootDir against buildDir

  guardDir(options, 'rootDir', 'buildDir');

  if (hasGenerateDir) {
    // Resolve generate.dir
    options.generate.dir = path__default.resolve(options.rootDir, options.generate.dir); // Protect rootDir against buildDir

    guardDir(options, 'rootDir', 'generate.dir');
  }

  if (hasSrcDir) {
    // Protect srcDir against buildDir
    guardDir(options, 'srcDir', 'buildDir');

    if (hasGenerateDir) {
      // Protect srcDir against generate.dir
      guardDir(options, 'srcDir', 'generate.dir');
    }
  } // Populate modulesDir


  options.modulesDir = [].concat(options.modulesDir).concat(path__default.join(options.nuxtDir, 'node_modules')).filter(hasValue).map(function (dir) {
    return path__default.resolve(options.rootDir, dir);
  });
  var mandatoryExtensions = ['js', 'mjs'];
  options.extensions = mandatoryExtensions.filter(function (ext) {
    return !options.extensions.includes(ext);
  }).concat(options.extensions); // If app.html is defined, set the template path to the user template

  if (options.appTemplatePath === undefined) {
    options.appTemplatePath = path__default.resolve(options.buildDir, 'views/app.template.html');

    if (fs.existsSync(path__default.join(options.srcDir, 'app.html'))) {
      options.appTemplatePath = path__default.join(options.srcDir, 'app.html');
    }
  } else {
    options.appTemplatePath = path__default.resolve(options.srcDir, options.appTemplatePath);
  } // Ignore publicPath on dev

  /* istanbul ignore if */


  if (options.dev && isUrl(options.build.publicPath)) {
    options.build.publicPath = defaults.build.publicPath;
  } // If store defined, update store options to true unless explicitly disabled


  if (options.store !== false && fs.existsSync(path__default.join(options.srcDir, options.dir.store)) && fs.readdirSync(path__default.join(options.srcDir, options.dir.store)).find(function (filename) {
    return filename !== 'README.md' && filename[0] !== '.';
  })) {
    options.store = true;
  } // SPA loadingIndicator


  if (options.loadingIndicator) {
    // Normalize loadingIndicator
    if (!isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = {
        name: options.loadingIndicator
      };
    } // Apply defaults


    options.loadingIndicator = Object.assign({
      name: 'default',
      color: options.loading && options.loading.color || '#D3D3D3',
      color2: '#F5F5F5',
      background: options.manifest && options.manifest.theme_color || 'white',
      dev: options.dev,
      loading: options.messages.loading
    }, options.loadingIndicator);
  } // Debug errors


  if (options.debug === undefined) {
    options.debug = options.dev;
  } // Apply default hash to CSP option


  var csp = options.render.csp;
  var cspDefaults = {
    hashAlgorithm: 'sha256',
    allowedSources: undefined,
    policies: undefined,
    reportOnly: options.debug
  };

  if (csp) {
    options.render.csp = ___default.defaults(___default.isObject(csp) ? csp : {}, cspDefaults);
  } // cssSourceMap


  if (options.build.cssSourceMap === undefined) {
    options.build.cssSourceMap = options.dev;
  } // babel cacheDirectory


  if (options.build.babel.cacheDirectory === undefined) {
    options.build.babel.cacheDirectory = options.dev;
  } // vue config


  var vueConfig = options.vue.config;

  if (vueConfig.silent === undefined) {
    vueConfig.silent = !options.dev;
  }

  if (vueConfig.performance === undefined) {
    vueConfig.performance = options.dev;
  } // merge custom env with variables


  var eligibleEnvVariables = ___default.pick(process.env, Object.keys(process.env).filter(function (k) {
    return k.startsWith('NUXT_ENV_');
  }));

  Object.assign(options.env, eligibleEnvVariables); // Normalize ignore

  options.ignore = options.ignore ? [].concat(options.ignore) : []; // Append ignorePrefix glob to ignore

  if (typeof options.ignorePrefix === 'string') {
    options.ignore.push("**/".concat(options.ignorePrefix, "*.*"));
  } // Compression middleware legacy


  if (options.render.gzip) {
    consola.warn('render.gzip is deprecated and will be removed in a future version! Please switch to render.compressor');
    options.render.compressor = options.render.gzip;
    delete options.render.gzip;
  } // Apply mode preset


  var modePreset = modes[options.mode || 'universal'] || modes.universal;

  ___default.defaultsDeep(options, modePreset); // If no server-side rendering, add appear true transition

  /* istanbul ignore if */


  if (options.render.ssr === false && options.transition) {
    options.transition.appear = true;
  } // We assume the SPA fallback path is 404.html (for GitHub Pages, Surge, etc.)


  if (options.generate.fallback === true) {
    options.generate.fallback = '404.html';
  }

  if (options.build.stats === 'none' || options.build.quiet === true) {
    options.build.stats = false;
  } // Vendor backward compatibility with nuxt 1.x


  if (typeof options.build.vendor !== 'undefined') {
    delete options.build.vendor;
    consola.warn('vendor has been deprecated due to webpack4 optimization');
  } // TODO: remove when mini-css-extract-plugin supports HMR


  if (options.dev) {
    options.build.extractCSS = false;
  } // Enable minimize for production builds


  if (options.build.optimization.minimize === undefined) {
    options.build.optimization.minimize = !options.dev;
  } // Enable optimizeCSS only when extractCSS is enabled


  if (options.build.optimizeCSS === undefined) {
    options.build.optimizeCSS = options.build.extractCSS ? {} : false;
  }

  var loaders = options.build.loaders;
  var vueLoader = loaders.vue;

  if (vueLoader.productionMode === undefined) {
    vueLoader.productionMode = !options.dev;
  }

  var styleLoaders = ['css', 'cssModules', 'less', 'sass', 'scss', 'stylus', 'vueStyle'];

  for (var _i = 0; _i < styleLoaders.length; _i++) {
    var name = styleLoaders[_i];
    var loader = loaders[name];

    if (loader && loader.sourceMap === undefined) {
      loader.sourceMap = Boolean(options.build.cssSourceMap);
    }
  } // include SFCs in node_modules


  options.build.transpile = [].concat(options.build.transpile || []).map(function (module) {
    return module instanceof RegExp ? module : new RegExp(module);
  });

  if (options.build.quiet === true) {
    consola.level = 0;
  }

  return options;
};

var name = "nuxt";
var version = "2.2.0";
var description = "A minimalistic framework for server-rendered Vue.js applications (inspired by Next.js)";
var contributors = [
	{
		name: "Sebastien Chopin (@Atinux)"
	},
	{
		name: "Alexandre Chopin (@alexchopin)"
	},
	{
		name: "Pooya Parsa (@pi0)"
	},
	{
		name: "Clark Du (@clarkdo)"
	},
	{
		name: "Jonas Galvez (@galvez)"
	},
	{
		name: "Alexander Lichter (@manniL}"
	}
];
var main = "index.js";
var module$1 = "./lib/nuxt.js";
var license = "MIT";
var repository = {
	type: "git",
	url: "git+https://github.com/nuxt/nuxt.js"
};
var files = [
	"bin",
	"lib",
	"dist",
	"index.js"
];
var keywords = [
	"nuxt",
	"nuxt.js",
	"nuxtjs",
	"vue",
	"vue.js",
	"vuejs",
	"vue universal",
	"vue ssr",
	"vue server side",
	"ssr",
	"vue isomorphic",
	"vue versatile"
];
var homepage = "https://github.com/nuxt/nuxt.js#readme";
var bin = {
	nuxt: "./bin/nuxt"
};
var scripts = {
	build: "node -r esm ./packages/nuxt-pack/build.js",
	coverage: "codecov",
	lint: "eslint --ext .js,.mjs,.vue bin/** benchmarks examples lib packages test",
	postinstall: "opencollective || exit 0",
	test: "yarn test:fixtures && yarn test:unit",
	"test:fixtures": "jest test/fixtures",
	"test:e2e": "jest -i test/e2e",
	"test:lint": "yarn lint",
	"test:unit": "jest test/unit"
};
var engines = {
	node: ">=8.0.0",
	npm: ">=5.0.0"
};
var dependencies = {
	"@babel/core": "^7.1.2",
	"@babel/polyfill": "^7.0.0",
	"@nuxtjs/babel-preset-app": "^0.7.0",
	"@nuxtjs/devalue": "^1.0.0",
	"@nuxtjs/friendly-errors-webpack-plugin": "^2.0.2",
	"@nuxtjs/opencollective": "^0.1.0",
	"@nuxtjs/youch": "^4.2.3",
	"babel-loader": "^8.0.4",
	"cache-loader": "^1.2.2",
	"caniuse-lite": "^1.0.30000890",
	chalk: "^2.4.1",
	chokidar: "^2.0.4",
	compression: "^1.7.3",
	connect: "^3.6.6",
	consola: "^1.4.4",
	"css-loader": "^1.0.0",
	cssnano: "^4.1.4",
	debug: "^4.1.0",
	esm: "^3.0.84",
	etag: "^1.8.1",
	"file-loader": "^2.0.0",
	fresh: "^0.5.2",
	"fs-extra": "^7.0.0",
	glob: "^7.1.3",
	"hash-sum": "^1.0.2",
	"html-minifier": "^3.5.20",
	"html-webpack-plugin": "^3.2.0",
	ip: "^1.1.5",
	"launch-editor-middleware": "^2.2.1",
	lodash: "^4.17.11",
	"lru-cache": "^4.1.3",
	"memory-fs": "^0.4.1",
	"mini-css-extract-plugin": "^0.4.4",
	minimist: "^1.2.0",
	"optimize-css-assets-webpack-plugin": "^5.0.1",
	pify: "^4.0.0",
	postcss: "^7.0.5",
	"postcss-import": "^12.0.0",
	"postcss-import-resolver": "^1.1.0",
	"postcss-loader": "^3.0.0",
	"postcss-preset-env": "^6.1.1",
	"postcss-url": "^8.0.0",
	semver: "^5.6.0",
	"serialize-javascript": "^1.5.0",
	"serve-static": "^1.13.2",
	"server-destroy": "^1.0.1",
	"std-env": "^2.0.2",
	"style-resources-loader": "^1.2.1",
	"terser-webpack-plugin": "^1.1.0",
	"thread-loader": "^1.2.0",
	"time-fix-plugin": "^2.0.3",
	upath: "^1.1.0",
	"url-loader": "^1.1.2",
	vue: "^2.5.17",
	"vue-loader": "^15.4.2",
	"vue-meta": "^1.5.5",
	"vue-no-ssr": "^1.0.0",
	"vue-router": "^3.0.1",
	"vue-server-renderer": "^2.5.17",
	"vue-template-compiler": "^2.5.17",
	vuex: "^3.0.1",
	webpack: "^4.20.2",
	"webpack-bundle-analyzer": "^3.0.2",
	"webpack-dev-middleware": "^3.4.0",
	"webpack-hot-middleware": "^2.24.3",
	"webpack-node-externals": "^1.7.2",
	webpackbar: "^2.6.3"
};
var devDependencies = {
	"@babel/preset-env": "^7.1.0",
	"babel-core": "^7.0.0-bridge",
	"babel-eslint": "^10.0.1",
	"babel-jest": "^23.6.0",
	"babel-plugin-dynamic-import-node": "^2.2.0",
	codecov: "^3.1.0",
	"cross-env": "^5.2.0",
	"cross-spawn": "^6.0.5",
	eslint: "^5.7.0",
	"eslint-config-standard": "^12.0.0",
	"eslint-plugin-import": "^2.14.0",
	"eslint-plugin-jest": "^21.24.1",
	"eslint-plugin-node": "^7.0.1",
	"eslint-plugin-promise": "^4.0.1",
	"eslint-plugin-standard": "^4.0.0",
	"eslint-plugin-vue": "^5.0.0-beta.3",
	express: "^4.16.4",
	finalhandler: "^1.1.1",
	"get-port": "^4.0.0",
	jest: "^23.6.0",
	jsdom: "^12.2.0",
	"klaw-sync": "^6.0.0",
	pug: "^2.0.3",
	"pug-plain-loader": "^1.0.0",
	puppeteer: "^1.9.0",
	request: "^2.88.0",
	"request-promise-native": "^1.0.5",
	rimraf: "^2.6.2",
	rollup: "^0.66.6",
	"rollup-plugin-babel": "^4.0.3",
	"rollup-plugin-commonjs": "^9.2.0",
	"rollup-plugin-json": "^3.1.0",
	"rollup-plugin-license": "^0.7.0"
};
var collective = {
	url: "https://opencollective.com/nuxtjs",
	logoUrl: "https://opencollective.com/nuxtjs/logo.txt?reverse=true&variant=variant2"
};
var packageJSON = {
	name: name,
	version: version,
	description: description,
	contributors: contributors,
	main: main,
	module: module$1,
	license: license,
	repository: repository,
	files: files,
	keywords: keywords,
	homepage: homepage,
	bin: bin,
	scripts: scripts,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	collective: collective
};

var MetaRenderer =
/*#__PURE__*/
function () {
  function MetaRenderer(nuxt, renderer) {
    _classCallCheck(this, MetaRenderer);

    this.nuxt = nuxt;
    this.renderer = renderer;
    this.options = nuxt.options;
    this.vueRenderer = vueServerRenderer.createRenderer();
    this.cache = LRU({}); // Add VueMeta to Vue (this is only for SPA mode)
    // See lib/app/index.js

    Vue.use(VueMeta, {
      keyName: 'head',
      attribute: 'data-n-head',
      ssrAttribute: 'data-n-head-ssr',
      tagIDKeyName: 'hid'
    });
  }

  _createClass(MetaRenderer, [{
    key: "getMeta",
    value: function () {
      var _getMeta = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(url) {
        var vm;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                vm = new Vue({
                  render: function render(h) {
                    return h();
                  },
                  // Render empty html tag
                  head: this.options.head || {}
                });
                _context.next = 3;
                return this.vueRenderer.renderToString(vm);

              case 3:
                return _context.abrupt("return", vm.$meta().inject());

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getMeta(_x) {
        return _getMeta.apply(this, arguments);
      };
    }()
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(_ref) {
        var _ref$url, url, meta, m, clientManifest, shouldPreload, shouldPrefetch, publicPath;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref$url = _ref.url, url = _ref$url === void 0 ? '/' : _ref$url;
                meta = this.cache.get(url);

                if (!meta) {
                  _context2.next = 4;
                  break;
                }

                return _context2.abrupt("return", meta);

              case 4:
                meta = {
                  HTML_ATTRS: '',
                  BODY_ATTRS: '',
                  HEAD: '',
                  BODY_SCRIPTS: '' // Get vue-meta context

                };
                _context2.next = 7;
                return this.getMeta(url);

              case 7:
                m = _context2.sent;
                // HTML_ATTRS
                meta.HTML_ATTRS = m.htmlAttrs.text(); // BODY_ATTRS

                meta.BODY_ATTRS = m.bodyAttrs.text(); // HEAD tags

                meta.HEAD = m.title.text() + m.meta.text() + m.link.text() + m.style.text() + m.script.text() + m.noscript.text(); // BODY_SCRIPTS

                meta.BODY_SCRIPTS = m.script.text({
                  body: true
                }) + m.noscript.text({
                  body: true
                }); // Resources Hints

                meta.resourceHints = '';
                clientManifest = this.renderer.resources.clientManifest;

                shouldPreload = this.options.render.bundleRenderer.shouldPreload || function () {
                  return true;
                };

                shouldPrefetch = this.options.render.bundleRenderer.shouldPrefetch || function () {
                  return true;
                };

                if (this.options.render.resourceHints && clientManifest) {
                  publicPath = clientManifest.publicPath || '/_nuxt/'; // Preload initial resources

                  if (Array.isArray(clientManifest.initial)) {
                    meta.resourceHints += clientManifest.initial.filter(function (file) {
                      return shouldPreload(file);
                    }).map(function (r) {
                      return "<link rel=\"preload\" href=\"".concat(publicPath).concat(r, "\" as=\"script\" />");
                    }).join('');
                  } // Prefetch async resources


                  if (Array.isArray(clientManifest.async)) {
                    meta.resourceHints += clientManifest.async.filter(function (file) {
                      return shouldPrefetch(file);
                    }).map(function (r) {
                      return "<link rel=\"prefetch\" href=\"".concat(publicPath).concat(r, "\" />");
                    }).join('');
                  } // Add them to HEAD


                  if (meta.resourceHints) {
                    meta.HEAD += meta.resourceHints;
                  }
                } // Emulate getPreloadFiles from vue-server-renderer (works for JS chunks only)


                meta.getPreloadFiles = function () {
                  return clientManifest.initial.filter(function (file) {
                    return shouldPreload(file);
                  }).map(function (r) {
                    return {
                      file: r,
                      fileWithoutQuery: r,
                      asType: 'script',
                      extension: 'js'
                    };
                  });
                }; // Set meta tags inside cache


                this.cache.set(url, meta);
                return _context2.abrupt("return", meta);

              case 20:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function render(_x2) {
        return _render.apply(this, arguments);
      };
    }()
  }]);

  return MetaRenderer;
}();

function errorMiddleware(err, req, res, next) {
  // ensure statusCode, message and name fields
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Nuxt Server Error';
  err.name = !err.name || err.name === 'Error' ? 'NuxtServerError' : err.name; // We hide actual errors from end users, so show them on server logs

  if (err.statusCode !== 404) {
    consola.error(err);
  }

  var sendResponse = function sendResponse(content) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text/html';
    // Set Headers
    res.statusCode = err.statusCode;
    res.statusMessage = err.name;
    res.setHeader('Content-Type', type + '; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(content));
    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate'); // Send Response

    res.end(content, 'utf-8');
  }; // Check if request accepts JSON


  var hasReqHeader = function hasReqHeader(header, includes) {
    return req.headers[header] && req.headers[header].toLowerCase().includes(includes);
  };

  var isJson = hasReqHeader('accept', 'application/json') || hasReqHeader('user-agent', 'curl/'); // Use basic errors when debug mode is disabled

  if (!this.options.debug) {
    // Json format is compatible with Youch json responses
    var json = {
      status: err.statusCode,
      message: err.message,
      name: err.name
    };

    if (isJson) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
      return;
    }

    var html = this.resources.errorTemplate(json);
    sendResponse(html);
    return;
  } // Show stack trace


  var youch = new Youch(err, req, readSource.bind(this), this.options.router.base, true);

  if (isJson) {
    youch.toJSON().then(function (json) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
    });
  } else {
    youch.toHTML().then(function (html) {
      return sendResponse(html);
    });
  }
}

function readSource(_x) {
  return _readSource.apply(this, arguments);
}

function _readSource() {
  _readSource = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(frame) {
    var sanitizeName, searchPath, _i, pathDir, fullPath, source;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // Remove webpack:/// & query string from the end
            sanitizeName = function sanitizeName(name) {
              return name ? name.replace('webpack:///', '').split('?')[0] : null;
            };

            frame.fileName = sanitizeName(frame.fileName); // Return if fileName is unknown

            /* istanbul ignore if */

            if (frame.fileName) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return");

          case 4:
            // Possible paths for file
            searchPath = [this.options.srcDir, this.options.rootDir, path__default.join(this.options.buildDir, 'dist', 'server'), this.options.buildDir, process.cwd()]; // Scan filesystem for real source

            _i = 0;

          case 6:
            if (!(_i < searchPath.length)) {
              _context.next = 20;
              break;
            }

            pathDir = searchPath[_i];
            fullPath = path__default.resolve(pathDir, frame.fileName);
            _context.next = 11;
            return fsExtra.readFile(fullPath, 'utf-8').catch(function () {
              return null;
            });

          case 11:
            source = _context.sent;

            if (!source) {
              _context.next = 17;
              break;
            }

            frame.contents = source;
            frame.fullPath = fullPath;

            if (path__default.isAbsolute(frame.fileName)) {
              frame.fileName = path__default.relative(this.options.rootDir, fullPath);
            }

            return _context.abrupt("return");

          case 17:
            _i++;
            _context.next = 6;
            break;

          case 20:
            // Fallback: use server bundle
            // TODO: restore to if after https://github.com/istanbuljs/nyc/issues/595 fixed

            /* istanbul ignore next */
            if (!frame.contents) {
              frame.contents = this.resources.serverBundle.files[frame.fileName];
            }

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
  return _readSource.apply(this, arguments);
}

function nuxtMiddleware(_x, _x2, _x3) {
  return _nuxtMiddleware.apply(this, arguments);
}

function _nuxtMiddleware() {
  _nuxtMiddleware = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee(req, res, next) {
    var context, result, html, cspScriptSrcHashSet, error, redirected, getPreloadFiles, etag, pushAssets, preloadFiles, shouldPush, publicPath, _this$options$render$, allowedSources, policies, cspHeader;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // Get context
            context = getContext(req, res);
            res.statusCode = 200;
            _context.prev = 2;
            _context.next = 5;
            return this.renderRoute(req.url, context);

          case 5:
            result = _context.sent;
            _context.next = 8;
            return this.nuxt.callHook('render:route', req.url, result, context);

          case 8:
            html = result.html, cspScriptSrcHashSet = result.cspScriptSrcHashSet, error = result.error, redirected = result.redirected, getPreloadFiles = result.getPreloadFiles;

            if (!redirected) {
              _context.next = 12;
              break;
            }

            this.nuxt.callHook('render:routeDone', req.url, result, context);
            return _context.abrupt("return", html);

          case 12:
            if (error) {
              res.statusCode = context.nuxt.error.statusCode || 500;
            } // Add ETag header


            if (!(!error && this.options.render.etag)) {
              _context.next = 21;
              break;
            }

            etag = generateETag(html, this.options.render.etag);

            if (!fresh(req.headers, {
              etag: etag
            })) {
              _context.next = 20;
              break;
            }

            res.statusCode = 304;
            res.end();
            this.nuxt.callHook('render:routeDone', req.url, result, context);
            return _context.abrupt("return");

          case 20:
            res.setHeader('ETag', etag);

          case 21:
            // HTTP2 push headers for preload assets
            if (!error && this.options.render.http2.push) {
              // Parse resourceHints to extract HTTP.2 prefetch/push headers
              // https://w3c.github.io/preload/#server-push-http-2
              pushAssets = [];
              preloadFiles = getPreloadFiles();
              shouldPush = this.options.render.http2.shouldPush;
              publicPath = this.resources.clientManifest.publicPath;
              preloadFiles.forEach(function (_ref4) {
                var file = _ref4.file,
                    asType = _ref4.asType,
                    fileWithoutQuery = _ref4.fileWithoutQuery;

                // By default, we only preload scripts or css

                /* istanbul ignore if */
                if (!shouldPush && asType !== 'script' && asType !== 'style') {
                  return;
                } // User wants to explicitly control what to preload


                if (shouldPush && !shouldPush(fileWithoutQuery, asType)) {
                  return;
                }

                pushAssets.push("<".concat(publicPath).concat(file, ">; rel=preload; as=").concat(asType));
              }); // Pass with single Link header
              // https://blog.cloudflare.com/http-2-server-push-with-multiple-assets-per-link-header
              // https://www.w3.org/Protocols/9707-link-header.html

              res.setHeader('Link', pushAssets.join(','));
            }

            if (this.options.render.csp) {
              _this$options$render$ = this.options.render.csp, allowedSources = _this$options$render$.allowedSources, policies = _this$options$render$.policies;
              cspHeader = this.options.render.csp.reportOnly ? 'Content-Security-Policy-Report-Only' : 'Content-Security-Policy';
              res.setHeader(cspHeader, getCspString({
                cspScriptSrcHashSet: cspScriptSrcHashSet,
                allowedSources: allowedSources,
                policies: policies,
                isDev: this.options.dev
              }));
            } // Send response


            res.setHeader('Content-Type', 'text/html; charset=utf-8');
            res.setHeader('Content-Length', Buffer.byteLength(html));
            res.end(html, 'utf8');
            this.nuxt.callHook('render:routeDone', req.url, result, context);
            return _context.abrupt("return", html);

          case 30:
            _context.prev = 30;
            _context.t0 = _context["catch"](2);

            if (!(context && context.redirected)) {
              _context.next = 35;
              break;
            }

            consola.error(_context.t0);
            return _context.abrupt("return", _context.t0);

          case 35:
            next(_context.t0);

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this, [[2, 30]]);
  }));
  return _nuxtMiddleware.apply(this, arguments);
}

var getCspString = function getCspString(_ref) {
  var cspScriptSrcHashSet = _ref.cspScriptSrcHashSet,
      allowedSources = _ref.allowedSources,
      policies = _ref.policies,
      isDev = _ref.isDev;
  var joinedHashSet = Array.from(cspScriptSrcHashSet).join(' ');
  var baseCspStr = "script-src 'self'".concat(isDev ? " 'unsafe-eval'" : '', " ").concat(joinedHashSet);

  if (Array.isArray(allowedSources)) {
    return "".concat(baseCspStr, " ").concat(allowedSources.join(' '));
  }

  var policyObjectAvailable = _typeof(policies) === 'object' && policies !== null && !Array.isArray(policies);

  if (policyObjectAvailable) {
    var transformedPolicyObject = transformPolicyObject(policies, cspScriptSrcHashSet);
    return Object.entries(transformedPolicyObject).map(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          k = _ref3[0],
          v = _ref3[1];

      return "".concat(k, " ").concat(v.join(' '));
    }).join('; ');
  }

  return baseCspStr;
};

var transformPolicyObject = function transformPolicyObject(policies, cspScriptSrcHashSet) {
  var userHasDefinedScriptSrc = policies['script-src'] && Array.isArray(policies['script-src']); // Self is always needed for inline-scripts, so add it, no matter if the user specified script-src himself.

  var hashAndPolicySet = cspScriptSrcHashSet;
  hashAndPolicySet.add("'self'");

  if (!userHasDefinedScriptSrc) {
    policies['script-src'] = Array.from(hashAndPolicySet);
    return policies;
  }

  new Set(policies['script-src']).forEach(function (src) {
    return hashAndPolicySet.add(src);
  });
  policies['script-src'] = Array.from(hashAndPolicySet);
  return policies;
};

var jsdom = null;

var Renderer =
/*#__PURE__*/
function () {
  function Renderer(nuxt) {
    _classCallCheck(this, Renderer);

    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.globals = determineGlobals(nuxt.options.globalName, nuxt.options.globals); // Will be set by createRenderer

    this.bundleRenderer = null;
    this.metaRenderer = null; // Will be available on dev

    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null; // Create new connect instance

    this.app = connect(); // Renderer runtime resources

    this.resources = {
      clientManifest: null,
      serverBundle: null,
      ssrTemplate: null,
      spaTemplate: null,
      errorTemplate: parseTemplate('Nuxt.js Internal Server Error')
    };
  }

  _createClass(Renderer, [{
    key: "ready",
    value: function () {
      var _ready = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.nuxt.callHook('render:before', this, this.options.render);

              case 2:
                _context.next = 4;
                return this.setupMiddleware();

              case 4:
                if (this.options.dev) {
                  _context.next = 7;
                  break;
                }

                _context.next = 7;
                return this.loadResources();

              case 7:
                _context.next = 9;
                return this.nuxt.callHook('render:done', this);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function ready() {
        return _ready.apply(this, arguments);
      };
    }()
  }, {
    key: "loadResources",
    value: function () {
      var _loadResources = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _this = this;

        var _fs,
            distPath,
            updated,
            errorTemplatePath,
            loadingHTMLPath,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _fs = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : fsExtra;
                distPath = path__default.resolve(this.options.buildDir, 'dist', 'server');
                updated = [];
                resourceMap.forEach(function (_ref) {
                  var key = _ref.key,
                      fileName = _ref.fileName,
                      transform = _ref.transform;
                  var rawKey = '$$' + key;

                  var _path = path__default.join(distPath, fileName);

                  if (!_fs.existsSync(_path)) {
                    return; // Resource not exists
                  }

                  var rawData = _fs.readFileSync(_path, 'utf8');

                  if (!rawData || rawData === _this.resources[rawKey]) {
                    return; // No changes
                  }

                  _this.resources[rawKey] = rawData;
                  var data = transform(rawData);
                  /* istanbul ignore if */

                  if (!data) {
                    return; // Invalid data ?
                  }

                  _this.resources[key] = data;
                  updated.push(key);
                }); // Reload error template

                errorTemplatePath = path__default.resolve(this.options.buildDir, 'views/error.html');

                if (fsExtra.existsSync(errorTemplatePath)) {
                  this.resources.errorTemplate = parseTemplate(fsExtra.readFileSync(errorTemplatePath, 'utf8'));
                } // Load loading template


                loadingHTMLPath = path__default.resolve(this.options.buildDir, 'loading.html');

                if (fsExtra.existsSync(loadingHTMLPath)) {
                  this.resources.loadingHTML = fsExtra.readFileSync(loadingHTMLPath, 'utf8');
                  this.resources.loadingHTML = this.resources.loadingHTML.replace(/\r|\n|[\t\s]{3,}/g, '');
                } else {
                  this.resources.loadingHTML = '';
                } // Call resourcesLoaded plugin


                _context2.next = 10;
                return this.nuxt.callHook('render:resourcesLoaded', this.resources);

              case 10:
                if (updated.length > 0) {
                  this.createRenderer();
                }

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function loadResources() {
        return _loadResources.apply(this, arguments);
      };
    }()
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      // Ensure resources are available
      if (!this.isResourcesAvailable) {
        return;
      } // Create Meta Renderer


      this.metaRenderer = new MetaRenderer(this.nuxt, this); // Skip following steps if noSSR mode

      if (this.noSSR) {
        return;
      }

      var hasModules = fsExtra.existsSync(path__default.resolve(this.options.rootDir, 'node_modules')); // Create bundle renderer for SSR

      this.bundleRenderer = vueServerRenderer.createBundleRenderer(this.resources.serverBundle, Object.assign({
        clientManifest: this.resources.clientManifest,
        runInNewContext: false,
        // for globally installed nuxt command, search dependencies in global dir
        basedir: hasModules ? this.options.rootDir : __dirname
      }, this.options.render.bundleRenderer));
    }
  }, {
    key: "useMiddleware",
    value: function useMiddleware(m) {
      // Resolve
      var $m = m;

      if (typeof m === 'string') {
        m = this.nuxt.requireModule(m);
      }

      if (typeof m.handler === 'string') {
        m.handler = this.nuxt.requireModule(m.handler);
      }

      var handler = m.handler || m;
      var path$$1 = ((m.prefix !== false ? this.options.router.base : '') + (typeof m.path === 'string' ? m.path : '')).replace(/\/\//g, '/');
      handler.$m = $m; // Use middleware

      this.app.use(path$$1, handler);
    }
  }, {
    key: "setupMiddleware",
    value: function () {
      var _setupMiddleware = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;

        var compressor, compression, staticMiddleware, distDir;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.nuxt.callHook('render:setupMiddleware', this.app);

              case 2:
                // Compression middleware for production
                if (!this.options.dev) {
                  compressor = this.options.render.compressor;

                  if (_typeof(compressor) === 'object') {
                    // If only setting for `compression` are provided, require the module and insert
                    // Prefer require instead of requireModule to keep dependency in nuxt-start
                    compression = require('compression');
                    this.useMiddleware(compression(compressor));
                  } else {
                    // Else, require own compression middleware
                    this.useMiddleware(compressor);
                  }
                } // Add webpack middleware only for development


                if (this.options.dev) {
                  this.useMiddleware(
                  /*#__PURE__*/
                  function () {
                    var _ref2 = _asyncToGenerator(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee3(req, res, next) {
                      return regeneratorRuntime.wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              if (!_this2.webpackDevMiddleware) {
                                _context3.next = 3;
                                break;
                              }

                              _context3.next = 3;
                              return _this2.webpackDevMiddleware(req, res);

                            case 3:
                              if (!_this2.webpackHotMiddleware) {
                                _context3.next = 6;
                                break;
                              }

                              _context3.next = 6;
                              return _this2.webpackHotMiddleware(req, res);

                            case 6:
                              next();

                            case 7:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3, this);
                    }));

                    return function (_x, _x2, _x3) {
                      return _ref2.apply(this, arguments);
                    };
                  }());
                } // open in editor for debug mode only


                if (this.options.debug && this.options.dev) {
                  this.useMiddleware({
                    path: '__open-in-editor',
                    handler: launchMiddleware(this.options.editor)
                  });
                } // For serving static/ files to /


                staticMiddleware = serveStatic(path__default.resolve(this.options.srcDir, this.options.dir.static), this.options.render.static);
                staticMiddleware.prefix = this.options.render.static.prefix;
                this.useMiddleware(staticMiddleware); // Serve .nuxt/dist/ files only for production
                // For dev they will be served with devMiddleware

                if (!this.options.dev) {
                  distDir = path__default.resolve(this.options.buildDir, 'dist', 'client');
                  this.useMiddleware({
                    path: this.publicPath,
                    handler: serveStatic(distDir, this.options.render.dist)
                  });
                } // Add User provided middleware


                this.options.serverMiddleware.forEach(function (m) {
                  _this2.useMiddleware(m);
                }); // Finally use nuxtMiddleware

                this.useMiddleware(nuxtMiddleware.bind(this)); // Error middleware for errors that occurred in middleware that declared above
                // Middleware should exactly take 4 arguments
                // https://github.com/senchalabs/connect#error-middleware
                // Apply errorMiddleware from modules first

                _context4.next = 13;
                return this.nuxt.callHook('render:errorMiddleware', this.app);

              case 13:
                // Apply errorMiddleware from Nuxt
                this.useMiddleware(errorMiddleware.bind(this));

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function setupMiddleware() {
        return _setupMiddleware.apply(this, arguments);
      };
    }()
  }, {
    key: "renderTemplate",
    value: function renderTemplate(ssr, opts) {
      // Fix problem with HTMLPlugin's minify option (#3392)
      opts.html_attrs = opts.HTML_ATTRS;
      opts.body_attrs = opts.BODY_ATTRS;
      var fn = ssr ? this.resources.ssrTemplate : this.resources.spaTemplate;
      return fn(opts);
    }
  }, {
    key: "renderRoute",
    value: function () {
      var _renderRoute = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(url) {
        var context,
            spa,
            ENV,
            _ref3,
            HTML_ATTRS,
            BODY_ATTRS,
            _HEAD,
            BODY_SCRIPTS,
            getPreloadFiles,
            _APP,
            err,
            _html,
            APP,
            m,
            HEAD,
            serializedSession,
            cspScriptSrcHashSet,
            hashAlgorithm,
            hash$$1,
            html,
            _args5 = arguments;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                context = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};

                if (this.isReady) {
                  _context5.next = 5;
                  break;
                }

                _context5.next = 4;
                return waitFor(1000);

              case 4:
                return _context5.abrupt("return", this.renderRoute(url, context));

              case 5:
                // Log rendered url
                consola.debug("Rendering url ".concat(url)); // Add url and isSever to the context

                context.url = url; // Basic response if SSR is disabled or spa data provided

                spa = context.spa || context.res && context.res.spa;
                ENV = this.options.env;

                if (!(this.noSSR || spa)) {
                  _context5.next = 24;
                  break;
                }

                _context5.next = 12;
                return this.metaRenderer.render(context);

              case 12:
                _ref3 = _context5.sent;
                HTML_ATTRS = _ref3.HTML_ATTRS;
                BODY_ATTRS = _ref3.BODY_ATTRS;
                _HEAD = _ref3.HEAD;
                BODY_SCRIPTS = _ref3.BODY_SCRIPTS;
                getPreloadFiles = _ref3.getPreloadFiles;
                _APP = "<div id=\"".concat(this.globals.id, "\">").concat(this.resources.loadingHTML, "</div>") + BODY_SCRIPTS; // Detect 404 errors

                if (!(url.includes(this.options.build.publicPath) || url.includes('__webpack'))) {
                  _context5.next = 22;
                  break;
                }

                err = {
                  statusCode: 404,
                  message: this.options.messages.error_404,
                  name: 'ResourceNotFound'
                };
                throw err;

              case 22:
                _html = this.renderTemplate(false, {
                  HTML_ATTRS: HTML_ATTRS,
                  BODY_ATTRS: BODY_ATTRS,
                  HEAD: _HEAD,
                  APP: _APP,
                  ENV: ENV
                });
                return _context5.abrupt("return", {
                  html: _html,
                  getPreloadFiles: getPreloadFiles
                });

              case 24:
                _context5.next = 26;
                return this.bundleRenderer.renderToString(context);

              case 26:
                APP = _context5.sent;

                if (!context.nuxt.serverRendered) {
                  APP = "<div id=\"".concat(this.globals.id, "\"></div>");
                }

                m = context.meta.inject();
                HEAD = m.title.text() + m.meta.text() + m.link.text() + m.style.text() + m.script.text() + m.noscript.text();

                if (this.options._routerBaseSpecified) {
                  HEAD += "<base href=\"".concat(this.options.router.base, "\">");
                }

                if (this.options.render.resourceHints) {
                  HEAD += context.renderResourceHints();
                }

                _context5.next = 34;
                return this.nuxt.callHook('render:routeContext', context.nuxt);

              case 34:
                serializedSession = "window.".concat(this.globals.context, "=").concat(devalue(context.nuxt), ";");
                cspScriptSrcHashSet = new Set();

                if (this.options.render.csp) {
                  hashAlgorithm = this.options.render.csp.hashAlgorithm;
                  hash$$1 = crypto.createHash(hashAlgorithm);
                  hash$$1.update(serializedSession);
                  cspScriptSrcHashSet.add("'".concat(hashAlgorithm, "-").concat(hash$$1.digest('base64'), "'"));
                }

                APP += "<script>".concat(serializedSession, "</script>");
                APP += context.renderScripts();
                APP += m.script.text({
                  body: true
                });
                APP += m.noscript.text({
                  body: true
                });
                HEAD += context.renderStyles();
                html = this.renderTemplate(true, {
                  HTML_ATTRS: 'data-n-head-ssr ' + m.htmlAttrs.text(),
                  BODY_ATTRS: m.bodyAttrs.text(),
                  HEAD: HEAD,
                  APP: APP,
                  ENV: ENV
                });
                return _context5.abrupt("return", {
                  html: html,
                  cspScriptSrcHashSet: cspScriptSrcHashSet,
                  getPreloadFiles: context.getPreloadFiles,
                  error: context.nuxt.error,
                  redirected: context.redirected
                });

              case 44:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function renderRoute(_x4) {
        return _renderRoute.apply(this, arguments);
      };
    }()
  }, {
    key: "renderAndGetWindow",
    value: function () {
      var _renderAndGetWindow = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(url) {
        var opts,
            options,
            jsdomErrHandler,
            _ref4,
            window,
            nuxtExists,
            error,
            onNuxtLoaded,
            _args6 = arguments;

        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (jsdom) {
                  _context6.next = 10;
                  break;
                }

                _context6.prev = 2;
                jsdom = require('jsdom');
                _context6.next = 10;
                break;

              case 6:
                _context6.prev = 6;
                _context6.t0 = _context6["catch"](2);
                consola.error("\n         Fail when calling nuxt.renderAndGetWindow(url)\n         jsdom module is not installed\n         Please install jsdom with: npm install --save-dev jsdom\n        ");
                throw _context6.t0;

              case 10:
                options = Object.assign({
                  resources: 'usable',
                  // load subresources (https://github.com/tmpvar/jsdom#loading-subresources)
                  runScripts: 'dangerously',
                  virtualConsole: true,
                  beforeParse: function beforeParse(window) {
                    // Mock window.scrollTo
                    window.scrollTo = function () {};
                  }
                }, opts);

                jsdomErrHandler = function jsdomErrHandler(err) {
                  throw err;
                };

                if (options.virtualConsole) {
                  if (options.virtualConsole === true) {
                    options.virtualConsole = new jsdom.VirtualConsole().sendTo(consola);
                  } // throw error when window creation failed


                  options.virtualConsole.on('jsdomError', jsdomErrHandler);
                }

                url = url || 'http://localhost:3000';
                _context6.next = 16;
                return jsdom.JSDOM.fromURL(url, options);

              case 16:
                _ref4 = _context6.sent;
                window = _ref4.window;
                // If Nuxt could not be loaded (error from the server-side)
                nuxtExists = window.document.body.innerHTML.includes(this.options.render.ssr ? "window.".concat(this.globals.context) : "<div id=\"".concat(this.globals.id, "\">"));
                /* istanbul ignore if */

                if (nuxtExists) {
                  _context6.next = 23;
                  break;
                }

                error = new Error('Could not load the nuxt app');
                error.body = window.document.body.innerHTML;
                throw error;

              case 23:
                // Used by nuxt.js to say when the components are loaded and the app ready
                onNuxtLoaded = this.globals.loadedCallback;
                _context6.next = 26;
                return timeout(new Promise(function (resolve) {
                  window[onNuxtLoaded] = function () {
                    return resolve(window);
                  };
                }), 20000, 'Components loading in renderAndGetWindow was not completed in 20s');

              case 26:
                if (options.virtualConsole) {
                  // after window initialized successfully
                  options.virtualConsole.removeListener('jsdomError', jsdomErrHandler);
                } // Send back window object


                return _context6.abrupt("return", window);

              case 28:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[2, 6]]);
      }));

      return function renderAndGetWindow(_x5) {
        return _renderAndGetWindow.apply(this, arguments);
      };
    }()
  }, {
    key: "noSSR",
    get: function get() {
      return this.options.render.ssr === false;
    }
  }, {
    key: "isReady",
    get: function get() {
      if (this.noSSR) {
        return Boolean(this.resources.spaTemplate);
      }

      return Boolean(this.bundleRenderer && this.resources.ssrTemplate);
    }
  }, {
    key: "isResourcesAvailable",
    get: function get() {
      // Required for both

      /* istanbul ignore if */
      if (!this.resources.clientManifest) {
        return false;
      } // Required for SPA rendering


      if (this.noSSR) {
        return Boolean(this.resources.spaTemplate);
      } // Required for bundle renderer


      return Boolean(this.resources.ssrTemplate && this.resources.serverBundle);
    }
  }, {
    key: "publicPath",
    get: function get() {
      return isUrl(this.options.build.publicPath) ? defaults.build.publicPath : this.options.build.publicPath;
    }
  }]);

  return Renderer;
}();

var parseTemplate = function parseTemplate(templateStr) {
  return ___default.template(templateStr, {
    interpolate: /{{([\s\S]+?)}}/g
  });
};

var resourceMap = [{
  key: 'clientManifest',
  fileName: 'vue-ssr-client-manifest.json',
  transform: JSON.parse
}, {
  key: 'serverBundle',
  fileName: 'server-bundle.json',
  transform: JSON.parse
}, {
  key: 'ssrTemplate',
  fileName: 'index.ssr.html',
  transform: parseTemplate
}, {
  key: 'spaTemplate',
  fileName: 'index.spa.html',
  transform: parseTemplate
}];

var Nuxt =
/*#__PURE__*/
function () {
  function Nuxt() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Nuxt);

    this.options = Options.from(options);
    this.readyMessage = null;
    this.initialized = false; // Hooks

    this._hooks = {};
    this.hook = this.hook.bind(this); // Create instance of core components

    this.moduleContainer = new ModuleContainer(this);
    this.renderer = new Renderer(this); // Backward compatibility

    this.render = this.renderer.app;
    this.renderRoute = this.renderer.renderRoute.bind(this.renderer);
    this.renderAndGetWindow = this.renderer.renderAndGetWindow.bind(this.renderer);
    this.resolvePath = this.resolvePath.bind(this);
    this.resolveAlias = this.resolveAlias.bind(this); // ESM Loader

    this.esm = esm(module, {});
    this._ready = this.ready().catch(function (err) {
      consola.fatal(err);
    });
  }

  _createClass(Nuxt, [{
    key: "ready",
    value: function () {
      var _ready = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._ready) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this._ready);

              case 2:
                // Add hooks
                if (___default.isPlainObject(this.options.hooks)) {
                  this.addHooks(this.options.hooks);
                } else if (typeof this.options.hooks === 'function') {
                  this.options.hooks(this.hook);
                } // Await for modules


                _context.next = 5;
                return this.moduleContainer.ready();

              case 5:
                _context.next = 7;
                return this.renderer.ready();

              case 7:
                this.initialized = true; // Call ready hook

                _context.next = 10;
                return this.callHook('ready', this);

              case 10:
                return _context.abrupt("return", this);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function ready() {
        return _ready.apply(this, arguments);
      };
    }()
  }, {
    key: "hook",
    value: function hook(name$$1, fn) {
      if (!name$$1 || typeof fn !== 'function') {
        return;
      }

      if (name$$1 === 'render:context') {
        name$$1 = 'render:routeContext';
        consola.warn('render:context hook has been deprecated, please use render:routeContext');
      }

      this._hooks[name$$1] = this._hooks[name$$1] || [];

      this._hooks[name$$1].push(fn);
    }
  }, {
    key: "callHook",
    value: function () {
      var _callHook = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(name$$1) {
        var _len,
            args,
            _key,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                for (_len = _args2.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = _args2[_key];
                }

                if (this._hooks[name$$1]) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                consola.debug("Call ".concat(name$$1, " hooks (").concat(this._hooks[name$$1].length, ")"));
                _context2.prev = 4;
                _context2.next = 7;
                return sequence(this._hooks[name$$1], function (fn) {
                  return fn.apply(void 0, args);
                });

              case 7:
                _context2.next = 13;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](4);
                consola.error(_context2.t0);
                this.callHook('error', _context2.t0);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[4, 9]]);
      }));

      return function callHook(_x) {
        return _callHook.apply(this, arguments);
      };
    }()
  }, {
    key: "clearHook",
    value: function clearHook(name$$1) {
      if (name$$1) {
        delete this._hooks[name$$1];
      }
    }
  }, {
    key: "flatHooks",
    value: function flatHooks(configHooks) {
      var _this = this;

      var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var parentName = arguments.length > 2 ? arguments[2] : undefined;
      Object.keys(configHooks).forEach(function (key) {
        var subHook = configHooks[key];
        var name$$1 = parentName ? "".concat(parentName, ":").concat(key) : key;

        if (_typeof(subHook) === 'object' && subHook !== null) {
          _this.flatHooks(subHook, hooks, name$$1);
        } else {
          hooks[name$$1] = subHook;
        }
      });
      return hooks;
    }
  }, {
    key: "addHooks",
    value: function addHooks(configHooks) {
      var _this2 = this;

      var hooks = this.flatHooks(configHooks);
      Object.keys(hooks).filter(Boolean).forEach(function (key) {
        [].concat(hooks[key]).forEach(function (h) {
          return _this2.hook(key, h);
        });
      });
    }
  }, {
    key: "showReady",
    value: function showReady() {
      var clear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (!this.readyMessage) {
        return;
      }

      consola.ready({
        message: this.readyMessage,
        badge: true,
        clear: clear
      });
      this.readyMessage = null;
    }
  }, {
    key: "listen",
    value: function listen(port, host, socket) {
      var _this3 = this;

      return this.ready().then(function () {
        return new Promise(function (resolve, reject) {
          if (!socket && typeof _this3.options.server.socket === 'string') {
            socket = _this3.options.server.socket;
          }

          var args = {
            exclusive: false
          };

          if (socket) {
            args.path = socket;
          } else {
            args.port = port || _this3.options.server.port;
            args.host = host || _this3.options.server.host;
          }

          var appServer;
          var isHttps = Boolean(_this3.options.server.https);

          if (isHttps) {
            var httpsOptions;

            if (_this3.options.server.https === true) {
              httpsOptions = {};
            } else {
              httpsOptions = _this3.options.server.https;
            }

            appServer = https.createServer(httpsOptions, _this3.renderer.app);
          } else {
            appServer = _this3.renderer.app;
          }

          var server = appServer.listen(args, function (err) {
            /* istanbul ignore if */
            if (err) {
              return reject(err);
            }

            var listenURL;

            if (!socket) {
              var _server$address = server.address();

              host = _server$address.address;
              port = _server$address.port;

              if (host === '127.0.0.1') {
                host = 'localhost';
              } else if (host === '0.0.0.0') {
                host = ip.address();
              }

              listenURL = Chalk.underline.blue("http".concat(isHttps ? 's' : '', "://").concat(host, ":").concat(port));
              _this3.readyMessage = "Listening on ".concat(listenURL);
            } else {
              listenURL = Chalk.underline.blue("unix+http://".concat(socket));
              _this3.readyMessage = "Listening on ".concat(listenURL);
            } // Close server on nuxt close


            _this3.hook('close', function () {
              return new Promise(function (resolve, reject) {
                // Destroy server by forcing every connection to be closed
                server.listening && server.destroy(function (err) {
                  consola.debug('server closed');
                  /* istanbul ignore if */

                  if (err) {
                    return reject(err);
                  }

                  resolve();
                });
              });
            });

            if (socket) {
              _this3.callHook('listen', server, {
                path: socket
              }).then(resolve);
            } else {
              _this3.callHook('listen', server, {
                port: port,
                host: host
              }).then(resolve);
            }
          }); // Add server.destroy(cb) method

          enableDestroy(server);
        });
      });
    }
  }, {
    key: "resolveModule",
    value: function resolveModule(path$$1) {
      try {
        var resolvedPath = Module._resolveFilename(path$$1, {
          paths: this.options.modulesDir
        });

        return resolvedPath;
      } catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
          return null;
        } else {
          throw error;
        }
      }
    }
  }, {
    key: "resolveAlias",
    value: function resolveAlias(path$$1) {
      var modulePath = this.resolveModule(path$$1); // Try to resolve it as if it were a regular node_module
      // Package first. Fixes issue with @<org> scoped packages

      if (modulePath != null) {
        return modulePath;
      }

      if (startsWithRootAlias(path$$1)) {
        return path.join(this.options.rootDir, path$$1.substr(2));
      }

      if (startsWithSrcAlias(path$$1)) {
        return path.join(this.options.srcDir, path$$1.substr(1));
      }

      return path.resolve(this.options.srcDir, path$$1);
    }
  }, {
    key: "resolvePath",
    value: function resolvePath(path$$1) {
      var _path = this.resolveAlias(path$$1);

      if (fsExtra.existsSync(_path)) {
        return _path;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.options.extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var ext = _step.value;

          if (fsExtra.existsSync(_path + '.' + ext)) {
            return _path + '.' + ext;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      throw new Error("Cannot resolve \"".concat(path$$1, "\" from \"").concat(_path, "\""));
    }
  }, {
    key: "requireModule",
    value: function requireModule(_path) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _resolvedPath = this.resolvePath(_path);

      var m = opts.esm === false ? require(_resolvedPath) : this.esm(_resolvedPath);
      return m && m.default || m;
    }
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(callback) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.callHook('close', this);

              case 2:
                if (!(typeof callback === 'function')) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 5;
                return callback();

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function close(_x2) {
        return _close.apply(this, arguments);
      };
    }()
  }], [{
    key: "version",
    get: function get() {
      return packageJSON.version;
    }
  }]);

  return Nuxt;
}();

var core = {
  Nuxt: Nuxt,
  Module: ModuleContainer,
  Renderer: Renderer
};

// https://github.com/webpack-contrib/cache-loader

var PerfLoader =
/*#__PURE__*/
function () {
  function PerfLoader(options) {
    _classCallCheck(this, PerfLoader);

    this.options = options;
    this.warmup = threadLoader.warmup;
    this.workerPools = {
      js: {
        name: 'js',
        poolTimeout: this.options.dev ? Infinity : 2000
      },
      css: {
        name: 'css',
        poolTimeout: this.options.dev ? Infinity : 2000
      }
    };
  }

  _createClass(PerfLoader, [{
    key: "warmupAll",
    value: function warmupAll() {
      this.warmup(this.workerPools.js, ['babel-loader', '@babel/preset-env']);
      this.warmup(this.workerPools.css, ['css-loader']);
    }
  }, {
    key: "pool",
    value: function pool(poolName, _loaders) {
      var loaders = [].concat(_loaders);

      if (this.options.build.parallel) {
        var pool = this.workerPools[poolName];

        if (pool) {
          loaders.unshift({
            loader: 'thread-loader',
            options: pool
          });
        }
      }

      if (this.options.build.cache) {
        loaders.unshift({
          loader: 'cache-loader',
          options: {
            cacheDirectory: path__default.resolve('node_modules/.cache/cache-loader')
          }
        });
      }

      return loaders;
    }
  }, {
    key: "poolOneOf",
    value: function poolOneOf(poolName, oneOfRules) {
      var _this = this;

      return oneOfRules.map(function (rule) {
        return Object.assign({}, rule, {
          use: _this.pool(poolName, rule.use)
        });
      });
    }
  }]);

  return PerfLoader;
}();

var prefix = "[vue-server-renderer-webpack-plugin]";
var warn = function warn(msg) {
  return console.error(Chalk.red("".concat(prefix, " ").concat(msg, "\n")));
}; // eslint-disable-line no-console

var tip = function tip(msg) {
  return console.log(Chalk.yellow("".concat(prefix, " ").concat(msg, "\n")));
}; // eslint-disable-line no-console

var validate = function validate(compiler) {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be "node".');
  }

  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be "commonjs2".');
  }

  if (!compiler.options.externals) {
    tip('It is recommended to externalize dependencies in the server build for ' + 'better build performance.');
  }
};
var onEmit = function onEmit(compiler, name, hook) {
  if (compiler.hooks) {
    // Webpack >= 4.0.0
    compiler.hooks.emit.tapAsync(name, hook);
  } else {
    // Webpack < 4.0.0
    compiler.plugin('emit', hook);
  }
};
var isJS = function isJS(file) {
  return /\.js(\?[^.]+)?$/.test(file);
};
var isCSS = function isCSS(file) {
  return /\.css(\?[^.]+)?$/.test(file);
};

var VueSSRClientPlugin =
/*#__PURE__*/
function () {
  function VueSSRClientPlugin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, VueSSRClientPlugin);

    this.options = Object.assign({
      filename: 'vue-ssr-client-manifest.json'
    }, options);
  }

  _createClass(VueSSRClientPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      onEmit(compiler, 'vue-client-plugin', function (compilation, cb) {
        var stats = compilation.getStats().toJson();
        var allFiles = _.uniq(stats.assets.map(function (a) {
          return a.name;
        }));
        var initialFiles = _.uniq(Object.keys(stats.entrypoints).map(function (name) {
          return stats.entrypoints[name].assets;
        }).reduce(function (assets, all) {
          return all.concat(assets);
        }, []).filter(function (file) {
          return isJS(file) || isCSS(file);
        }));
        var asyncFiles = allFiles.filter(function (file) {
          return isJS(file) || isCSS(file);
        }).filter(function (file) {
          return !initialFiles.includes(file);
        });
        var manifest = {
          publicPath: stats.publicPath,
          all: allFiles,
          initial: initialFiles,
          async: asyncFiles,
          modules: {
            /* [identifier: string]: Array<index: number> */
          }
        };
        var assetModules = stats.modules.filter(function (m) {
          return m.assets.length;
        });

        var fileToIndex = function fileToIndex(file) {
          return manifest.all.indexOf(file);
        };

        stats.modules.forEach(function (m) {
          // ignore modules duplicated in multiple chunks
          if (m.chunks.length === 1) {
            var cid = m.chunks[0];
            var chunk = stats.chunks.find(function (c) {
              return c.id === cid;
            });

            if (!chunk || !chunk.files) {
              return;
            }

            var id = m.identifier.replace(/\s\w+$/, ''); // remove appended hash

            var files = manifest.modules[hash(id)] = chunk.files.map(fileToIndex); // find all asset modules associated with the same chunk

            assetModules.forEach(function (m) {
              if (m.chunks.some(function (id) {
                return id === cid;
              })) {
                files.push.apply(files, m.assets.map(fileToIndex));
              }
            });
          }
        }); // const debug = (file, obj) => {
        //   require('fs').writeFileSync(__dirname + '/' + file, JSON.stringify(obj, null, 2))
        // }
        // debug('stats.json', stats)
        // debug('client-manifest.json', manifest)

        var json = JSON.stringify(manifest, null, 2);
        compilation.assets[_this.options.filename] = {
          source: function source() {
            return json;
          },
          size: function size() {
            return json.length;
          }
        };
        cb();
      });
    }
  }]);

  return VueSSRClientPlugin;
}();

var PostcssConfig =
/*#__PURE__*/
function () {
  function PostcssConfig(options, nuxt) {
    _classCallCheck(this, PostcssConfig);

    this.nuxt = nuxt;
    this.dev = options.dev;
    this.postcss = options.build.postcss;
    this.srcDir = options.srcDir;
    this.rootDir = options.rootDir;
    this.cssSourceMap = options.build.cssSourceMap;
    this.modulesDir = options.modulesDir;
  }

  _createClass(PostcssConfig, [{
    key: "searchConfigFile",
    value: function searchConfigFile() {
      // Search for postCSS config file and use it if exists
      // https://github.com/michael-ciniawsky/postcss-load-config
      var _arr = [this.srcDir, this.rootDir];

      for (var _i = 0; _i < _arr.length; _i++) {
        var dir = _arr[_i];
        var _arr2 = ['postcss.config.js', '.postcssrc.js', '.postcssrc', '.postcssrc.json', '.postcssrc.yaml'];

        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
          var file = _arr2[_i2];
          var configFile = path__default.resolve(dir, file);

          if (fs.existsSync(configFile)) {
            return configFile;
          }
        }
      }
    }
  }, {
    key: "configFromFile",
    value: function configFromFile() {
      var loaderConfig = this.postcss && this.postcss.config || {};
      loaderConfig.path = loaderConfig.path || this.searchConfigFile();

      if (loaderConfig.path) {
        return {
          sourceMap: this.cssSourceMap,
          config: loaderConfig
        };
      }
    }
  }, {
    key: "normalize",
    value: function normalize(config) {
      if (Array.isArray(config)) {
        config = {
          plugins: config
        };
      }

      return config;
    }
  }, {
    key: "loadPlugins",
    value: function loadPlugins(config) {
      var plugins = config.plugins;

      if (isPureObject(plugins)) {
        // Map postcss plugins into instances on object mode once
        config.plugins = Object.keys(plugins).map(function (p) {
          var plugin = require(p);

          var opts = plugins[p];
          if (opts === false) return; // Disabled

          var instance = plugin(opts);
          return instance;
        }).filter(function (e) {
          return e;
        });
      }
    }
  }, {
    key: "config",
    value: function config() {
      /* istanbul ignore if */
      if (!this.postcss) {
        return false;
      }

      var config = this.configFromFile();

      if (config) {
        return config;
      }

      config = this.normalize(___default.cloneDeep(this.postcss)); // Apply default plugins

      if (isPureObject(config)) {
        if (config.preset) {
          this.preset = config.preset;
          delete config.preset;
        }

        if (Array.isArray(config.plugins)) {
          ___default.defaults(config, this.defaultConfig);
        } else {
          // Keep the order of default plugins
          config = ___default.merge({}, this.defaultConfig, config);
          this.loadPlugins(config);
        }

        return config;
      }
    }
  }, {
    key: "defaultConfig",
    get: function get() {
      return {
        sourceMap: this.cssSourceMap,
        plugins: {
          // https://github.com/postcss/postcss-import
          'postcss-import': {
            resolve: createResolver({
              alias: {
                '~': path__default.join(this.srcDir),
                '~~': path__default.join(this.rootDir),
                '@': path__default.join(this.srcDir),
                '@@': path__default.join(this.rootDir)
              },
              modules: [this.srcDir, this.rootDir].concat(_toConsumableArray(this.modulesDir))
            })
          },
          // https://github.com/postcss/postcss-url
          'postcss-url': {},
          // https://github.com/csstools/postcss-preset-env
          'postcss-preset-env': this.preset || {},
          'cssnano': this.dev ? false : {
            preset: 'default'
          }
        }
      };
    }
  }]);

  return PostcssConfig;
}();

var StyleLoader =
/*#__PURE__*/
function () {
  function StyleLoader(options, nuxt, _ref) {
    var isServer = _ref.isServer;

    _classCallCheck(this, StyleLoader);

    this.isServer = isServer;
    this.dev = options.dev;
    this.srcDir = options.srcDir;
    this.assetsDir = options.dir.assets;
    this.staticDir = options.dir.static;
    this.loaders = options.build.loaders;
    this.extractCSS = options.build.extractCSS;
    this.resources = options.build.styleResources;
    this.sourceMap = Boolean(options.build.cssSourceMap);

    if (options.build.postcss) {
      this.postcssConfig = new PostcssConfig(options, nuxt);
    }
  }

  _createClass(StyleLoader, [{
    key: "normalize",
    value: function normalize(loaders) {
      loaders = wrapArray(loaders);
      return loaders.map(function (loader) {
        return typeof loader === 'string' ? {
          loader: loader
        } : loader;
      });
    }
  }, {
    key: "styleResource",
    value: function styleResource(ext) {
      var extResource = this.resources[ext]; // style-resources-loader
      // https://github.com/yenshih/style-resources-loader

      if (extResource) {
        var patterns = wrapArray(extResource);
        return {
          loader: 'style-resources-loader',
          options: Object.assign({
            patterns: patterns
          }, this.resources.options || {})
        };
      }
    }
  }, {
    key: "postcss",
    value: function postcss() {
      // postcss-loader
      // https://github.com/postcss/postcss-loader
      if (this.postcssConfig) {
        var config = this.postcssConfig.config();

        if (config) {
          return {
            loader: 'postcss-loader',
            options: Object.assign({
              sourceMap: this.sourceMap
            }, config)
          };
        }
      }
    }
  }, {
    key: "css",
    value: function css(options) {
      return {
        loader: this.isServer && this.extractCSS ? 'css-loader/locals' : 'css-loader',
        options: options
      };
    }
  }, {
    key: "cssModules",
    value: function cssModules(options) {
      options.modules = true;
      return {
        loader: 'css-loader',
        options: options
      };
    }
  }, {
    key: "extract",
    value: function extract() {
      if (this.extractCSS && !this.isServer) {
        return MiniCssExtractPlugin.loader;
      }
    }
  }, {
    key: "vueStyle",
    value: function vueStyle() {
      // https://github.com/vuejs/vue-style-loader
      return {
        loader: 'vue-style-loader',
        options: this.loaders.vueStyle
      };
    }
  }, {
    key: "apply",
    value: function apply(ext) {
      var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var customLoaders = [].concat(this.postcss(loaders), this.normalize(loaders), this.styleResource(ext)).filter(Boolean);
      var _this$loaders = this.loaders,
          cssOptions = _this$loaders.css,
          cssModulesOptions = _this$loaders.cssModules;
      cssOptions.importLoaders = cssModulesOptions.importLoaders = customLoaders.length;
      var styleLoader = this.extract() || this.vueStyle();
      return [// This matches <style module>
      {
        resourceQuery: /module/,
        use: [].concat(styleLoader, this.cssModules(cssModulesOptions), customLoaders)
      }, // This matches plain <style> or <style scoped>
      {
        use: [].concat(styleLoader, this.css(cssOptions), customLoaders)
      }];
    }
  }]);

  return StyleLoader;
}();

var WarnFixPlugin =
/*#__PURE__*/
function () {
  function WarnFixPlugin() {
    _classCallCheck(this, WarnFixPlugin);
  }

  _createClass(WarnFixPlugin, [{
    key: "apply",
    value: function apply(compiler)
    /* istanbul ignore next */
    {
      compiler.hooks.done.tap('warnfix-plugin', function (stats) {
        stats.compilation.warnings = stats.compilation.warnings.filter(function (warn) {
          if (warn.name === 'ModuleDependencyWarning' && warn.message.includes("export 'default'") && warn.message.includes('nuxt_plugin_')) {
            return false;
          }

          return true;
        });
      });
    }
  }]);

  return WarnFixPlugin;
}();

var StatsPlugin =
/*#__PURE__*/
function () {
  function StatsPlugin(statsOptions) {
    _classCallCheck(this, StatsPlugin);

    this.statsOptions = statsOptions;
  }

  _createClass(StatsPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      compiler.hooks.done.tap('stats-plugin', function (stats) {
        process.stdout.write('\n' + stats.toString(_this.statsOptions) + '\n');
      });
    }
  }]);

  return StatsPlugin;
}();

var WebpackBaseConfig =
/*#__PURE__*/
function () {
  function WebpackBaseConfig(builder, options) {
    _classCallCheck(this, WebpackBaseConfig);

    this.name = options.name;
    this.isServer = options.isServer;
    this.builder = builder;
    this.nuxt = this.builder.nuxt;
    this.isStatic = builder.isStatic;
    this.options = builder.options;
    this.spinner = builder.spinner;
    this.loaders = this.options.build.loaders;
  }

  _createClass(WebpackBaseConfig, [{
    key: "getBabelOptions",
    value: function getBabelOptions() {
      var options = ___default.clone(this.options.build.babel);

      if (typeof options.presets === 'function') {
        options.presets = options.presets({
          isServer: this.isServer
        });
      }

      if (!options.babelrc && !options.presets) {
        options.presets = [[require.resolve('@nuxtjs/babel-preset-app'), {
          buildTarget: this.isServer ? 'server' : 'client'
        }]];
      }

      return options;
    }
  }, {
    key: "getFileName",
    value: function getFileName(key) {
      var fileName = this.options.build.filenames[key];

      if (typeof fileName === 'function') {
        fileName = fileName(this.nuxtEnv);
      }

      if (this.options.dev) {
        var hash$$1 = /\[(chunkhash|contenthash|hash)(?::(\d+))?\]/.exec(fileName);

        if (hash$$1) {
          consola.warn("Notice: Please do not use ".concat(hash$$1[1], " in dev mode to prevent memory leak"));
        }
      }

      return fileName;
    }
  }, {
    key: "devtool",
    value: function devtool() {
      return false;
    }
  }, {
    key: "env",
    value: function env$$1() {
      var env$$1 = {
        'process.mode': JSON.stringify(this.options.mode),
        'process.static': this.isStatic
      };
      Object.entries(this.options.env).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        env$$1['process.env.' + key] = ['boolean', 'number'].includes(_typeof(value)) ? value : JSON.stringify(value);
      });
      return env$$1;
    }
  }, {
    key: "output",
    value: function output() {
      return {
        path: path__default.resolve(this.options.buildDir, 'dist', this.isServer ? 'server' : 'client'),
        filename: this.getFileName('app'),
        chunkFilename: this.getFileName('chunk'),
        publicPath: isUrl(this.options.build.publicPath) ? this.options.build.publicPath : urlJoin(this.options.router.base, this.options.build.publicPath)
      };
    }
  }, {
    key: "optimization",
    value: function optimization() {
      return this.options.build.optimization;
    }
  }, {
    key: "alias",
    value: function alias() {
      var _ref3;

      var _this$options = this.options,
          srcDir = _this$options.srcDir,
          rootDir = _this$options.rootDir,
          _this$options$dir = _this$options.dir,
          assetsDir = _this$options$dir.assets,
          staticDir = _this$options$dir.static;
      return _ref3 = {
        '~': path__default.join(srcDir),
        '~~': path__default.join(rootDir),
        '@': path__default.join(srcDir),
        '@@': path__default.join(rootDir)
      }, _defineProperty(_ref3, assetsDir, path__default.join(srcDir, assetsDir)), _defineProperty(_ref3, staticDir, path__default.join(srcDir, staticDir)), _ref3;
    }
  }, {
    key: "rules",
    value: function rules() {
      var _this = this;

      var styleLoader = new StyleLoader(this.options, this.builder.nuxt, {
        isServer: this.isServer
      });
      var perfLoader = this.builder.perfLoader;
      return [{
        test: /\.vue$/,
        loader: 'vue-loader',
        options: this.loaders.vue
      }, {
        test: /\.pug$/,
        oneOf: [{
          resourceQuery: /^\?vue/,
          use: [{
            loader: 'pug-plain-loader',
            options: this.loaders.pugPlain
          }]
        }, {
          use: ['raw-loader', {
            loader: 'pug-plain-loader',
            options: this.loaders.pugPlain
          }]
        }]
      }, {
        test: /\.jsx?$/,
        exclude: function exclude(file) {
          // not exclude files outside node_modules
          if (!/node_modules/.test(file)) {
            return false;
          } // item in transpile can be string or regex object


          var modulesToTranspile = [/\.vue\.js/].concat(_this.options.build.transpile);
          return !modulesToTranspile.some(function (module) {
            return module.test(file);
          });
        },
        use: perfLoader.pool('js', {
          loader: 'babel-loader',
          options: this.getBabelOptions()
        })
      }, {
        test: /\.css$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('css'))
      }, {
        test: /\.less$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('less', {
          loader: 'less-loader',
          options: this.loaders.less
        }))
      }, {
        test: /\.sass$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('sass', {
          loader: 'sass-loader',
          options: this.loaders.sass
        }))
      }, {
        test: /\.scss$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('scss', {
          loader: 'sass-loader',
          options: this.loaders.scss
        }))
      }, {
        test: /\.styl(us)?$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('stylus', {
          loader: 'stylus-loader',
          options: this.loaders.stylus
        }))
      }, {
        test: /\.(png|jpe?g|gif|svg|webp)$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: Object.assign(this.loaders.imgUrl, {
            name: this.getFileName('img')
          })
        })
      }, {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: Object.assign(this.loaders.fontUrl, {
            name: this.getFileName('font')
          })
        })
      }, {
        test: /\.(webm|mp4|ogv)$/,
        use: perfLoader.pool('assets', {
          loader: 'file-loader',
          options: Object.assign(this.loaders.file, {
            name: this.getFileName('video')
          })
        })
      }];
    }
  }, {
    key: "plugins",
    value: function plugins() {
      var _this2 = this;

      var plugins = [new VueLoader.VueLoaderPlugin()];
      Array.prototype.push.apply(plugins, this.options.build.plugins || []); // Add timefix-plugin before others plugins

      if (this.options.dev) {
        plugins.unshift(new TimeFixPlugin());
      } // Hide warnings about plugins without a default export (#1179)


      plugins.push(new WarnFixPlugin()); // Build progress indicator

      plugins.push(new WebpackBar({
        profile: this.options.build.profile,
        name: this.isServer ? 'server' : 'client',
        color: this.isServer ? 'orange' : 'green',
        compiledIn: false,
        done: function done(states) {
          if (_this2.options.dev) {
            var hasErrors = Object.values(states).some(function (state) {
              return state.stats.hasErrors();
            });

            if (!hasErrors) {
              _this2.nuxt.showReady(false);
            }
          }
        }
      })); // Add stats plugin

      if (!this.options.dev && this.options.build.stats) {
        plugins.push(new StatsPlugin(this.options.build.stats));
      } // CSS extraction
      // MiniCssExtractPlugin does not currently supports SSR
      // https://github.com/webpack-contrib/mini-css-extract-plugin/issues/48
      // So we use css-loader/locals as a fallback (utils/style-loader)


      if (this.options.build.extractCSS && !this.isServer) {
        plugins.push(new MiniCssExtractPlugin(Object.assign({
          filename: this.getFileName('css'),
          chunkFilename: this.getFileName('css')
        }, this.options.build.extractCSS)));
      }

      return plugins;
    }
  }, {
    key: "extendConfig",
    value: function extendConfig(config) {
      if (typeof this.options.build.extend === 'function') {
        var extendedConfig = this.options.build.extend.call(this.builder, config, _objectSpread({
          loaders: this.loaders
        }, this.nuxtEnv)); // Only overwrite config when something is returned for backwards compatibility

        if (extendedConfig !== undefined) {
          return extendedConfig;
        }
      }

      return config;
    }
  }, {
    key: "config",
    value: function config() {
      // Prioritize nested node_modules in webpack search path (#2558)
      var webpackModulesDir = ['node_modules'].concat(this.options.modulesDir);
      var config = {
        name: this.name,
        mode: this.options.dev ? 'development' : 'production',
        devtool: this.devtool(),
        optimization: this.optimization(),
        output: this.output(),
        performance: {
          maxEntrypointSize: 1000 * 1024,
          hints: this.options.dev ? false : 'warning'
        },
        resolve: {
          extensions: ['.wasm', '.mjs', '.js', '.json', '.vue', '.jsx'],
          alias: this.alias(),
          modules: webpackModulesDir
        },
        resolveLoader: {
          modules: webpackModulesDir
        },
        module: {
          rules: this.rules()
        },
        plugins: this.plugins()
      };
      var extendedConfig = this.extendConfig(config); // Clone deep avoid leaking config between Client and Server

      return ___default.cloneDeep(extendedConfig);
    }
  }, {
    key: "nuxtEnv",
    get: function get() {
      return {
        isDev: this.options.dev,
        isServer: this.isServer,
        isClient: !this.isServer
      };
    }
  }]);

  return WebpackBaseConfig;
}();

var WebpackClientConfig =
/*#__PURE__*/
function (_WebpackBaseConfig) {
  _inherits(WebpackClientConfig, _WebpackBaseConfig);

  function WebpackClientConfig(builder) {
    _classCallCheck(this, WebpackClientConfig);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebpackClientConfig).call(this, builder, {
      name: 'client',
      isServer: false
    }));
  }

  _createClass(WebpackClientConfig, [{
    key: "getFileName",
    value: function getFileName() {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (this.options.build.analyze) {
        var key = args[0];

        if (['app', 'chunk'].includes(key)) {
          return '[name].js';
        }
      }

      return (_get2 = _get(_getPrototypeOf(WebpackClientConfig.prototype), "getFileName", this)).call.apply(_get2, [this].concat(args));
    }
  }, {
    key: "env",
    value: function env$$1() {
      return Object.assign(_get(_getPrototypeOf(WebpackClientConfig.prototype), "env", this).call(this), {
        'process.env.VUE_ENV': JSON.stringify('client'),
        'process.browser': true,
        'process.client': true,
        'process.server': false
      });
    }
  }, {
    key: "optimization",
    value: function optimization() {
      var optimization = _get(_getPrototypeOf(WebpackClientConfig.prototype), "optimization", this).call(this); // Small, known and common modules which are usually used project-wise
      // Sum of them may not be more than 244 KiB


      if (this.options.build.splitChunks.commons === true && optimization.splitChunks.cacheGroups.commons === undefined) {
        optimization.splitChunks.cacheGroups.commons = {
          test: /node_modules[\\/](vue|vue-loader|vue-router|vuex|vue-meta|core-js|@babel\/runtime|axios|webpack|setimmediate|timers-browserify|process|regenerator-runtime|cookie|js-cookie|is-buffer|dotprop|nuxt\.js)[\\/]/,
          chunks: 'all',
          priority: 10,
          name: true
        };
      }

      return optimization;
    }
  }, {
    key: "plugins",
    value: function plugins() {
      var plugins = _get(_getPrototypeOf(WebpackClientConfig.prototype), "plugins", this).call(this); // Generate output HTML for SSR


      if (this.options.build.ssr) {
        plugins.push(new HTMLPlugin({
          filename: '../server/index.ssr.html',
          template: this.options.appTemplatePath,
          minify: this.options.build.html.minify,
          inject: false // Resources will be injected using bundleRenderer

        }));
      }

      plugins.push(new HTMLPlugin({
        filename: '../server/index.spa.html',
        template: this.options.appTemplatePath,
        minify: this.options.build.html.minify,
        inject: true,
        chunksSortMode: 'dependency'
      }), new VueSSRClientPlugin({
        filename: '../server/vue-ssr-client-manifest.json'
      }), new webpack.DefinePlugin(this.env()));

      if (this.options.dev) {
        // TODO: webpackHotUpdate is not defined: https://github.com/webpack/webpack/issues/6693
        plugins.push(new webpack.HotModuleReplacementPlugin());
      } // Webpack Bundle Analyzer
      // https://github.com/webpack-contrib/webpack-bundle-analyzer


      if (!this.options.dev && this.options.build.analyze) {
        var statsDir = path__default.resolve(this.options.buildDir, 'stats');
        plugins.push(new BundleAnalyzer.BundleAnalyzerPlugin(Object.assign({
          analyzerMode: 'static',
          defaultSizes: 'gzip',
          generateStatsFile: true,
          openAnalyzer: !this.options.build.quiet,
          reportFilename: path__default.resolve(statsDir, 'client.html'),
          statsFilename: path__default.resolve(statsDir, 'client.json')
        }, this.options.build.analyze)));
      }

      return plugins;
    }
  }, {
    key: "extendConfig",
    value: function extendConfig() {
      var config = _get(_getPrototypeOf(WebpackClientConfig.prototype), "extendConfig", this).apply(this, arguments); // Add minimizer plugins


      if (config.optimization.minimize && config.optimization.minimizer === undefined) {
        config.optimization.minimizer = []; // https://github.com/webpack-contrib/terser-webpack-plugin

        if (this.options.build.terser) {
          config.optimization.minimizer.push(new TerserWebpackPlugin(Object.assign({
            parallel: true,
            cache: this.options.build.cache,
            sourceMap: config.devtool && /source-?map/.test(config.devtool),
            extractComments: {
              filename: 'LICENSES'
            },
            terserOptions: {
              output: {
                comments: /^\**!|@preserve|@license|@cc_on/
              }
            }
          }, this.options.build.terser)));
        } // https://github.com/NMFR/optimize-css-assets-webpack-plugin
        // https://github.com/webpack-contrib/mini-css-extract-plugin#minimizing-for-production
        // TODO: Remove OptimizeCSSAssetsPlugin when upgrading to webpack 5


        if (this.options.build.optimizeCSS) {
          config.optimization.minimizer.push(new OptimizeCSSAssetsPlugin(Object.assign({}, this.options.build.optimizeCSS)));
        }
      }

      return config;
    }
  }, {
    key: "config",
    value: function config() {
      var config = _get(_getPrototypeOf(WebpackClientConfig.prototype), "config", this).call(this); // Entry points


      config.entry = {
        app: [path__default.resolve(this.options.buildDir, 'client.js')] // Add HMR support

      };

      if (this.options.dev) {
        config.entry.app.unshift( // https://github.com/glenjamin/webpack-hot-middleware#config
        "webpack-hot-middleware/client?name=client&reload=true&timeout=30000&path=".concat(this.options.router.base, "/__webpack_hmr").replace(/\/\//g, '/'));
      } // Add friendly error plugin


      if (this.options.dev && !this.options.build.quiet) {
        config.plugins.push(new FriendlyErrorsWebpackPlugin({
          clearConsole: true,
          logLevel: 'WARNING'
        }));
      }

      return config;
    }
  }]);

  return WebpackClientConfig;
}(WebpackBaseConfig);

var VueSSRServerPlugin =
/*#__PURE__*/
function () {
  function VueSSRServerPlugin() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, VueSSRServerPlugin);

    this.options = Object.assign({
      filename: 'vue-ssr-server-bundle.json'
    }, options);
  }

  _createClass(VueSSRServerPlugin, [{
    key: "apply",
    value: function apply(compiler) {
      var _this = this;

      validate(compiler);
      onEmit(compiler, 'vue-server-plugin', function (compilation, cb) {
        var stats = compilation.getStats().toJson();
        var entryName = Object.keys(stats.entrypoints)[0];
        var entryInfo = stats.entrypoints[entryName];

        if (!entryInfo) {
          // #5553
          return cb();
        }

        var entryAssets = entryInfo.assets.filter(isJS);

        if (entryAssets.length > 1) {
          throw new Error("Server-side bundle should have one single entry file. " + "Avoid using CommonsChunkPlugin in the server config.");
        }

        var entry = entryAssets[0];

        if (!entry || typeof entry !== 'string') {
          throw new Error("Entry \"".concat(entryName, "\" not found. Did you specify the correct entry option?"));
        }

        var bundle = {
          entry: entry,
          files: {},
          maps: {}
        };
        stats.assets.forEach(function (asset) {
          if (isJS(asset.name)) {
            bundle.files[asset.name] = compilation.assets[asset.name].source();
          } else if (asset.name.match(/\.js\.map$/)) {
            bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
          } // do not emit anything else for server


          delete compilation.assets[asset.name];
        });
        var json = JSON.stringify(bundle, null, 2);
        var filename = _this.options.filename;
        compilation.assets[filename] = {
          source: function source() {
            return json;
          },
          size: function size() {
            return json.length;
          }
        };
        cb();
      });
    }
  }]);

  return VueSSRServerPlugin;
}();

var WebpackServerConfig =
/*#__PURE__*/
function (_BaseConfig) {
  _inherits(WebpackServerConfig, _BaseConfig);

  function WebpackServerConfig(builder) {
    _classCallCheck(this, WebpackServerConfig);

    return _possibleConstructorReturn(this, _getPrototypeOf(WebpackServerConfig).call(this, builder, {
      name: 'server',
      isServer: true
    }));
  }

  _createClass(WebpackServerConfig, [{
    key: "devtool",
    value: function devtool() {
      return 'cheap-module-inline-source-map';
    }
  }, {
    key: "env",
    value: function env$$1() {
      return Object.assign(_get(_getPrototypeOf(WebpackServerConfig.prototype), "env", this).call(this), {
        'process.env.VUE_ENV': JSON.stringify('server'),
        'process.browser': false,
        'process.client': false,
        'process.server': true
      });
    }
  }, {
    key: "optimization",
    value: function optimization() {
      return {
        splitChunks: false,
        minimizer: []
      };
    }
  }, {
    key: "plugins",
    value: function plugins() {
      var plugins = _get(_getPrototypeOf(WebpackServerConfig.prototype), "plugins", this).call(this);

      plugins.push(new VueSSRServerPlugin({
        filename: 'server-bundle.json'
      }), new webpack.DefinePlugin(this.env()));
      return plugins;
    }
  }, {
    key: "config",
    value: function config() {
      var _this = this;

      var config = _get(_getPrototypeOf(WebpackServerConfig.prototype), "config", this).call(this);

      Object.assign(config, {
        target: 'node',
        node: false,
        entry: {
          app: [path__default.resolve(this.options.buildDir, 'server.js')]
        },
        output: Object.assign({}, config.output, {
          filename: 'server-bundle.js',
          libraryTarget: 'commonjs2'
        }),
        performance: {
          hints: false,
          maxAssetSize: Infinity
        },
        externals: []
      }); // https://webpack.js.org/configuration/externals/#externals
      // https://github.com/liady/webpack-node-externals
      // https://vue-loader.vuejs.org/migrating.html#ssr-externals

      this.options.modulesDir.forEach(function (dir) {
        if (fs.existsSync(dir)) {
          config.externals.push(nodeExternals({
            whitelist: [/\.css$/, /\?vue&type=style/].concat(_toConsumableArray(_this.options.build.transpile)),
            modulesDir: dir
          }));
        }
      });
      return config;
    }
  }]);

  return WebpackServerConfig;
}(WebpackBaseConfig);

var glob = pify(Glob);

var Builder =
/*#__PURE__*/
function () {
  function Builder(nuxt) {
    var _this = this;

    _classCallCheck(this, Builder);

    this.nuxt = nuxt;
    this.isStatic = false; // Flag to know if the build is for a generated app

    this.options = nuxt.options;
    this.globals = determineGlobals(nuxt.options.globalName, nuxt.options.globals); // Fields that set on build

    this.compilers = [];
    this.compilersWatching = [];
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;
    this.watchers = {
      files: null,
      custom: null,
      restart: null
    };
    this.perfLoader = null; // Helper to resolve build paths

    this.relativeToBuild = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return relativeTo.apply(void 0, [_this.options.buildDir].concat(args));
    };

    this._buildStatus = STATUS.INITIAL; // Stop watching on nuxt.close()

    if (this.options.dev) {
      this.nuxt.hook('close', function () {
        return _this.unwatch();
      });
    } // Initialize shared FS and Cache


    if (this.options.dev) {
      this.mfs = new MFS();
    }

    if (this.options.build.analyze) {
      this.nuxt.hook('build:done', function () {
        consola.warn({
          message: 'Notice: Please do not deploy bundles built with analyze mode, it\'s only for analyzing purpose.',
          badge: true
        });
      });
    } // if(!this.options.dev) {
    // TODO: enable again when unsafe concern resolved.(common/options.js:42)
    // this.nuxt.hook('build:done', () => this.generateConfig())
    // }

  }

  _createClass(Builder, [{
    key: "normalizePlugins",
    value: function normalizePlugins() {
      var _this2 = this;

      return ___default.uniqBy(this.options.plugins.map(function (p) {
        if (typeof p === 'string') p = {
          src: p
        };
        var pluginBaseName = path__default.basename(p.src, path__default.extname(p.src)).replace(/[^a-zA-Z?\d\s:]/g, '');
        return {
          src: _this2.nuxt.resolveAlias(p.src),
          ssr: p.ssr !== false,
          name: 'nuxt_plugin_' + pluginBaseName + '_' + hash(p.src)
        };
      }), function (p) {
        return p.name;
      });
    }
  }, {
    key: "forGenerate",
    value: function forGenerate() {
      this.isStatic = true;
    }
  }, {
    key: "build",
    value: function () {
      var _build = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var dir, buildDirs;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(this._buildStatus === STATUS.BUILD_DONE && this.options.dev)) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this);

              case 2:
                if (!(this._buildStatus === STATUS.BUILDING)) {
                  _context.next = 6;
                  break;
                }

                _context.next = 5;
                return waitFor(1000);

              case 5:
                return _context.abrupt("return", this.build());

              case 6:
                this._buildStatus = STATUS.BUILDING;
                consola.info({
                  message: 'Building project',
                  badge: true,
                  clear: !this.options.dev
                }); // Wait for nuxt ready

                _context.next = 10;
                return this.nuxt.ready();

              case 10:
                _context.next = 12;
                return this.nuxt.callHook('build:before', this, this.options.build);

              case 12:
                // Check if pages dir exists and warn if not
                this._nuxtPages = typeof this.options.build.createRoutes !== 'function';

                if (!this._nuxtPages) {
                  _context.next = 22;
                  break;
                }

                if (fsExtra.existsSync(path__default.join(this.options.srcDir, this.options.dir.pages))) {
                  _context.next = 22;
                  break;
                }

                dir = this.options.srcDir;

                if (!fsExtra.existsSync(path__default.join(this.options.srcDir, '..', this.options.dir.pages))) {
                  _context.next = 20;
                  break;
                }

                throw new Error("No `".concat(this.options.dir.pages, "` directory found in ").concat(dir, ". Did you mean to run `nuxt` in the parent (`../`) directory?"));

              case 20:
                this._defaultPage = true;
                consola.warn({
                  message: "No `".concat(this.options.dir.pages, "` directory found in ").concat(dir, "."),
                  additional: 'Using the default built-in page.\n',
                  additionalStyle: 'yellowBright',
                  badge: true
                });

              case 22:
                consola.success('Builder initialized');
                consola.debug("App root: ".concat(this.options.srcDir)); // Create .nuxt/, .nuxt/components and .nuxt/dist folders

                _context.next = 26;
                return fsExtra.remove(r(this.options.buildDir));

              case 26:
                buildDirs = [r(this.options.buildDir, 'components')];

                if (!this.options.dev) {
                  buildDirs.push(r(this.options.buildDir, 'dist', 'client'), r(this.options.buildDir, 'dist', 'server'));
                }

                _context.next = 30;
                return Promise.all(buildDirs.map(function (dir) {
                  return fsExtra.mkdirp(dir);
                }));

              case 30:
                _context.next = 32;
                return this.generateRoutesAndFiles();

              case 32:
                _context.next = 34;
                return this.webpackBuild();

              case 34:
                // Flag to set that building is done
                this._buildStatus = STATUS.BUILD_DONE; // Call done hook

                _context.next = 37;
                return this.nuxt.callHook('build:done', this);

              case 37:
                return _context.abrupt("return", this);

              case 38:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function build() {
        return _build.apply(this, arguments);
      };
    }()
  }, {
    key: "generateRoutesAndFiles",
    value: function () {
      var _generateRoutesAndFiles = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var _this3 = this;

        var templatesFiles, templateVars, layoutsFiles, files, extendedRoutes, customTemplateFiles, indicatorPath1, indicatorPath2, indicatorPath;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                consola.debug("Generating nuxt files");
                this.plugins = this.normalizePlugins(); // -- Templates --

                templatesFiles = ['App.js', 'client.js', 'index.js', 'middleware.js', 'router.js', 'server.js', 'utils.js', 'empty.js', 'components/nuxt-error.vue', 'components/nuxt-loading.vue', 'components/nuxt-child.js', 'components/nuxt-link.js', 'components/nuxt.js', 'components/no-ssr.js', 'views/app.template.html', 'views/error.html'];
                templateVars = {
                  options: this.options,
                  extensions: this.options.extensions.map(function (ext) {
                    return ext.replace(/^\./, '');
                  }).join('|'),
                  messages: this.options.messages,
                  splitChunks: this.options.build.splitChunks,
                  uniqBy: ___default.uniqBy,
                  isDev: this.options.dev,
                  debug: this.options.debug,
                  vue: {
                    config: this.options.vue.config
                  },
                  mode: this.options.mode,
                  router: this.options.router,
                  env: this.options.env,
                  head: this.options.head,
                  middleware: fsExtra.existsSync(path__default.join(this.options.srcDir, this.options.dir.middleware)),
                  store: this.options.store,
                  globalName: this.options.globalName,
                  globals: this.globals,
                  css: this.options.css,
                  plugins: this.plugins,
                  appPath: './App.js',
                  ignorePrefix: this.options.ignorePrefix,
                  layouts: Object.assign({}, this.options.layouts),
                  loading: typeof this.options.loading === 'string' ? this.relativeToBuild(this.options.srcDir, this.options.loading) : this.options.loading,
                  transition: this.options.transition,
                  layoutTransition: this.options.layoutTransition,
                  dir: this.options.dir,
                  components: {
                    ErrorPage: this.options.ErrorPage ? this.relativeToBuild(this.options.ErrorPage) : null
                  } // -- Layouts --

                };

                if (!fsExtra.existsSync(path__default.resolve(this.options.srcDir, this.options.dir.layouts))) {
                  _context3.next = 9;
                  break;
                }

                _context3.next = 7;
                return glob("".concat(this.options.dir.layouts, "/**/*.{vue,js}"), {
                  cwd: this.options.srcDir,
                  ignore: this.options.ignore
                });

              case 7:
                layoutsFiles = _context3.sent;
                layoutsFiles.forEach(function (file) {
                  var name = file.split('/').slice(1).join('/').replace(/\.(vue|js)$/, '');

                  if (name === 'error') {
                    if (!templateVars.components.ErrorPage) {
                      templateVars.components.ErrorPage = _this3.relativeToBuild(_this3.options.srcDir, file);
                    }

                    return;
                  }

                  if (!templateVars.layouts[name] || /\.vue$/.test(file)) {
                    templateVars.layouts[name] = _this3.relativeToBuild(_this3.options.srcDir, file);
                  }
                });

              case 9:
                if (templateVars.layouts.default) {
                  _context3.next = 14;
                  break;
                }

                _context3.next = 12;
                return fsExtra.mkdirp(r(this.options.buildDir, 'layouts'));

              case 12:
                templatesFiles.push('layouts/default.vue');
                templateVars.layouts.default = './layouts/default.vue';

              case 14:
                // -- Routes --
                consola.debug('Generating routes...');

                if (!this._defaultPage) {
                  _context3.next = 19;
                  break;
                }

                templateVars.router.routes = createRoutes(['index.vue'], this.options.nuxtAppDir + '/pages');
                _context3.next = 29;
                break;

              case 19:
                if (!this._nuxtPages) {
                  _context3.next = 28;
                  break;
                }

                // If user defined a custom method to create routes
                // Use nuxt.js createRoutes bases on pages/
                files = {};
                _context3.next = 23;
                return glob("".concat(this.options.dir.pages, "/**/*.{vue,js}"), {
                  cwd: this.options.srcDir,
                  ignore: this.options.ignore
                });

              case 23:
                _context3.t0 = function (f) {
                  var key = f.replace(/\.(js|vue)$/, '');

                  if (/\.vue$/.test(f) || !files[key]) {
                    files[key] = f.replace(/('|")/g, '\\$1');
                  }
                };

                _context3.sent.forEach(_context3.t0);

                templateVars.router.routes = createRoutes(Object.values(files), this.options.srcDir, this.options.dir.pages);
                _context3.next = 29;
                break;

              case 28:
                templateVars.router.routes = this.options.build.createRoutes(this.options.srcDir);

              case 29:
                _context3.next = 31;
                return this.nuxt.callHook('build:extendRoutes', templateVars.router.routes, r);

              case 31:
                // router.extendRoutes method
                if (typeof this.options.router.extendRoutes === 'function') {
                  // let the user extend the routes
                  extendedRoutes = this.options.router.extendRoutes(templateVars.router.routes, r); // Only overwrite routes when something is returned for backwards compatibility

                  if (extendedRoutes !== undefined) {
                    templateVars.router.routes = extendedRoutes;
                  }
                } // Make routes accessible for other modules and webpack configs


                this.routes = templateVars.router.routes; // -- Store --
                // Add store if needed

                if (this.options.store) {
                  templatesFiles.push('store.js');
                } // Resolve template files


                customTemplateFiles = this.options.build.templates.map(function (t) {
                  return t.dst || path__default.basename(t.src || t);
                });
                templatesFiles = templatesFiles.map(function (file) {
                  // Skip if custom file was already provided in build.templates[]
                  if (customTemplateFiles.includes(file)) {
                    return;
                  } // Allow override templates using a file with same name in ${srcDir}/app


                  var customPath = r(_this3.options.srcDir, 'app', file);
                  var customFileExists = fsExtra.existsSync(customPath);
                  return {
                    src: customFileExists ? customPath : r(_this3.options.nuxtAppDir, file),
                    dst: file,
                    custom: customFileExists
                  };
                }).filter(function (i) {
                  return !!i;
                }); // -- Custom templates --
                // Add custom template files

                templatesFiles = templatesFiles.concat(this.options.build.templates.map(function (t) {
                  return Object.assign({
                    src: r(_this3.options.srcDir, t.src || t),
                    dst: t.dst || path__default.basename(t.src || t),
                    custom: true
                  }, t);
                })); // -- Loading indicator --

                if (this.options.loadingIndicator.name) {
                  indicatorPath1 = path__default.resolve(this.options.nuxtAppDir, 'views/loading', this.options.loadingIndicator.name + '.html');
                  indicatorPath2 = this.nuxt.resolveAlias(this.options.loadingIndicator.name);
                  indicatorPath = fsExtra.existsSync(indicatorPath1) ? indicatorPath1 : fsExtra.existsSync(indicatorPath2) ? indicatorPath2 : null;

                  if (indicatorPath) {
                    templatesFiles.push({
                      src: indicatorPath,
                      dst: 'loading.html',
                      options: this.options.loadingIndicator
                    });
                  } else {
                    /* istanbul ignore next */
                    // eslint-disable-next-line no-console
                    console.error("Could not fetch loading indicator: ".concat(this.options.loadingIndicator.name));
                  }
                }

                _context3.next = 40;
                return this.nuxt.callHook('build:templates', {
                  templatesFiles: templatesFiles,
                  templateVars: templateVars,
                  resolve: r
                });

              case 40:
                _context3.next = 42;
                return Promise.all(templatesFiles.map(
                /*#__PURE__*/
                function () {
                  var _ref2 = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(_ref) {
                    var src, dst, options, custom, fileContent, content, template, _path;

                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            src = _ref.src, dst = _ref.dst, options = _ref.options, custom = _ref.custom;

                            // Add template to watchers
                            _this3.options.build.watch.push(src); // Render template to dst


                            _context2.next = 4;
                            return fsExtra.readFile(src, 'utf8');

                          case 4:
                            fileContent = _context2.sent;
                            _context2.prev = 5;
                            template = ___default.template(fileContent, {
                              imports: {
                                serialize: serialize,
                                devalue: devalue,
                                hash: hash,
                                r: r,
                                wp: wp,
                                wChunk: wChunk,
                                resolvePath: _this3.nuxt.resolvePath,
                                resolveAlias: _this3.nuxt.resolveAlias,
                                relativeToBuild: _this3.relativeToBuild
                              },
                              interpolate: /<%=([\s\S]+?)%>/g
                            });
                            content = template(Object.assign({}, templateVars, {
                              options: options || {},
                              custom: custom,
                              src: src,
                              dst: dst
                            }));
                            _context2.next = 13;
                            break;

                          case 10:
                            _context2.prev = 10;
                            _context2.t0 = _context2["catch"](5);
                            throw new Error("Could not compile template ".concat(src, ": ").concat(_context2.t0.message));

                          case 13:
                            _path = r(_this3.options.buildDir, dst); // Ensure parent dir exits and write file

                            _context2.next = 16;
                            return fsExtra.outputFile(_path, content, 'utf8');

                          case 16:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this, [[5, 10]]);
                  }));

                  return function (_x) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 42:
                consola.success('Nuxt files generated');

              case 43:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function generateRoutesAndFiles() {
        return _generateRoutesAndFiles.apply(this, arguments);
      };
    }()
  }, {
    key: "webpackBuild",
    value: function () {
      var _webpackBuild = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var _this4 = this;

        var compilersOptions, clientConfig, serverConfig, runner;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.perfLoader = new PerfLoader(this.options);
                compilersOptions = []; // Client

                clientConfig = new WebpackClientConfig(this).config();
                compilersOptions.push(clientConfig); // Server

                serverConfig = null;

                if (this.options.build.ssr) {
                  serverConfig = new WebpackServerConfig(this).config();
                  compilersOptions.push(serverConfig);
                } // Check plugins exist then set alias to their real path


                _context5.next = 8;
                return Promise.all(this.plugins.map(
                /*#__PURE__*/
                function () {
                  var _ref3 = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee4(p) {
                    var ext, pluginFiles, src;
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            ext = path__default.extname(p.src) ? '' : '{.+([^.]),/index.+([^.])}';
                            _context4.next = 3;
                            return glob("".concat(p.src).concat(ext));

                          case 3:
                            pluginFiles = _context4.sent;

                            if (!(!pluginFiles || pluginFiles.length === 0)) {
                              _context4.next = 8;
                              break;
                            }

                            throw new Error("Plugin not found: ".concat(p.src));

                          case 8:
                            if (pluginFiles.length > 1) {
                              consola.warn({
                                message: "Found ".concat(pluginFiles.length, " plugins that match the configuration, suggest to specify extension:"),
                                additional: "  ".concat(pluginFiles.join('\n  ')),
                                badge: true
                              });
                            }

                          case 9:
                            src = _this4.relativeToBuild(p.src); // Client config

                            if (!clientConfig.resolve.alias[p.name]) {
                              clientConfig.resolve.alias[p.name] = src;
                            } // Server config


                            if (serverConfig && !serverConfig.resolve.alias[p.name]) {
                              // Alias to noop for ssr:false plugins
                              serverConfig.resolve.alias[p.name] = p.ssr ? src : './empty.js';
                            }

                          case 12:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, this);
                  }));

                  return function (_x2) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 8:
                // Configure compilers
                this.compilers = compilersOptions.map(function (compilersOption) {
                  var compiler = webpack(compilersOption); // In dev, write files in memory FS

                  if (_this4.options.dev) {
                    compiler.outputFileSystem = _this4.mfs;
                  }

                  return compiler;
                }); // Warmup perfLoader before build

                if (this.options.build.parallel) {
                  consola.info('Warming up worker pools');
                  this.perfLoader.warmupAll();
                  consola.success('Worker pools ready');
                } // Start Builds


                runner = this.options.dev ? parallel : sequence;
                _context5.next = 13;
                return runner(this.compilers, function (compiler) {
                  return _this4.webpackCompile(compiler);
                });

              case 13:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function webpackBuild() {
        return _webpackBuild.apply(this, arguments);
      };
    }()
  }, {
    key: "webpackCompile",
    value: function webpackCompile(compiler) {
      var _this5 = this;

      return new Promise(
      /*#__PURE__*/
      function () {
        var _ref4 = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee7(resolve, reject) {
          var name;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  name = compiler.options.name;
                  _context7.next = 3;
                  return _this5.nuxt.callHook('build:compile', {
                    name: name,
                    compiler: compiler
                  });

                case 3:
                  // Load renderer resources after build
                  compiler.hooks.done.tap('load-resources',
                  /*#__PURE__*/
                  function () {
                    var _ref5 = _asyncToGenerator(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee6(stats) {
                      return regeneratorRuntime.wrap(function _callee6$(_context6) {
                        while (1) {
                          switch (_context6.prev = _context6.next) {
                            case 0:
                              _context6.next = 2;
                              return _this5.nuxt.callHook('build:compiled', {
                                name: name,
                                compiler: compiler,
                                stats: stats
                              });

                            case 2:
                              // Reload renderer if available
                              _this5.nuxt.renderer.loadResources(_this5.mfs || fs); // Resolve on next tick


                              process.nextTick(resolve);

                            case 4:
                            case "end":
                              return _context6.stop();
                          }
                        }
                      }, _callee6, this);
                    }));

                    return function (_x5) {
                      return _ref5.apply(this, arguments);
                    };
                  }());

                  if (!_this5.options.dev) {
                    _context7.next = 10;
                    break;
                  }

                  if (!(compiler.options.name === 'client')) {
                    _context7.next = 7;
                    break;
                  }

                  return _context7.abrupt("return", _this5.webpackDev(compiler));

                case 7:
                  // Server, build and watch for changes
                  _this5.compilersWatching.push(compiler.watch(_this5.options.watchers.webpack, function (err) {
                    /* istanbul ignore if */
                    if (err) return reject(err);
                  }));

                  _context7.next = 11;
                  break;

                case 10:
                  // --- Production Build ---
                  compiler.run(function (err, stats) {
                    /* istanbul ignore next */
                    if (err) {
                      return reject(err);
                    } else if (stats.hasErrors()) {
                      if (_this5.options.build.quiet === true) {
                        err = stats.toString(_this5.options.build.stats);
                      }

                      if (!err) {
                        // actual errors will be printed by webpack itself
                        err = 'Nuxt Build Error';
                      }

                      return reject(err);
                    }

                    resolve();
                  });

                case 11:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        return function (_x3, _x4) {
          return _ref4.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "webpackDev",
    value: function webpackDev(compiler) {
      consola.debug('Adding webpack middleware...'); // Create webpack dev middleware

      this.webpackDevMiddleware = pify(webpackDevMiddleware(compiler, Object.assign({
        publicPath: this.options.build.publicPath,
        stats: false,
        logLevel: 'silent',
        watchOptions: this.options.watchers.webpack
      }, this.options.build.devMiddleware)));
      this.webpackDevMiddleware.close = pify(this.webpackDevMiddleware.close);
      this.webpackHotMiddleware = pify(webpackHotMiddleware(compiler, Object.assign({
        log: false,
        heartbeat: 10000
      }, this.options.build.hotMiddleware))); // Inject to renderer instance

      if (this.nuxt.renderer) {
        this.nuxt.renderer.webpackDevMiddleware = this.webpackDevMiddleware;
        this.nuxt.renderer.webpackHotMiddleware = this.webpackHotMiddleware;
      } // Start watching client files


      this.watchClient();
    }
  }, {
    key: "watchClient",
    value: function watchClient() {
      var _this6 = this;

      var src = this.options.srcDir;
      var patterns = [r(src, this.options.dir.layouts), r(src, this.options.dir.store), r(src, this.options.dir.middleware), r(src, "".concat(this.options.dir.layouts, "/*.{vue,js}")), r(src, "".concat(this.options.dir.layouts, "/**/*.{vue,js}"))];

      if (this._nuxtPages) {
        patterns.push(r(src, this.options.dir.pages), r(src, "".concat(this.options.dir.pages, "/*.{vue,js}")), r(src, "".concat(this.options.dir.pages, "/**/*.{vue,js}")));
      }

      patterns = ___default.map(patterns, upath.normalizeSafe);
      var options = this.options.watchers.chokidar;
      /* istanbul ignore next */

      var refreshFiles = ___default.debounce(function () {
        return _this6.generateRoutesAndFiles();
      }, 200); // Watch for src Files


      this.watchers.files = chokidar.watch(patterns, options).on('add', refreshFiles).on('unlink', refreshFiles); // Watch for custom provided files

      var customPatterns = ___default.concat.apply(___default, [this.options.build.watch].concat(_toConsumableArray(___default.values(___default.omit(this.options.build.styleResources, ['options'])))));

      customPatterns = ___default.map(___default.uniq(customPatterns), upath.normalizeSafe);
      this.watchers.custom = chokidar.watch(customPatterns, options).on('change', refreshFiles);
    }
  }, {
    key: "watchServer",
    value: function watchServer() {
      var _this7 = this;

      var nuxtRestartWatch = ___default.concat(this.options.serverMiddleware.filter(function (i) {
        return typeof i === 'string';
      }).map(this.nuxt.resolveAlias), this.options.watch.map(this.nuxt.resolveAlias), path__default.join(this.options.rootDir, 'nuxt.config.js'));

      this.watchers.restart = chokidar.watch(nuxtRestartWatch, this.options.watchers.chokidar).on('change', function (_path) {
        _this7.watchers.restart.close();

        var _path$parse = path__default.parse(_path),
            name = _path$parse.name,
            ext = _path$parse.ext;

        _this7.nuxt.callHook('watch:fileChanged', _this7, "".concat(name).concat(ext));
      });
    }
  }, {
    key: "unwatch",
    value: function () {
      var _unwatch = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8() {
        var watcher;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                for (watcher in this.watchers) {
                  if (this.watchers[watcher]) {
                    this.watchers[watcher].close();
                  }
                }

                this.compilersWatching.forEach(function (watching) {
                  return watching.close();
                }); // Stop webpack middleware

                if (!this.webpackDevMiddleware) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 5;
                return this.webpackDevMiddleware.close();

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function unwatch() {
        return _unwatch.apply(this, arguments);
      };
    }() // TODO: remove ignore when generateConfig enabled again

  }, {
    key: "generateConfig",
    value: function () {
      var _generateConfig = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9() {
        var config, options;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                config = path__default.resolve(this.options.buildDir, 'build.config.js');
                options = ___default.omit(this.options, Options.unsafeKeys);
                _context9.next = 4;
                return fsExtra.writeFile(config, "export default ".concat(JSON.stringify(options, null, '  ')), 'utf8');

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function generateConfig() {
        return _generateConfig.apply(this, arguments);
      };
    }()
  }]);

  return Builder;
}();
var STATUS = {
  INITIAL: 1,
  BUILD_DONE: 2,
  BUILDING: 3
};

var Generator =
/*#__PURE__*/
function () {
  function Generator(nuxt, builder) {
    _classCallCheck(this, Generator);

    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.builder = builder; // Set variables

    this.staticRoutes = path__default.resolve(this.options.srcDir, this.options.dir.static);
    this.srcBuiltPath = path__default.resolve(this.options.buildDir, 'dist', 'client');
    this.distPath = this.options.generate.dir;
    this.distNuxtPath = path__default.join(this.distPath, isUrl(this.options.build.publicPath) ? '' : this.options.build.publicPath);
  }

  _createClass(Generator, [{
    key: "generate",
    value: function () {
      var _generate = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _ref,
            _ref$build,
            build,
            _ref$init,
            init,
            routes,
            errors,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$build = _ref.build, build = _ref$build === void 0 ? true : _ref$build, _ref$init = _ref.init, init = _ref$init === void 0 ? true : _ref$init;
                consola.debug('Initializing generator...');
                _context.next = 4;
                return this.initiate({
                  build: build,
                  init: init
                });

              case 4:
                consola.debug('Preparing routes for generate...');
                _context.next = 7;
                return this.initRoutes();

              case 7:
                routes = _context.sent;
                consola.info({
                  message: 'Generating pages',
                  badge: true,
                  clear: true
                });
                _context.next = 11;
                return this.generateRoutes(routes);

              case 11:
                errors = _context.sent;
                _context.next = 14;
                return this.afterGenerate();

              case 14:
                _context.next = 16;
                return this.nuxt.callHook('generate:done', this, errors);

              case 16:
                return _context.abrupt("return", {
                  errors: errors
                });

              case 17:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function generate() {
        return _generate.apply(this, arguments);
      };
    }()
  }, {
    key: "initiate",
    value: function () {
      var _initiate = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _ref2,
            _ref2$build,
            build,
            _ref2$init,
            init,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref2$build = _ref2.build, build = _ref2$build === void 0 ? true : _ref2$build, _ref2$init = _ref2.init, init = _ref2$init === void 0 ? true : _ref2$init;
                _context2.next = 3;
                return this.nuxt.ready();

              case 3:
                _context2.next = 5;
                return this.nuxt.callHook('generate:before', this, this.options.generate);

              case 5:
                if (!build) {
                  _context2.next = 9;
                  break;
                }

                // Add flag to set process.static
                this.builder.forGenerate(); // Start build process

                _context2.next = 9;
                return this.builder.build();

              case 9:
                if (!init) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 12;
                return this.initDist();

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function initiate() {
        return _initiate.apply(this, arguments);
      };
    }()
  }, {
    key: "initRoutes",
    value: function () {
      var _initRoutes = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var generateRoutes,
            _len,
            args,
            _key,
            routes,
            _args3 = arguments;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // Resolve config.generate.routes promises before generating the routes
                generateRoutes = [];

                if (!(this.options.router.mode !== 'hash')) {
                  _context3.next = 13;
                  break;
                }

                _context3.prev = 2;

                for (_len = _args3.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = _args3[_key];
                }

                _context3.next = 6;
                return promisifyRoute.apply(void 0, [this.options.generate.routes || []].concat(args));

              case 6:
                generateRoutes = _context3.sent;
                _context3.next = 13;
                break;

              case 9:
                _context3.prev = 9;
                _context3.t0 = _context3["catch"](2);
                consola.error('Could not resolve routes');
                throw _context3.t0;

              case 13:
                // Generate only index.html for router.mode = 'hash'
                routes = this.options.router.mode === 'hash' ? ['/'] : flatRoutes(this.options.router.routes);
                routes = this.decorateWithPayloads(routes, generateRoutes); // extendRoutes hook

                _context3.next = 17;
                return this.nuxt.callHook('generate:extendRoutes', routes);

              case 17:
                return _context3.abrupt("return", routes);

              case 18:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 9]]);
      }));

      return function initRoutes() {
        return _initRoutes.apply(this, arguments);
      };
    }()
  }, {
    key: "generateRoutes",
    value: function () {
      var _generateRoutes = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(routes) {
        var _this = this;

        var errors, _loop;

        return regeneratorRuntime.wrap(function _callee5$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                errors = []; // Start generate process

                _loop =
                /*#__PURE__*/
                regeneratorRuntime.mark(function _loop() {
                  var n;
                  return regeneratorRuntime.wrap(function _loop$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          n = 0;
                          _context5.next = 3;
                          return Promise.all(routes.splice(0, _this.options.generate.concurrency).map(
                          /*#__PURE__*/
                          function () {
                            var _ref4 = _asyncToGenerator(
                            /*#__PURE__*/
                            regeneratorRuntime.mark(function _callee4(_ref3) {
                              var route, payload;
                              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                                while (1) {
                                  switch (_context4.prev = _context4.next) {
                                    case 0:
                                      route = _ref3.route, payload = _ref3.payload;
                                      _context4.next = 3;
                                      return waitFor(n++ * _this.options.generate.interval);

                                    case 3:
                                      _context4.next = 5;
                                      return _this.generateRoute({
                                        route: route,
                                        payload: payload,
                                        errors: errors
                                      });

                                    case 5:
                                    case "end":
                                      return _context4.stop();
                                  }
                                }
                              }, _callee4, this);
                            }));

                            return function (_x2) {
                              return _ref4.apply(this, arguments);
                            };
                          }()));

                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _loop, this);
                });

              case 2:
                if (!routes.length) {
                  _context6.next = 6;
                  break;
                }

                return _context6.delegateYield(_loop(), "t0", 4);

              case 4:
                _context6.next = 2;
                break;

              case 6:
                // Improve string representation for errors
                errors.toString = function () {
                  return _this._formatErrors(errors);
                };

                return _context6.abrupt("return", errors);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee5, this);
      }));

      return function generateRoutes(_x) {
        return _generateRoutes.apply(this, arguments);
      };
    }()
  }, {
    key: "_formatErrors",
    value: function _formatErrors(errors) {
      return errors.map(function (_ref5) {
        var type = _ref5.type,
            route = _ref5.route,
            error = _ref5.error;
        var isHandled = type === 'handled';
        var bgColor = isHandled ? 'bgYellow' : 'bgRed';
        var color = isHandled ? 'yellow' : 'red';
        var line = Chalk.black[bgColor](' GEN ERR ') + Chalk[color](" ".concat(route, "\n\n"));

        if (isHandled) {
          line += Chalk.grey(JSON.stringify(error, undefined, 2) + '\n');
        } else {
          line += Chalk.grey(error.stack);
        }

        return line;
      }).join('\n');
    }
  }, {
    key: "afterGenerate",
    value: function () {
      var _afterGenerate = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var fallback, fallbackPath, _ref6, html;

        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                fallback = this.options.generate.fallback; // Disable SPA fallback if value isn't a non-empty string

                if (!(typeof fallback !== 'string' || !fallback)) {
                  _context7.next = 3;
                  break;
                }

                return _context7.abrupt("return");

              case 3:
                fallbackPath = path__default.join(this.distPath, fallback); // Prevent conflicts

                if (!fsExtra.existsSync(fallbackPath)) {
                  _context7.next = 7;
                  break;
                }

                consola.warn("SPA fallback was configured, but the configured path (".concat(fallbackPath, ") already exists."));
                return _context7.abrupt("return");

              case 7:
                _context7.next = 9;
                return this.nuxt.renderRoute('/', {
                  spa: true
                });

              case 9:
                _ref6 = _context7.sent;
                html = _ref6.html;
                _context7.next = 13;
                return fsExtra.writeFile(fallbackPath, html, 'utf8');

              case 13:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee6, this);
      }));

      return function afterGenerate() {
        return _afterGenerate.apply(this, arguments);
      };
    }()
  }, {
    key: "initDist",
    value: function () {
      var _initDist = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        var nojekyllPath;
        return regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return fsExtra.remove(this.distPath);

              case 2:
                _context8.next = 4;
                return this.nuxt.callHook('generate:distRemoved', this);

              case 4:
                if (!fsExtra.existsSync(this.staticRoutes)) {
                  _context8.next = 7;
                  break;
                }

                _context8.next = 7;
                return fsExtra.copy(this.staticRoutes, this.distPath);

              case 7:
                _context8.next = 9;
                return fsExtra.copy(this.srcBuiltPath, this.distNuxtPath);

              case 9:
                // Add .nojekyll file to let GitHub Pages add the _nuxt/ folder
                // https://help.github.com/articles/files-that-start-with-an-underscore-are-missing/
                nojekyllPath = path__default.resolve(this.distPath, '.nojekyll');
                fsExtra.writeFile(nojekyllPath, '');
                _context8.next = 13;
                return this.nuxt.callHook('generate:distCopied', this);

              case 13:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee7, this);
      }));

      return function initDist() {
        return _initDist.apply(this, arguments);
      };
    }()
  }, {
    key: "decorateWithPayloads",
    value: function decorateWithPayloads(routes, generateRoutes) {
      var routeMap = {}; // Fill routeMap for known routes

      routes.forEach(function (route) {
        routeMap[route] = {
          route: route,
          payload: null
        };
      }); // Fill routeMap with given generate.routes

      generateRoutes.forEach(function (route) {
        // route is either a string or like { route : '/my_route/1', payload: {} }
        var path$$1 = isString(route) ? route : route.route;
        routeMap[path$$1] = {
          route: path$$1,
          payload: route.payload || null
        };
      });
      return Object.values(routeMap);
    }
  }, {
    key: "generateRoute",
    value: function () {
      var _generateRoute = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(_ref7) {
        var route, _ref7$payload, payload, _ref7$errors, errors, html, pageErrors, res, minificationOptions, minifyErr, _path, page;

        return regeneratorRuntime.wrap(function _callee8$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                route = _ref7.route, _ref7$payload = _ref7.payload, payload = _ref7$payload === void 0 ? {} : _ref7$payload, _ref7$errors = _ref7.errors, errors = _ref7$errors === void 0 ? [] : _ref7$errors;
                pageErrors = [];
                _context9.prev = 2;
                _context9.next = 5;
                return this.nuxt.renderer.renderRoute(route, {
                  _generate: true,
                  payload: payload
                });

              case 5:
                res = _context9.sent;
                html = res.html;

                if (res.error) {
                  pageErrors.push({
                    type: 'handled',
                    route: route,
                    error: res.error
                  });
                }

                _context9.next = 18;
                break;

              case 10:
                _context9.prev = 10;
                _context9.t0 = _context9["catch"](2);

                /* istanbul ignore next */
                pageErrors.push({
                  type: 'unhandled',
                  route: route,
                  error: _context9.t0
                });
                Array.prototype.push.apply(errors, pageErrors);
                _context9.next = 16;
                return this.nuxt.callHook('generate:routeFailed', {
                  route: route,
                  errors: pageErrors
                });

              case 16:
                consola.error(this._formatErrors(pageErrors));
                return _context9.abrupt("return", false);

              case 18:
                minificationOptions = this.options.build.html.minify; // Legacy: Override minification options with generate.minify if present
                // TODO: Remove in Nuxt version 3

                if (typeof this.options.generate.minify !== 'undefined') {
                  minificationOptions = this.options.generate.minify;
                  consola.warn('generate.minify has been deprecated and will be removed in the next major version.' + ' Use build.html.minify instead!');
                }

                if (minificationOptions) {
                  try {
                    html = htmlMinifier.minify(html, minificationOptions);
                  } catch (err)
                  /* istanbul ignore next */
                  {
                    minifyErr = new Error("HTML minification failed. Make sure the route generates valid HTML. Failed HTML:\n ".concat(html));
                    pageErrors.push({
                      type: 'unhandled',
                      route: route,
                      error: minifyErr
                    });
                  }
                }

                if (this.options.generate.subFolders) {
                  _path = path__default.join(route, path__default.sep, 'index.html'); // /about -> /about/index.html

                  _path = _path === '/404/index.html' ? '/404.html' : _path; // /404 -> /404.html
                } else {
                  _path = route.length > 1 ? path__default.join(path__default.sep, route + '.html') : path__default.join(path__default.sep, 'index.html');
                } // Call hook to let user update the path & html


                page = {
                  route: route,
                  path: _path,
                  html: html
                };
                _context9.next = 25;
                return this.nuxt.callHook('generate:page', page);

              case 25:
                page.path = path__default.join(this.distPath, page.path); // Make sure the sub folders are created

                _context9.next = 28;
                return fsExtra.mkdirp(path__default.dirname(page.path));

              case 28:
                _context9.next = 30;
                return fsExtra.writeFile(page.path, page.html, 'utf8');

              case 30:
                _context9.next = 32;
                return this.nuxt.callHook('generate:routeCreated', {
                  route: route,
                  path: page.path,
                  errors: pageErrors
                });

              case 32:
                if (pageErrors.length) {
                  consola.error('Error generating ' + route);
                  Array.prototype.push.apply(errors, pageErrors);
                } else {
                  consola.success('Generated ' + route);
                }

                return _context9.abrupt("return", true);

              case 34:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee8, this, [[2, 10]]);
      }));

      return function generateRoute(_x3) {
        return _generateRoute.apply(this, arguments);
      };
    }()
  }]);

  return Generator;
}();

var builder = {
  Builder: Builder,
  Generator: Generator
};

consola.warn('You are using legacy build of Nuxt. Please consider upgrading your Node.js version to 8.x or later.');
var index = Object.assign({
  Utils: Utils
}, core, builder);

module.exports = index;
//# sourceMappingURL=nuxt-legacy.js.map
