/*!
 * nuxt v2.2.0 (c) 2016-2018
 * - Sebastien Chopin (@Atinux)
 * - Alexandre Chopin (@alexchopin)
 * - Pooya Parsa (@pi0)
 * - Clark Du (@clarkdo)
 * - Jonas Galvez (@galvez)
 * - Alexander Lichter (@manniL}
 * - All the amazing contributors
 * Released under the MIT License.
 * Website: https://nuxtjs.org
*/
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var _ = require('lodash');
var ___default = _interopDefault(_);
var consola = _interopDefault(require('consola'));
var fs = _interopDefault(require('fs'));
var hash = _interopDefault(require('hash-sum'));
var env = _interopDefault(require('std-env'));
var Vue = _interopDefault(require('vue'));
var VueMeta = _interopDefault(require('vue-meta'));
var vueServerRenderer = require('vue-server-renderer');
var LRU = _interopDefault(require('lru-cache'));
var Youch = _interopDefault(require('@nuxtjs/youch'));
var fsExtra = _interopDefault(require('fs-extra'));
var generateETag = _interopDefault(require('etag'));
var fresh = _interopDefault(require('fresh'));
var crypto = _interopDefault(require('crypto'));
var devalue = _interopDefault(require('@nuxtjs/devalue'));
var serveStatic = _interopDefault(require('serve-static'));
var connect = _interopDefault(require('connect'));
var launchMiddleware = _interopDefault(require('launch-editor-middleware'));
var Module = _interopDefault(require('module'));
var https = _interopDefault(require('https'));
var enableDestroy = _interopDefault(require('server-destroy'));
var Chalk = _interopDefault(require('chalk'));
var esm = _interopDefault(require('esm'));
var ip = _interopDefault(require('ip'));
var threadLoader = require('thread-loader');
var createResolver = _interopDefault(require('postcss-import-resolver'));
var MiniCssExtractPlugin = _interopDefault(require('mini-css-extract-plugin'));
var TimeFixPlugin = _interopDefault(require('time-fix-plugin'));
var VueLoader = _interopDefault(require('vue-loader'));
var WebpackBar = _interopDefault(require('webpackbar'));
var webpack = _interopDefault(require('webpack'));
var HTMLPlugin = _interopDefault(require('html-webpack-plugin'));
var BundleAnalyzer = _interopDefault(require('webpack-bundle-analyzer'));
var TerserWebpackPlugin = _interopDefault(require('terser-webpack-plugin'));
var OptimizeCSSAssetsPlugin = _interopDefault(require('optimize-css-assets-webpack-plugin'));
var FriendlyErrorsWebpackPlugin = _interopDefault(require('@nuxtjs/friendly-errors-webpack-plugin'));
var nodeExternals = _interopDefault(require('webpack-node-externals'));
var pify = _interopDefault(require('pify'));
var chokidar = _interopDefault(require('chokidar'));
var serialize = _interopDefault(require('serialize-javascript'));
var MFS = _interopDefault(require('memory-fs'));
var webpackDevMiddleware = _interopDefault(require('webpack-dev-middleware'));
var webpackHotMiddleware = _interopDefault(require('webpack-hot-middleware'));
var Glob = _interopDefault(require('glob'));
var upath = _interopDefault(require('upath'));
var htmlMinifier = _interopDefault(require('html-minifier'));

const encodeHtml = function encodeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
};

const getContext = function getContext(req, res) {
  return { req, res }
};

const waitFor = function waitFor(ms) {
  return new Promise(resolve => setTimeout(resolve, ms || 0))
};

const isString = function isString(obj) {
  return typeof obj === 'string' || obj instanceof String
};
const startsWithAlias = aliasArray => str => aliasArray.some(c => str.startsWith(c));

const startsWithSrcAlias = startsWithAlias(['@', '~']);

const startsWithRootAlias = startsWithAlias(['@@', '~~']);

async function promiseFinally(fn, finalFn) {
  let result;
  try {
    if (typeof fn === 'function') {
      result = await fn();
    } else {
      result = await fn;
    }
  } finally {
    finalFn();
  }
  return result
}

const timeout = function timeout(fn, ms, msg) {
  let timerId;
  const warpPromise = promiseFinally(fn, () => clearTimeout(timerId));
  const timerPromise = new Promise((resolve, reject) => {
    timerId = setTimeout(() => reject(new Error(msg)), ms);
  });
  return Promise.race([warpPromise, timerPromise])
};

const urlJoin = function urlJoin() {
  return [].slice
    .call(arguments)
    .join('/')
    .replace(/\/+/g, '/')
    .replace(':/', '://')
};

const isUrl = function isUrl(url) {
  return ['http', '//'].some(str => url.startsWith(str))
};

const promisifyRoute = function promisifyRoute(fn, ...args) {
  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn)
  }
  // If routes is a function expecting a callback
  if (fn.length === arguments.length) {
    return new Promise((resolve, reject) => {
      fn((err, routeParams) => {
        if (err) {
          reject(err);
        }
        resolve(routeParams);
      }, ...args);
    })
  }
  let promise = fn(...args);
  if (
    !promise ||
    (!(promise instanceof Promise) && typeof promise.then !== 'function')
  ) {
    promise = Promise.resolve(promise);
  }
  return promise
};

const sequence = function sequence(tasks, fn) {
  return tasks.reduce(
    (promise, task) => promise.then(() => fn(task)),
    Promise.resolve()
  )
};

const parallel = function parallel(tasks, fn) {
  return Promise.all(tasks.map(fn))
};

const chainFn = function chainFn(base, fn) {
  /* istanbul ignore if */
  if (typeof fn !== 'function') {
    return base
  }
  return function () {
    if (typeof base !== 'function') {
      return fn.apply(this, arguments)
    }
    let baseResult = base.apply(this, arguments);
    // Allow function to mutate the first argument instead of returning the result
    if (baseResult === undefined) {
      baseResult = arguments[0];
    }
    const fnResult = fn.call(
      this,
      baseResult,
      ...Array.prototype.slice.call(arguments, 1)
    );
    // Return mutated argument if no result was returned
    if (fnResult === undefined) {
      return baseResult
    }
    return fnResult
  }
};

const isPureObject = function isPureObject(o) {
  return !Array.isArray(o) && typeof o === 'object'
};

const isWindows = /^win/.test(process.platform);

const wp = function wp(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\\/g, '\\\\')
  }
  return p
};

const wChunk = function wChunk(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\//g, '_')
  }
  return p
};

const reqSep = /\//g;
const sysSep = ___default.escapeRegExp(path__default.sep);
const normalize = string => string.replace(reqSep, sysSep);

const r = function r(...args) {
  const lastArg = args[args.length - 1];

  if (startsWithSrcAlias(lastArg)) {
    return wp(lastArg)
  }

  return wp(path__default.resolve(...args.map(normalize)))
};

const relativeTo = function relativeTo() {
  const args = Array.prototype.slice.apply(arguments);
  const dir = args.shift();

  // Keep webpack inline loader intact
  if (args[0].includes('!')) {
    const loaders = args.shift().split('!');

    return loaders.concat(relativeTo(dir, loaders.pop(), ...args)).join('!')
  }

  // Resolve path
  const _path = r(...args);

  // Check if path is an alias
  if (startsWithSrcAlias(_path)) {
    return _path
  }

  // Make correct relative path
  let rp = path__default.relative(dir, _path);
  if (rp[0] !== '.') {
    rp = './' + rp;
  }

  return wp(rp)
};

const flatRoutes = function flatRoutes(router, _path = '', routes = []) {
  router.forEach((r) => {
    if ([':', '*'].some(c => r.path.includes(c))) {
      return
    }
    /* istanbul ignore if */
    if (r.children) {
      if (_path === '' && r.path === '/') {
        routes.push('/');
      }
      return flatRoutes(r.children, _path + r.path + '/', routes)
    }
    _path = _path.replace(/^\/+$/, '/');
    routes.push(
      (r.path === '' && _path[_path.length - 1] === '/'
        ? _path.slice(0, -1)
        : _path) + r.path
    );
  });
  return routes
};

function cleanChildrenRoutes(routes, isChild = false) {
  let start = -1;
  const routesIndex = [];
  routes.forEach((route) => {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      const res = route.name.split('-');
      const s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach((route) => {
    route.path = isChild ? route.path.replace('/', '') : route.path;
    if (route.path.includes('?')) {
      const names = route.name.split('-');
      const paths = route.path.split('/');
      if (!isChild) {
        paths.shift();
      } // clean first / for parents
      routesIndex.forEach((r) => {
        const i = r.indexOf('index') - start; //  children names
        if (i < paths.length) {
          for (let a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }
            if (a < i && names[a] !== r[a]) {
              break
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }
    route.name = route.name.replace(/-index$/, '');
    if (route.children) {
      if (route.children.find(child => child.path === '')) {
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes
}

const createRoutes = function createRoutes(files, srcDir, pagesDir) {
  const routes = [];
  files.forEach((file) => {
    const keys = file
      .replace(RegExp(`^${pagesDir}`), '')
      .replace(/\.(vue|js)$/, '')
      .replace(/\/{2,}/g, '/')
      .split('/')
      .slice(1);
    const route = { name: '', path: '', component: r(srcDir, file) };
    let parent = routes;
    keys.forEach((key, i) => {
      // remove underscore only, if its the prefix
      const sanitizedKey = key.startsWith('_') ? key.substr(1) : key;

      route.name = route.name
        ? route.name + '-' + sanitizedKey
        : sanitizedKey;
      route.name += key === '_' ? 'all' : '';
      route.chunkName = file.replace(/\.(vue|js)$/, '');
      const child = parent.find(parentRoute => parentRoute.name === route.name);

      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = '';
      } else if (key === 'index' && i + 1 === keys.length) {
        route.path += i > 0 ? '' : '/';
      } else {
        route.path += '/' + getRoutePathExtension(key);

        if (key.startsWith('_') && key.length > 1) {
          route.path += '?';
        }
      }
    });
    // Order Routes path
    parent.push(route);
    parent.sort((a, b) => {
      if (!a.path.length) {
        return -1
      }
      if (!b.path.length) {
        return 1
      }
      // Order: /static, /index, /:dynamic
      // Match exact route before index: /login before /index/_slug
      if (a.path === '/') {
        return DYNAMIC_ROUTE_REGEX.test(b.path) ? -1 : 1
      }
      if (b.path === '/') {
        return DYNAMIC_ROUTE_REGEX.test(a.path) ? 1 : -1
      }

      let i;
      let res = 0;
      let y = 0;
      let z = 0;
      const _a = a.path.split('/');
      const _b = b.path.split('/');
      for (i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break
        }
        y = _a[i] === '*' ? 2 : _a[i].includes(':') ? 1 : 0;
        z = _b[i] === '*' ? 2 : _b[i].includes(':') ? 1 : 0;
        res = y - z;
        // If a.length >= b.length
        if (i === _b.length - 1 && res === 0) {
          // change order if * found
          res = _a[i] === '*' ? -1 : 1;
        }
      }
      return res === 0 ? (_a[i - 1] === '*' && _b[i] ? 1 : -1) : res
    });
  });
  return cleanChildrenRoutes(routes)
};

// Guard dir1 from dir2 which can be indiscriminately removed
const guardDir = function guardDir(options, key1, key2) {
  const dir1 = ___default.get(options, key1, false);
  const dir2 = ___default.get(options, key2, false);

  if (
    dir1 &&
    dir2 &&
    (
      dir1 === dir2 ||
      (
        dir1.startsWith(dir2) &&
        !path__default.basename(dir1).startsWith(path__default.basename(dir2))
      )
    )
  ) {
    const errorMessage = `options.${key2} cannot be a parent of or same as ${key1}`;
    consola.fatal(errorMessage);
    throw new Error(errorMessage)
  }
};

const determineGlobals = function determineGlobals(globalName, globals) {
  const _globals = {};
  for (const global in globals) {
    if (typeof globals[global] === 'function') {
      _globals[global] = globals[global](globalName);
    } else {
      _globals[global] = globals[global];
    }
  }
  return _globals
};

const getRoutePathExtension = (key) => {
  if (key === '_') {
    return '*'
  }

  if (key.startsWith('_')) {
    return `:${key.substr(1)}`
  }

  return key
};

const DYNAMIC_ROUTE_REGEX = /^\/(:|\*)/;

/**
 * Wraps value in array if it is not already an array
 *
 * @param  {any} value
 * @return {array}
 */
const wrapArray = value => Array.isArray(value) ? value : [value];

var Utils = /*#__PURE__*/Object.freeze({
  encodeHtml: encodeHtml,
  getContext: getContext,
  waitFor: waitFor,
  isString: isString,
  startsWithAlias: startsWithAlias,
  startsWithSrcAlias: startsWithSrcAlias,
  startsWithRootAlias: startsWithRootAlias,
  timeout: timeout,
  urlJoin: urlJoin,
  isUrl: isUrl,
  promisifyRoute: promisifyRoute,
  sequence: sequence,
  parallel: parallel,
  chainFn: chainFn,
  isPureObject: isPureObject,
  isWindows: isWindows,
  wp: wp,
  wChunk: wChunk,
  r: r,
  relativeTo: relativeTo,
  flatRoutes: flatRoutes,
  createRoutes: createRoutes,
  guardDir: guardDir,
  determineGlobals: determineGlobals,
  wrapArray: wrapArray
});

class ModuleContainer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.requiredModules = {};
  }

  async ready() {
    // Call before hook
    await this.nuxt.callHook('modules:before', this, this.options.modules);

    // Load every module in sequence
    await sequence(this.options.modules, this.addModule.bind(this));

    // Call done hook
    await this.nuxt.callHook('modules:done', this);
  }

  addVendor() {
    consola.warn('addVendor has been deprecated due to webpack4 optimization');
  }

  addTemplate(template) {
    /* istanbul ignore if */
    if (!template) {
      throw new Error('Invalid template:' + JSON.stringify(template))
    }

    // Validate & parse source
    const src = template.src || template;
    const srcPath = path__default.parse(src);
    /* istanbul ignore if */
    if (typeof src !== 'string' || !fs.existsSync(src)) {
      throw new Error('Template src not found:' + src)
    }

    // Generate unique and human readable dst filename
    const dst =
      template.fileName ||
      path__default.basename(srcPath.dir) + `.${srcPath.name}.${hash(src)}` + srcPath.ext;

    // Add to templates list
    const templateObj = {
      src,
      dst,
      options: template.options
    };

    this.options.build.templates.push(templateObj);
    return templateObj
  }

  addPlugin(template) {
    const { dst } = this.addTemplate(template);

    // Add to nuxt plugins
    this.options.plugins.unshift({
      src: path__default.join(this.options.buildDir, dst),
      ssr: template.ssr
    });
  }

  addLayout(template, name) {
    const { dst, src } = this.addTemplate(template);

    // Add to nuxt layouts
    this.options.layouts[name || path__default.parse(src).name] = `./${dst}`;

    // If error layout, set ErrorPage
    if (name === 'error') {
      this.addErrorLayout(dst);
    }
  }

  addErrorLayout(dst) {
    const relativeBuildDir = path__default.relative(this.options.rootDir, this.options.buildDir);
    this.options.ErrorPage = `~/${relativeBuildDir}/${dst}`;
  }

  addServerMiddleware(middleware) {
    this.options.serverMiddleware.push(middleware);
  }

  extendBuild(fn) {
    this.options.build.extend = chainFn(this.options.build.extend, fn);
  }

  extendRoutes(fn) {
    this.options.router.extendRoutes = chainFn(
      this.options.router.extendRoutes,
      fn
    );
  }

  requireModule(moduleOpts) {
    return this.addModule(moduleOpts, true /* require once */)
  }

  addModule(moduleOpts, requireOnce) {
    let src;
    let options;
    let handler;

    // Type 1: String
    if (typeof moduleOpts === 'string') {
      src = moduleOpts;
    } else if (Array.isArray(moduleOpts)) {
      // Type 2: Babel style array
      src = moduleOpts[0];
      options = moduleOpts[1];
    } else if (typeof moduleOpts === 'object') {
      // Type 3: Pure object
      src = moduleOpts.src;
      options = moduleOpts.options;
      handler = moduleOpts.handler;
    }

    // Resolve handler
    if (!handler) {
      handler = this.nuxt.requireModule(src);
    }

    // Validate handler
    /* istanbul ignore if */
    if (typeof handler !== 'function') {
      throw new Error('Module should export a function: ' + src)
    }

    // Resolve module meta
    const key = (handler.meta && handler.meta.name) || handler.name || src;

    // Update requiredModules
    if (typeof key === 'string') {
      if (requireOnce && this.requiredModules[key]) {
        return
      }
      this.requiredModules[key] = { src, options, handler };
    }

    // Default module options to empty object
    if (options === undefined) {
      options = {};
    }

    return new Promise((resolve) => {
      // Call module with `this` context and pass options
      const result = handler.call(this, options);

      // If module send back a promise
      if (result && result.then) {
        return resolve(result)
      }

      // synchronous
      return resolve()
    })
  }
}

var modes = {
  universal: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  spa: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
};

const nuxtDir = fs.existsSync(path__default.resolve(__dirname, '..', 'package.json'))
  ? path__default.resolve(__dirname, '..') // dist
  : path__default.resolve(__dirname, '..', '..'); // src

var defaults = {
  // Information about running environment
  dev: Boolean(env.dev),
  debug: undefined, // = dev

  // Mode
  mode: 'universal',

  // Global name
  globalName: `nuxt`,
  globals: {
    id: globalName => `__${globalName}`,
    nuxt: globalName => `$${globalName}`,
    context: globalName => `__${globalName.toUpperCase()}__`,
    pluginPrefix: globalName => globalName,
    readyCallback: globalName => `on${___default.capitalize(globalName)}Ready`,
    loadedCallback: globalName => `_on${___default.capitalize(globalName)}Loaded`
  },

  // Server options
  server: {
    https: false,
    port: process.env.NUXT_PORT ||
      process.env.PORT ||
      process.env.npm_package_config_nuxt_port,
    host: process.env.NUXT_HOST ||
      process.env.HOST ||
      process.env.npm_package_config_nuxt_host
  },

  // Dirs
  srcDir: undefined,
  buildDir: '.nuxt',
  nuxtDir,
  nuxtAppDir: path__default.resolve(nuxtDir, 'lib', 'app'),
  modulesDir: ['node_modules'], // ~> relative to options.rootDir

  // Ignore
  ignorePrefix: '-',
  ignore: [
    '**/*.test.*',
    '**/*.spec.*'
  ],

  extensions: [],

  build: {
    quiet: Boolean(env.ci || env.test),
    analyze: false,
    profile: process.argv.includes('--profile'),
    extractCSS: false,
    cssSourceMap: undefined,
    ssr: undefined,
    parallel: false,
    cache: false,
    publicPath: '/_nuxt/',
    filenames: {
      // { isDev, isClient, isServer }
      app: ({ isDev }) => isDev ? '[name].js' : '[chunkhash].js',
      chunk: ({ isDev }) => isDev ? '[name].js' : '[chunkhash].js',
      css: ({ isDev }) => isDev ? '[name].css' : '[contenthash].css',
      img: ({ isDev }) => isDev ? '[path][name].[ext]' : 'img/[hash:7].[ext]',
      font: ({ isDev }) => isDev ? '[path][name].[ext]' : 'fonts/[hash:7].[ext]',
      video: ({ isDev }) => isDev ? '[path][name].[ext]' : 'videos/[hash:7].[ext]'
    },
    loaders: {
      file: {},
      fontUrl: { limit: 1000 },
      imgUrl: { limit: 1000 },
      pugPlain: {},
      vue: {
        transformAssetUrls: {
          video: 'src',
          source: 'src',
          object: 'src',
          embed: 'src'
        }
      },
      css: {},
      cssModules: {
        localIdentName: '[local]_[hash:base64:5]'
      },
      less: {},
      sass: {
        indentedSyntax: true
      },
      scss: {},
      stylus: {},
      vueStyle: {}
    },
    styleResources: {},
    plugins: [],
    terser: {},
    optimizeCSS: undefined,
    optimization: {
      runtimeChunk: 'single',
      minimize: undefined,
      minimizer: undefined,
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '.',
        name: undefined,
        cacheGroups: {}
      }
    },
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    babel: {
      babelrc: false,
      cacheDirectory: undefined
    },
    transpile: [], // Name of NPM packages to be transpiled
    postcss: {
      preset: {
        // https://cssdb.org/#staging-process
        stage: 2
      }
    },
    html: {
      minify: {
        collapseBooleanAttributes: true,
        decodeEntities: true,
        minifyCSS: true,
        minifyJS: true,
        processConditionalComments: true,
        removeEmptyAttributes: true,
        removeRedundantAttributes: true,
        trimCustomFragments: true,
        useShortDoctype: true
      }
    },

    templates: [],
    watch: [],
    devMiddleware: {},
    hotMiddleware: {},
    stats: {
      chunks: false,
      children: false,
      modules: false,
      colors: true,
      warnings: true,
      errors: true,
      excludeAssets: [
        /.map$/,
        /index\..+\.html$/,
        /vue-ssr-client-manifest.json/
      ]
    }
  },
  generate: {
    dir: 'dist',
    routes: [],
    concurrency: 500,
    interval: 0,
    subFolders: true,
    fallback: '200.html'
  },
  env: {},
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  plugins: [],
  css: [],
  modules: [],
  layouts: {},
  serverMiddleware: [],
  ErrorPage: null,
  loading: {
    color: 'black',
    failedColor: 'red',
    height: '2px',
    throttle: 200,
    duration: 5000,
    rtl: false
  },
  loadingIndicator: 'default',
  transition: {
    name: 'page',
    mode: 'out-in',
    appear: false,
    appearClass: 'appear',
    appearActiveClass: 'appear-active',
    appearToClass: 'appear-to'
  },
  layoutTransition: {
    name: 'layout',
    mode: 'out-in'
  },
  dir: {
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    pages: 'pages',
    static: 'static',
    store: 'store'
  },
  vue: {
    config: {
      silent: undefined, // = !dev
      performance: undefined // = dev
    }
  },
  router: {
    mode: 'history',
    base: '/',
    routes: [],
    middleware: [],
    linkActiveClass: 'nuxt-link-active',
    linkExactActiveClass: 'nuxt-link-exact-active',
    extendRoutes: null,
    scrollBehavior: null,
    parseQuery: false,
    stringifyQuery: false,
    fallback: false
  },
  render: {
    bundleRenderer: {
      shouldPrefetch: () => false
    },
    resourceHints: true,
    ssr: undefined,
    http2: {
      push: false,
      shouldPush: null
    },
    static: {
      prefix: true
    },
    compressor: {
      threshold: 0
    },
    etag: {
      weak: false
    },
    csp: false,
    dist: {
      // Don't serve index.html template
      index: false,
      // 1 year in production
      maxAge: '1y'
    }
  },
  // User-defined changes
  watch: [],
  watchers: {
    webpack: {},
    chokidar: {
      ignoreInitial: true
    }
  },
  editor: undefined,
  hooks: null,
  messages: {
    loading: 'Loading...',
    error_404: 'This page could not be found',
    server_error: 'Server error',
    nuxtjs: 'Nuxt.js',
    back_to_home: 'Back to the home page',
    server_error_details:
      'An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.',
    client_error: 'Error',
    client_error_details:
      'An error occurred while rendering the page. Check developer tools console for details.'
  }
};

// hasValue utility
const hasValue = v => typeof v === 'string' && v;

const Options = {};

Options.from = function (_options) {
  // Clone options to prevent unwanted side-effects
  const options = Object.assign({}, _options);

  // Normalize options
  if (options.loading === true) {
    delete options.loading;
  }
  if (
    options.router &&
    options.router.middleware &&
    !Array.isArray(options.router.middleware)
  ) {
    options.router.middleware = [options.router.middleware];
  }
  if (options.router && typeof options.router.base === 'string') {
    options._routerBaseSpecified = true;
  }
  if (typeof options.transition === 'string') {
    options.transition = { name: options.transition };
  }
  if (typeof options.layoutTransition === 'string') {
    options.layoutTransition = { name: options.layoutTransition };
  }
  if (typeof options.extensions === 'string') {
    options.extensions = [options.extensions];
  }

  options.globalName = (___default.isString(options.globalName) && /^[a-zA-Z]+$/.test(options.globalName))
    ? options.globalName.toLowerCase()
    : 'nuxt';

  // Resolve rootDir
  options.rootDir = hasValue(options.rootDir) ? path__default.resolve(options.rootDir) : process.cwd();

  // Apply defaults by ${buildDir}/dist/build.config.js
  // TODO: Unsafe operation.
  // const buildDir = options.buildDir || defaults.buildDir
  // const buildConfig = resolve(options.rootDir, buildDir, 'build.config.js')
  // if (existsSync(buildConfig)) {
  //   _.defaultsDeep(options, require(buildConfig))
  // }

  // Apply defaults
  ___default.defaultsDeep(options, defaults);

  // Check srcDir and generate.dir excistence
  const hasSrcDir = hasValue(options.srcDir);
  const hasGenerateDir = hasValue(options.generate.dir);

  // Resolve srcDir
  options.srcDir = hasSrcDir
    ? path__default.resolve(options.rootDir, options.srcDir)
    : options.rootDir;

  // Resolve buildDir
  options.buildDir = path__default.resolve(options.rootDir, options.buildDir);

  // Protect rootDir against buildDir
  guardDir(options, 'rootDir', 'buildDir');

  if (hasGenerateDir) {
    // Resolve generate.dir
    options.generate.dir = path__default.resolve(options.rootDir, options.generate.dir);

    // Protect rootDir against buildDir
    guardDir(options, 'rootDir', 'generate.dir');
  }

  if (hasSrcDir) {
    // Protect srcDir against buildDir
    guardDir(options, 'srcDir', 'buildDir');

    if (hasGenerateDir) {
      // Protect srcDir against generate.dir
      guardDir(options, 'srcDir', 'generate.dir');
    }
  }

  // Populate modulesDir
  options.modulesDir = []
    .concat(options.modulesDir)
    .concat(path__default.join(options.nuxtDir, 'node_modules')).filter(hasValue)
    .map(dir => path__default.resolve(options.rootDir, dir));

  const mandatoryExtensions = ['js', 'mjs'];

  options.extensions = mandatoryExtensions
    .filter(ext => !options.extensions.includes(ext))
    .concat(options.extensions);

  // If app.html is defined, set the template path to the user template
  if (options.appTemplatePath === undefined) {
    options.appTemplatePath = path__default.resolve(options.buildDir, 'views/app.template.html');
    if (fs.existsSync(path__default.join(options.srcDir, 'app.html'))) {
      options.appTemplatePath = path__default.join(options.srcDir, 'app.html');
    }
  } else {
    options.appTemplatePath = path__default.resolve(options.srcDir, options.appTemplatePath);
  }

  // Ignore publicPath on dev
  /* istanbul ignore if */
  if (options.dev && isUrl(options.build.publicPath)) {
    options.build.publicPath = defaults.build.publicPath;
  }

  // If store defined, update store options to true unless explicitly disabled
  if (
    options.store !== false &&
    fs.existsSync(path__default.join(options.srcDir, options.dir.store)) &&
    fs.readdirSync(path__default.join(options.srcDir, options.dir.store))
      .find(filename => filename !== 'README.md' && filename[0] !== '.')
  ) {
    options.store = true;
  }

  // SPA loadingIndicator
  if (options.loadingIndicator) {
    // Normalize loadingIndicator
    if (!isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = { name: options.loadingIndicator };
    }

    // Apply defaults
    options.loadingIndicator = Object.assign(
      {
        name: 'default',
        color: (options.loading && options.loading.color) || '#D3D3D3',
        color2: '#F5F5F5',
        background: (options.manifest && options.manifest.theme_color) || 'white',
        dev: options.dev,
        loading: options.messages.loading
      },
      options.loadingIndicator
    );
  }

  // Debug errors
  if (options.debug === undefined) {
    options.debug = options.dev;
  }

  // Apply default hash to CSP option
  const csp = options.render.csp;
  const cspDefaults = {
    hashAlgorithm: 'sha256',
    allowedSources: undefined,
    policies: undefined,
    reportOnly: options.debug
  };
  if (csp) {
    options.render.csp = ___default.defaults(___default.isObject(csp) ? csp : {}, cspDefaults);
  }

  // cssSourceMap
  if (options.build.cssSourceMap === undefined) {
    options.build.cssSourceMap = options.dev;
  }

  // babel cacheDirectory
  if (options.build.babel.cacheDirectory === undefined) {
    options.build.babel.cacheDirectory = options.dev;
  }

  // vue config
  const vueConfig = options.vue.config;

  if (vueConfig.silent === undefined) {
    vueConfig.silent = !options.dev;
  }
  if (vueConfig.performance === undefined) {
    vueConfig.performance = options.dev;
  }

  // merge custom env with variables
  const eligibleEnvVariables = ___default.pick(process.env, Object.keys(process.env).filter(k => k.startsWith('NUXT_ENV_')));
  Object.assign(options.env, eligibleEnvVariables);

  // Normalize ignore
  options.ignore = options.ignore ? [].concat(options.ignore) : [];

  // Append ignorePrefix glob to ignore
  if (typeof options.ignorePrefix === 'string') {
    options.ignore.push(`**/${options.ignorePrefix}*.*`);
  }

  // Compression middleware legacy
  if (options.render.gzip) {
    consola.warn('render.gzip is deprecated and will be removed in a future version! Please switch to render.compressor');
    options.render.compressor = options.render.gzip;
    delete options.render.gzip;
  }

  // Apply mode preset
  const modePreset = modes[options.mode || 'universal'] || modes.universal;
  ___default.defaultsDeep(options, modePreset);

  // If no server-side rendering, add appear true transition
  /* istanbul ignore if */
  if (options.render.ssr === false && options.transition) {
    options.transition.appear = true;
  }

  // We assume the SPA fallback path is 404.html (for GitHub Pages, Surge, etc.)
  if (options.generate.fallback === true) {
    options.generate.fallback = '404.html';
  }

  if (options.build.stats === 'none' || options.build.quiet === true) {
    options.build.stats = false;
  }

  // Vendor backward compatibility with nuxt 1.x
  if (typeof options.build.vendor !== 'undefined') {
    delete options.build.vendor;
    consola.warn('vendor has been deprecated due to webpack4 optimization');
  }

  // TODO: remove when mini-css-extract-plugin supports HMR
  if (options.dev) {
    options.build.extractCSS = false;
  }

  // Enable minimize for production builds
  if (options.build.optimization.minimize === undefined) {
    options.build.optimization.minimize = !options.dev;
  }

  // Enable optimizeCSS only when extractCSS is enabled
  if (options.build.optimizeCSS === undefined) {
    options.build.optimizeCSS = options.build.extractCSS ? {} : false;
  }

  const loaders = options.build.loaders;
  const vueLoader = loaders.vue;
  if (vueLoader.productionMode === undefined) {
    vueLoader.productionMode = !options.dev;
  }
  const styleLoaders = [
    'css', 'cssModules', 'less',
    'sass', 'scss', 'stylus', 'vueStyle'
  ];
  for (const name of styleLoaders) {
    const loader = loaders[name];
    if (loader && loader.sourceMap === undefined) {
      loader.sourceMap = Boolean(options.build.cssSourceMap);
    }
  }

  // include SFCs in node_modules
  options.build.transpile = [].concat(options.build.transpile || [])
    .map(module => module instanceof RegExp ? module : new RegExp(module));

  if (options.build.quiet === true) {
    consola.level = 0;
  }

  return options
};

var name = "nuxt";
var version = "2.2.0";
var description = "A minimalistic framework for server-rendered Vue.js applications (inspired by Next.js)";
var contributors = [
	{
		name: "Sebastien Chopin (@Atinux)"
	},
	{
		name: "Alexandre Chopin (@alexchopin)"
	},
	{
		name: "Pooya Parsa (@pi0)"
	},
	{
		name: "Clark Du (@clarkdo)"
	},
	{
		name: "Jonas Galvez (@galvez)"
	},
	{
		name: "Alexander Lichter (@manniL}"
	}
];
var main = "index.js";
var module$1 = "./lib/nuxt.js";
var license = "MIT";
var repository = {
	type: "git",
	url: "git+https://github.com/nuxt/nuxt.js"
};
var files = [
	"bin",
	"lib",
	"dist",
	"index.js"
];
var keywords = [
	"nuxt",
	"nuxt.js",
	"nuxtjs",
	"vue",
	"vue.js",
	"vuejs",
	"vue universal",
	"vue ssr",
	"vue server side",
	"ssr",
	"vue isomorphic",
	"vue versatile"
];
var homepage = "https://github.com/nuxt/nuxt.js#readme";
var bin = {
	nuxt: "./bin/nuxt"
};
var scripts = {
	build: "node -r esm ./packages/nuxt-pack/build.js",
	coverage: "codecov",
	lint: "eslint --ext .js,.mjs,.vue bin/** benchmarks examples lib packages test",
	postinstall: "opencollective || exit 0",
	test: "yarn test:fixtures && yarn test:unit",
	"test:fixtures": "jest test/fixtures",
	"test:e2e": "jest -i test/e2e",
	"test:lint": "yarn lint",
	"test:unit": "jest test/unit"
};
var engines = {
	node: ">=8.0.0",
	npm: ">=5.0.0"
};
var dependencies = {
	"@babel/core": "^7.1.2",
	"@babel/polyfill": "^7.0.0",
	"@nuxtjs/babel-preset-app": "^0.7.0",
	"@nuxtjs/devalue": "^1.0.0",
	"@nuxtjs/friendly-errors-webpack-plugin": "^2.0.2",
	"@nuxtjs/opencollective": "^0.1.0",
	"@nuxtjs/youch": "^4.2.3",
	"babel-loader": "^8.0.4",
	"cache-loader": "^1.2.2",
	"caniuse-lite": "^1.0.30000890",
	chalk: "^2.4.1",
	chokidar: "^2.0.4",
	compression: "^1.7.3",
	connect: "^3.6.6",
	consola: "^1.4.4",
	"css-loader": "^1.0.0",
	cssnano: "^4.1.4",
	debug: "^4.1.0",
	esm: "^3.0.84",
	etag: "^1.8.1",
	"file-loader": "^2.0.0",
	fresh: "^0.5.2",
	"fs-extra": "^7.0.0",
	glob: "^7.1.3",
	"hash-sum": "^1.0.2",
	"html-minifier": "^3.5.20",
	"html-webpack-plugin": "^3.2.0",
	ip: "^1.1.5",
	"launch-editor-middleware": "^2.2.1",
	lodash: "^4.17.11",
	"lru-cache": "^4.1.3",
	"memory-fs": "^0.4.1",
	"mini-css-extract-plugin": "^0.4.4",
	minimist: "^1.2.0",
	"optimize-css-assets-webpack-plugin": "^5.0.1",
	pify: "^4.0.0",
	postcss: "^7.0.5",
	"postcss-import": "^12.0.0",
	"postcss-import-resolver": "^1.1.0",
	"postcss-loader": "^3.0.0",
	"postcss-preset-env": "^6.1.1",
	"postcss-url": "^8.0.0",
	semver: "^5.6.0",
	"serialize-javascript": "^1.5.0",
	"serve-static": "^1.13.2",
	"server-destroy": "^1.0.1",
	"std-env": "^2.0.2",
	"style-resources-loader": "^1.2.1",
	"terser-webpack-plugin": "^1.1.0",
	"thread-loader": "^1.2.0",
	"time-fix-plugin": "^2.0.3",
	upath: "^1.1.0",
	"url-loader": "^1.1.2",
	vue: "^2.5.17",
	"vue-loader": "^15.4.2",
	"vue-meta": "^1.5.5",
	"vue-no-ssr": "^1.0.0",
	"vue-router": "^3.0.1",
	"vue-server-renderer": "^2.5.17",
	"vue-template-compiler": "^2.5.17",
	vuex: "^3.0.1",
	webpack: "^4.20.2",
	"webpack-bundle-analyzer": "^3.0.2",
	"webpack-dev-middleware": "^3.4.0",
	"webpack-hot-middleware": "^2.24.3",
	"webpack-node-externals": "^1.7.2",
	webpackbar: "^2.6.3"
};
var devDependencies = {
	"@babel/preset-env": "^7.1.0",
	"babel-core": "^7.0.0-bridge",
	"babel-eslint": "^10.0.1",
	"babel-jest": "^23.6.0",
	"babel-plugin-dynamic-import-node": "^2.2.0",
	codecov: "^3.1.0",
	"cross-env": "^5.2.0",
	"cross-spawn": "^6.0.5",
	eslint: "^5.7.0",
	"eslint-config-standard": "^12.0.0",
	"eslint-plugin-import": "^2.14.0",
	"eslint-plugin-jest": "^21.24.1",
	"eslint-plugin-node": "^7.0.1",
	"eslint-plugin-promise": "^4.0.1",
	"eslint-plugin-standard": "^4.0.0",
	"eslint-plugin-vue": "^5.0.0-beta.3",
	express: "^4.16.4",
	finalhandler: "^1.1.1",
	"get-port": "^4.0.0",
	jest: "^23.6.0",
	jsdom: "^12.2.0",
	"klaw-sync": "^6.0.0",
	pug: "^2.0.3",
	"pug-plain-loader": "^1.0.0",
	puppeteer: "^1.9.0",
	request: "^2.88.0",
	"request-promise-native": "^1.0.5",
	rimraf: "^2.6.2",
	rollup: "^0.66.6",
	"rollup-plugin-babel": "^4.0.3",
	"rollup-plugin-commonjs": "^9.2.0",
	"rollup-plugin-json": "^3.1.0",
	"rollup-plugin-license": "^0.7.0"
};
var collective = {
	url: "https://opencollective.com/nuxtjs",
	logoUrl: "https://opencollective.com/nuxtjs/logo.txt?reverse=true&variant=variant2"
};
var packageJSON = {
	name: name,
	version: version,
	description: description,
	contributors: contributors,
	main: main,
	module: module$1,
	license: license,
	repository: repository,
	files: files,
	keywords: keywords,
	homepage: homepage,
	bin: bin,
	scripts: scripts,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	collective: collective
};

class MetaRenderer {
  constructor(nuxt, renderer) {
    this.nuxt = nuxt;
    this.renderer = renderer;
    this.options = nuxt.options;
    this.vueRenderer = vueServerRenderer.createRenderer();
    this.cache = LRU({});

    // Add VueMeta to Vue (this is only for SPA mode)
    // See lib/app/index.js
    Vue.use(VueMeta, {
      keyName: 'head',
      attribute: 'data-n-head',
      ssrAttribute: 'data-n-head-ssr',
      tagIDKeyName: 'hid'
    });
  }

  async getMeta(url) {
    const vm = new Vue({
      render: h => h(), // Render empty html tag
      head: this.options.head || {}
    });
    await this.vueRenderer.renderToString(vm);
    return vm.$meta().inject()
  }

  async render({ url = '/' }) {
    let meta = this.cache.get(url);

    if (meta) {
      return meta
    }

    meta = {
      HTML_ATTRS: '',
      BODY_ATTRS: '',
      HEAD: '',
      BODY_SCRIPTS: ''
    };

    // Get vue-meta context
    const m = await this.getMeta(url);

    // HTML_ATTRS
    meta.HTML_ATTRS = m.htmlAttrs.text();

    // BODY_ATTRS
    meta.BODY_ATTRS = m.bodyAttrs.text();

    // HEAD tags
    meta.HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();

    // BODY_SCRIPTS
    meta.BODY_SCRIPTS = m.script.text({ body: true }) + m.noscript.text({ body: true });

    // Resources Hints

    meta.resourceHints = '';

    const clientManifest = this.renderer.resources.clientManifest;

    const shouldPreload = this.options.render.bundleRenderer.shouldPreload || (() => true);
    const shouldPrefetch = this.options.render.bundleRenderer.shouldPrefetch || (() => true);

    if (this.options.render.resourceHints && clientManifest) {
      const publicPath = clientManifest.publicPath || '/_nuxt/';

      // Preload initial resources
      if (Array.isArray(clientManifest.initial)) {
        meta.resourceHints += clientManifest.initial
          .filter(file => shouldPreload(file))
          .map(
            r => `<link rel="preload" href="${publicPath}${r}" as="script" />`
          )
          .join('');
      }

      // Prefetch async resources
      if (Array.isArray(clientManifest.async)) {
        meta.resourceHints += clientManifest.async
          .filter(file => shouldPrefetch(file))
          .map(r => `<link rel="prefetch" href="${publicPath}${r}" />`)
          .join('');
      }

      // Add them to HEAD
      if (meta.resourceHints) {
        meta.HEAD += meta.resourceHints;
      }
    }

    // Emulate getPreloadFiles from vue-server-renderer (works for JS chunks only)
    meta.getPreloadFiles = () =>
      clientManifest.initial
        .filter(file => shouldPreload(file))
        .map(r => ({
          file: r,
          fileWithoutQuery: r,
          asType: 'script',
          extension: 'js'
        }));

    // Set meta tags inside cache
    this.cache.set(url, meta);

    return meta
  }
}

function errorMiddleware(err, req, res, next) {
  // ensure statusCode, message and name fields
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Nuxt Server Error';
  err.name = !err.name || err.name === 'Error' ? 'NuxtServerError' : err.name;

  // We hide actual errors from end users, so show them on server logs
  if (err.statusCode !== 404) {
    consola.error(err);
  }

  const sendResponse = (content, type = 'text/html') => {
    // Set Headers
    res.statusCode = err.statusCode;
    res.statusMessage = err.name;
    res.setHeader('Content-Type', type + '; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(content));
    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');

    // Send Response
    res.end(content, 'utf-8');
  };

  // Check if request accepts JSON
  const hasReqHeader = (header, includes) =>
    req.headers[header] && req.headers[header].toLowerCase().includes(includes);
  const isJson =
    hasReqHeader('accept', 'application/json') ||
    hasReqHeader('user-agent', 'curl/');

  // Use basic errors when debug mode is disabled
  if (!this.options.debug) {
    // Json format is compatible with Youch json responses
    const json = {
      status: err.statusCode,
      message: err.message,
      name: err.name
    };
    if (isJson) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
      return
    }
    const html = this.resources.errorTemplate(json);
    sendResponse(html);
    return
  }

  // Show stack trace
  const youch = new Youch(
    err,
    req,
    readSource.bind(this),
    this.options.router.base,
    true
  );
  if (isJson) {
    youch.toJSON().then((json) => {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
    });
  } else {
    youch.toHTML().then(html => sendResponse(html));
  }
}

async function readSource(frame) {
  // Remove webpack:/// & query string from the end
  const sanitizeName = name =>
    name ? name.replace('webpack:///', '').split('?')[0] : null;
  frame.fileName = sanitizeName(frame.fileName);

  // Return if fileName is unknown
  /* istanbul ignore if */
  if (!frame.fileName) {
    return
  }

  // Possible paths for file
  const searchPath = [
    this.options.srcDir,
    this.options.rootDir,
    path__default.join(this.options.buildDir, 'dist', 'server'),
    this.options.buildDir,
    process.cwd()
  ];

  // Scan filesystem for real source
  for (const pathDir of searchPath) {
    const fullPath = path__default.resolve(pathDir, frame.fileName);
    const source = await fsExtra.readFile(fullPath, 'utf-8').catch(() => null);
    if (source) {
      frame.contents = source;
      frame.fullPath = fullPath;
      if (path__default.isAbsolute(frame.fileName)) {
        frame.fileName = path__default.relative(this.options.rootDir, fullPath);
      }
      return
    }
  }

  // Fallback: use server bundle
  // TODO: restore to if after https://github.com/istanbuljs/nyc/issues/595 fixed
  /* istanbul ignore next */
  if (!frame.contents) {
    frame.contents = this.resources.serverBundle.files[frame.fileName];
  }
}

async function nuxtMiddleware(req, res, next) {
  // Get context
  const context = getContext(req, res);

  res.statusCode = 200;
  try {
    const result = await this.renderRoute(req.url, context);
    await this.nuxt.callHook('render:route', req.url, result, context);
    const {
      html,
      cspScriptSrcHashSet,
      error,
      redirected,
      getPreloadFiles
    } = result;

    if (redirected) {
      this.nuxt.callHook('render:routeDone', req.url, result, context);
      return html
    }
    if (error) {
      res.statusCode = context.nuxt.error.statusCode || 500;
    }

    // Add ETag header
    if (!error && this.options.render.etag) {
      const etag = generateETag(html, this.options.render.etag);
      if (fresh(req.headers, { etag })) {
        res.statusCode = 304;
        res.end();
        this.nuxt.callHook('render:routeDone', req.url, result, context);
        return
      }
      res.setHeader('ETag', etag);
    }

    // HTTP2 push headers for preload assets
    if (!error && this.options.render.http2.push) {
      // Parse resourceHints to extract HTTP.2 prefetch/push headers
      // https://w3c.github.io/preload/#server-push-http-2
      const pushAssets = [];
      const preloadFiles = getPreloadFiles();
      const { shouldPush } = this.options.render.http2;
      const { publicPath } = this.resources.clientManifest;

      preloadFiles.forEach(({ file, asType, fileWithoutQuery }) => {
        // By default, we only preload scripts or css
        /* istanbul ignore if */
        if (!shouldPush && asType !== 'script' && asType !== 'style') {
          return
        }

        // User wants to explicitly control what to preload
        if (shouldPush && !shouldPush(fileWithoutQuery, asType)) {
          return
        }

        pushAssets.push(`<${publicPath}${file}>; rel=preload; as=${asType}`);
      });

      // Pass with single Link header
      // https://blog.cloudflare.com/http-2-server-push-with-multiple-assets-per-link-header
      // https://www.w3.org/Protocols/9707-link-header.html
      res.setHeader('Link', pushAssets.join(','));
    }

    if (this.options.render.csp) {
      const { allowedSources, policies } = this.options.render.csp;
      const cspHeader = this.options.render.csp.reportOnly ? 'Content-Security-Policy-Report-Only' : 'Content-Security-Policy';

      res.setHeader(cspHeader, getCspString({ cspScriptSrcHashSet, allowedSources, policies, isDev: this.options.dev }));
    }

    // Send response
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(html));
    res.end(html, 'utf8');
    this.nuxt.callHook('render:routeDone', req.url, result, context);
    return html
  } catch (err) {
    /* istanbul ignore if */
    if (context && context.redirected) {
      consola.error(err);
      return err
    }

    next(err);
  }
}

const getCspString = ({ cspScriptSrcHashSet, allowedSources, policies, isDev }) => {
  const joinedHashSet = Array.from(cspScriptSrcHashSet).join(' ');
  const baseCspStr = `script-src 'self'${isDev ? ` 'unsafe-eval'` : ''} ${joinedHashSet}`;

  if (Array.isArray(allowedSources)) {
    return `${baseCspStr} ${allowedSources.join(' ')}`
  }

  const policyObjectAvailable = typeof policies === 'object' && policies !== null && !Array.isArray(policies);

  if (policyObjectAvailable) {
    const transformedPolicyObject = transformPolicyObject(policies, cspScriptSrcHashSet);

    return Object.entries(transformedPolicyObject).map(([k, v]) => `${k} ${v.join(' ')}`).join('; ')
  }

  return baseCspStr
};

const transformPolicyObject = (policies, cspScriptSrcHashSet) => {
  const userHasDefinedScriptSrc = policies['script-src'] && Array.isArray(policies['script-src']);

  // Self is always needed for inline-scripts, so add it, no matter if the user specified script-src himself.

  const hashAndPolicySet = cspScriptSrcHashSet;
  hashAndPolicySet.add(`'self'`);

  if (!userHasDefinedScriptSrc) {
    policies['script-src'] = Array.from(hashAndPolicySet);
    return policies
  }

  new Set(policies['script-src']).forEach(src => hashAndPolicySet.add(src));

  policies['script-src'] = Array.from(hashAndPolicySet);

  return policies
};

let jsdom = null;

class Renderer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.globals = determineGlobals(nuxt.options.globalName, nuxt.options.globals);

    // Will be set by createRenderer
    this.bundleRenderer = null;
    this.metaRenderer = null;

    // Will be available on dev
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;

    // Create new connect instance
    this.app = connect();

    // Renderer runtime resources
    this.resources = {
      clientManifest: null,
      serverBundle: null,
      ssrTemplate: null,
      spaTemplate: null,
      errorTemplate: parseTemplate('Nuxt.js Internal Server Error')
    };
  }

  async ready() {
    await this.nuxt.callHook('render:before', this, this.options.render);
    // Setup nuxt middleware
    await this.setupMiddleware();

    // Production: Load SSR resources from fs
    if (!this.options.dev) {
      await this.loadResources();
    }

    // Call done hook
    await this.nuxt.callHook('render:done', this);
  }

  async loadResources(_fs = fsExtra) {
    const distPath = path__default.resolve(this.options.buildDir, 'dist', 'server');
    const updated = [];

    resourceMap.forEach(({ key, fileName, transform }) => {
      const rawKey = '$$' + key;
      const _path = path__default.join(distPath, fileName);

      if (!_fs.existsSync(_path)) {
        return // Resource not exists
      }
      const rawData = _fs.readFileSync(_path, 'utf8');
      if (!rawData || rawData === this.resources[rawKey]) {
        return // No changes
      }
      this.resources[rawKey] = rawData;
      const data = transform(rawData);
      /* istanbul ignore if */
      if (!data) {
        return // Invalid data ?
      }
      this.resources[key] = data;
      updated.push(key);
    });

    // Reload error template
    const errorTemplatePath = path__default.resolve(this.options.buildDir, 'views/error.html');
    if (fsExtra.existsSync(errorTemplatePath)) {
      this.resources.errorTemplate = parseTemplate(
        fsExtra.readFileSync(errorTemplatePath, 'utf8')
      );
    }

    // Load loading template
    const loadingHTMLPath = path__default.resolve(this.options.buildDir, 'loading.html');
    if (fsExtra.existsSync(loadingHTMLPath)) {
      this.resources.loadingHTML = fsExtra.readFileSync(loadingHTMLPath, 'utf8');
      this.resources.loadingHTML = this.resources.loadingHTML
        .replace(/\r|\n|[\t\s]{3,}/g, '');
    } else {
      this.resources.loadingHTML = '';
    }

    // Call resourcesLoaded plugin
    await this.nuxt.callHook('render:resourcesLoaded', this.resources);

    if (updated.length > 0) {
      this.createRenderer();
    }
  }

  get noSSR() {
    return this.options.render.ssr === false
  }

  get isReady() {
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    return Boolean(this.bundleRenderer && this.resources.ssrTemplate)
  }

  get isResourcesAvailable() {
    // Required for both
    /* istanbul ignore if */
    if (!this.resources.clientManifest) {
      return false
    }

    // Required for SPA rendering
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    // Required for bundle renderer
    return Boolean(this.resources.ssrTemplate && this.resources.serverBundle)
  }

  createRenderer() {
    // Ensure resources are available
    if (!this.isResourcesAvailable) {
      return
    }

    // Create Meta Renderer
    this.metaRenderer = new MetaRenderer(this.nuxt, this);

    // Skip following steps if noSSR mode
    if (this.noSSR) {
      return
    }

    const hasModules = fsExtra.existsSync(path__default.resolve(this.options.rootDir, 'node_modules'));
    // Create bundle renderer for SSR
    this.bundleRenderer = vueServerRenderer.createBundleRenderer(
      this.resources.serverBundle,
      Object.assign(
        {
          clientManifest: this.resources.clientManifest,
          runInNewContext: false,
          // for globally installed nuxt command, search dependencies in global dir
          basedir: hasModules ? this.options.rootDir : __dirname
        },
        this.options.render.bundleRenderer
      )
    );
  }

  useMiddleware(m) {
    // Resolve
    const $m = m;
    if (typeof m === 'string') {
      m = this.nuxt.requireModule(m);
    }
    if (typeof m.handler === 'string') {
      m.handler = this.nuxt.requireModule(m.handler);
    }

    const handler = m.handler || m;
    const path$$1 = (
      (m.prefix !== false ? this.options.router.base : '') +
      (typeof m.path === 'string' ? m.path : '')
    ).replace(/\/\//g, '/');

    handler.$m = $m;

    // Use middleware
    this.app.use(path$$1, handler);
  }

  get publicPath() {
    return isUrl(this.options.build.publicPath)
      ? defaults.build.publicPath
      : this.options.build.publicPath
  }

  async setupMiddleware() {
    // Apply setupMiddleware from modules first
    await this.nuxt.callHook('render:setupMiddleware', this.app);

    // Compression middleware for production
    if (!this.options.dev) {
      const compressor = this.options.render.compressor;
      if (typeof compressor === 'object') {
        // If only setting for `compression` are provided, require the module and insert
        // Prefer require instead of requireModule to keep dependency in nuxt-start
        const compression = require('compression');
        this.useMiddleware(compression(compressor));
      } else {
        // Else, require own compression middleware
        this.useMiddleware(compressor);
      }
    }

    // Add webpack middleware only for development
    if (this.options.dev) {
      this.useMiddleware(async (req, res, next) => {
        if (this.webpackDevMiddleware) {
          await this.webpackDevMiddleware(req, res);
        }
        if (this.webpackHotMiddleware) {
          await this.webpackHotMiddleware(req, res);
        }
        next();
      });
    }

    // open in editor for debug mode only
    if (this.options.debug && this.options.dev) {
      this.useMiddleware({
        path: '__open-in-editor',
        handler: launchMiddleware(this.options.editor)
      });
    }

    // For serving static/ files to /
    const staticMiddleware = serveStatic(
      path__default.resolve(this.options.srcDir, this.options.dir.static),
      this.options.render.static
    );
    staticMiddleware.prefix = this.options.render.static.prefix;
    this.useMiddleware(staticMiddleware);

    // Serve .nuxt/dist/ files only for production
    // For dev they will be served with devMiddleware
    if (!this.options.dev) {
      const distDir = path__default.resolve(this.options.buildDir, 'dist', 'client');
      this.useMiddleware({
        path: this.publicPath,
        handler: serveStatic(
          distDir,
          this.options.render.dist
        )
      });
    }

    // Add User provided middleware
    this.options.serverMiddleware.forEach((m) => {
      this.useMiddleware(m);
    });

    // Finally use nuxtMiddleware
    this.useMiddleware(nuxtMiddleware.bind(this));

    // Error middleware for errors that occurred in middleware that declared above
    // Middleware should exactly take 4 arguments
    // https://github.com/senchalabs/connect#error-middleware

    // Apply errorMiddleware from modules first
    await this.nuxt.callHook('render:errorMiddleware', this.app);

    // Apply errorMiddleware from Nuxt
    this.useMiddleware(errorMiddleware.bind(this));
  }

  renderTemplate(ssr, opts) {
    // Fix problem with HTMLPlugin's minify option (#3392)
    opts.html_attrs = opts.HTML_ATTRS;
    opts.body_attrs = opts.BODY_ATTRS;

    const fn = ssr ? this.resources.ssrTemplate : this.resources.spaTemplate;

    return fn(opts)
  }

  async renderRoute(url, context = {}) {
    /* istanbul ignore if */
    if (!this.isReady) {
      await waitFor(1000);
      return this.renderRoute(url, context)
    }

    // Log rendered url
    consola.debug(`Rendering url ${url}`);

    // Add url and isSever to the context
    context.url = url;

    // Basic response if SSR is disabled or spa data provided
    const spa = context.spa || (context.res && context.res.spa);
    const ENV = this.options.env;

    if (this.noSSR || spa) {
      const {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        BODY_SCRIPTS,
        getPreloadFiles
      } = await this.metaRenderer.render(context);
      const APP =
        `<div id="${this.globals.id}">${this.resources.loadingHTML}</div>` + BODY_SCRIPTS;

      // Detect 404 errors
      if (
        url.includes(this.options.build.publicPath) ||
        url.includes('__webpack')
      ) {
        const err = {
          statusCode: 404,
          message: this.options.messages.error_404,
          name: 'ResourceNotFound'
        };
        throw err
      }

      const html = this.renderTemplate(false, {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        APP,
        ENV
      });

      return { html, getPreloadFiles }
    }

    // Call renderToString from the bundleRenderer and generate the HTML (will update the context as well)
    let APP = await this.bundleRenderer.renderToString(context);

    if (!context.nuxt.serverRendered) {
      APP = `<div id="${this.globals.id}"></div>`;
    }
    const m = context.meta.inject();
    let HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();
    if (this.options._routerBaseSpecified) {
      HEAD += `<base href="${this.options.router.base}">`;
    }

    if (this.options.render.resourceHints) {
      HEAD += context.renderResourceHints();
    }

    await this.nuxt.callHook('render:routeContext', context.nuxt);

    const serializedSession = `window.${this.globals.context}=${devalue(context.nuxt)};`;

    const cspScriptSrcHashSet = new Set();
    if (this.options.render.csp) {
      const { hashAlgorithm } = this.options.render.csp;
      const hash$$1 = crypto.createHash(hashAlgorithm);
      hash$$1.update(serializedSession);
      cspScriptSrcHashSet.add(`'${hashAlgorithm}-${hash$$1.digest('base64')}'`);
    }

    APP += `<script>${serializedSession}</script>`;
    APP += context.renderScripts();
    APP += m.script.text({ body: true });
    APP += m.noscript.text({ body: true });

    HEAD += context.renderStyles();

    const html = this.renderTemplate(true, {
      HTML_ATTRS: 'data-n-head-ssr ' + m.htmlAttrs.text(),
      BODY_ATTRS: m.bodyAttrs.text(),
      HEAD,
      APP,
      ENV
    });

    return {
      html,
      cspScriptSrcHashSet,
      getPreloadFiles: context.getPreloadFiles,
      error: context.nuxt.error,
      redirected: context.redirected
    }
  }

  async renderAndGetWindow(url, opts = {}) {
    /* istanbul ignore if */
    if (!jsdom) {
      try {
        jsdom = require('jsdom');
      } catch (e) /* istanbul ignore next */ {
        consola.error(`
         Fail when calling nuxt.renderAndGetWindow(url)
         jsdom module is not installed
         Please install jsdom with: npm install --save-dev jsdom
        `);
        throw e
      }
    }
    const options = Object.assign({
      resources: 'usable', // load subresources (https://github.com/tmpvar/jsdom#loading-subresources)
      runScripts: 'dangerously',
      virtualConsole: true,
      beforeParse(window) {
        // Mock window.scrollTo
        window.scrollTo = () => {};
      }
    }, opts);
    const jsdomErrHandler = (err) => { throw err };
    if (options.virtualConsole) {
      if (options.virtualConsole === true) {
        options.virtualConsole = new jsdom.VirtualConsole().sendTo(consola);
      }
      // throw error when window creation failed
      options.virtualConsole.on('jsdomError', jsdomErrHandler);
    }
    url = url || 'http://localhost:3000';
    const { window } = await jsdom.JSDOM.fromURL(url, options);
    // If Nuxt could not be loaded (error from the server-side)
    const nuxtExists = window.document.body.innerHTML.includes(
      this.options.render.ssr ? `window.${this.globals.context}` : `<div id="${this.globals.id}">`
    );
    /* istanbul ignore if */
    if (!nuxtExists) {
      const error = new Error('Could not load the nuxt app');
      error.body = window.document.body.innerHTML;
      throw error
    }
    // Used by nuxt.js to say when the components are loaded and the app ready
    const onNuxtLoaded = this.globals.loadedCallback;
    await timeout(new Promise((resolve) => {
      window[onNuxtLoaded] = () => resolve(window);
    }), 20000, 'Components loading in renderAndGetWindow was not completed in 20s');
    if (options.virtualConsole) {
      // after window initialized successfully
      options.virtualConsole.removeListener('jsdomError', jsdomErrHandler);
    }
    // Send back window object
    return window
  }
}

const parseTemplate = templateStr =>
  ___default.template(templateStr, {
    interpolate: /{{([\s\S]+?)}}/g
  });

const resourceMap = [
  {
    key: 'clientManifest',
    fileName: 'vue-ssr-client-manifest.json',
    transform: JSON.parse
  },
  {
    key: 'serverBundle',
    fileName: 'server-bundle.json',
    transform: JSON.parse
  },
  {
    key: 'ssrTemplate',
    fileName: 'index.ssr.html',
    transform: parseTemplate
  },
  {
    key: 'spaTemplate',
    fileName: 'index.spa.html',
    transform: parseTemplate
  }
];

class Nuxt {
  constructor(options = {}) {
    this.options = Options.from(options);

    this.readyMessage = null;
    this.initialized = false;

    // Hooks
    this._hooks = {};
    this.hook = this.hook.bind(this);

    // Create instance of core components
    this.moduleContainer = new ModuleContainer(this);
    this.renderer = new Renderer(this);

    // Backward compatibility
    this.render = this.renderer.app;
    this.renderRoute = this.renderer.renderRoute.bind(this.renderer);
    this.renderAndGetWindow = this.renderer.renderAndGetWindow.bind(
      this.renderer
    );
    this.resolvePath = this.resolvePath.bind(this);
    this.resolveAlias = this.resolveAlias.bind(this);

    // ESM Loader
    this.esm = esm(module, {});

    this._ready = this.ready().catch((err) => {
      consola.fatal(err);
    });
  }

  static get version() {
    return packageJSON.version
  }

  async ready() {
    if (this._ready) {
      return this._ready
    }

    // Add hooks
    if (___default.isPlainObject(this.options.hooks)) {
      this.addHooks(this.options.hooks);
    } else if (typeof this.options.hooks === 'function') {
      this.options.hooks(this.hook);
    }

    // Await for modules
    await this.moduleContainer.ready();

    // Await for renderer to be ready
    await this.renderer.ready();

    this.initialized = true;

    // Call ready hook
    await this.callHook('ready', this);

    return this
  }

  hook(name$$1, fn) {
    if (!name$$1 || typeof fn !== 'function') {
      return
    }
    if (name$$1 === 'render:context') {
      name$$1 = 'render:routeContext';
      consola.warn('render:context hook has been deprecated, please use render:routeContext');
    }
    this._hooks[name$$1] = this._hooks[name$$1] || [];
    this._hooks[name$$1].push(fn);
  }

  async callHook(name$$1, ...args) {
    if (!this._hooks[name$$1]) {
      return
    }
    consola.debug(`Call ${name$$1} hooks (${this._hooks[name$$1].length})`);
    try {
      await sequence(this._hooks[name$$1], fn => fn(...args));
    } catch (err) {
      consola.error(err);
      this.callHook('error', err);
    }
  }

  clearHook(name$$1) {
    if (name$$1) {
      delete this._hooks[name$$1];
    }
  }

  flatHooks(configHooks, hooks = {}, parentName) {
    Object.keys(configHooks).forEach((key) => {
      const subHook = configHooks[key];
      const name$$1 = parentName ? `${parentName}:${key}` : key;
      if (typeof subHook === 'object' && subHook !== null) {
        this.flatHooks(subHook, hooks, name$$1);
      } else {
        hooks[name$$1] = subHook;
      }
    });
    return hooks
  }

  addHooks(configHooks) {
    const hooks = this.flatHooks(configHooks);
    Object.keys(hooks).filter(Boolean).forEach((key) => {
      [].concat(hooks[key]).forEach(h => this.hook(key, h));
    });
  }

  showReady(clear = true) {
    if (!this.readyMessage) {
      return
    }
    consola.ready({
      message: this.readyMessage,
      badge: true,
      clear
    });
    this.readyMessage = null;
  }

  listen(port, host, socket) {
    return this.ready().then(() => new Promise((resolve, reject) => {
      if (!socket && typeof this.options.server.socket === 'string') {
        socket = this.options.server.socket;
      }

      const args = { exclusive: false };

      if (socket) {
        args.path = socket;
      } else {
        args.port = port || this.options.server.port;
        args.host = host || this.options.server.host;
      }

      let appServer;
      const isHttps = Boolean(this.options.server.https);

      if (isHttps) {
        let httpsOptions;

        if (this.options.server.https === true) {
          httpsOptions = {};
        } else {
          httpsOptions = this.options.server.https;
        }

        appServer = https.createServer(httpsOptions, this.renderer.app);
      } else {
        appServer = this.renderer.app;
      }

      const server = appServer.listen(
        args,
        (err) => {
          /* istanbul ignore if */
          if (err) {
            return reject(err)
          }

          let listenURL;

          if (!socket) {
            ({ address: host, port } = server.address());
            if (host === '127.0.0.1') {
              host = 'localhost';
            } else if (host === '0.0.0.0') {
              host = ip.address();
            }

            listenURL = Chalk.underline.blue(`http${isHttps ? 's' : ''}://${host}:${port}`);
            this.readyMessage = `Listening on ${listenURL}`;
          } else {
            listenURL = Chalk.underline.blue(`unix+http://${socket}`);
            this.readyMessage = `Listening on ${listenURL}`;
          }

          // Close server on nuxt close
          this.hook(
            'close',
            () =>
              new Promise((resolve, reject) => {
                // Destroy server by forcing every connection to be closed
                server.listening && server.destroy((err) => {
                  consola.debug('server closed');
                  /* istanbul ignore if */
                  if (err) {
                    return reject(err)
                  }
                  resolve();
                });
              })
          );

          if (socket) {
            this.callHook('listen', server, { path: socket }).then(resolve);
          } else {
            this.callHook('listen', server, { port, host }).then(resolve);
          }
        }
      );

      // Add server.destroy(cb) method
      enableDestroy(server);
    }))
  }

  resolveModule(path$$1) {
    try {
      const resolvedPath = Module._resolveFilename(path$$1, {
        paths: this.options.modulesDir
      });

      return resolvedPath
    } catch (error) {
      if (error.code === 'MODULE_NOT_FOUND') {
        return null
      } else {
        throw error
      }
    }
  }

  resolveAlias(path$$1) {
    const modulePath = this.resolveModule(path$$1);

    // Try to resolve it as if it were a regular node_module
    // Package first. Fixes issue with @<org> scoped packages
    if (modulePath != null) {
      return modulePath
    }

    if (startsWithRootAlias(path$$1)) {
      return path.join(this.options.rootDir, path$$1.substr(2))
    }

    if (startsWithSrcAlias(path$$1)) {
      return path.join(this.options.srcDir, path$$1.substr(1))
    }

    return path.resolve(this.options.srcDir, path$$1)
  }

  resolvePath(path$$1) {
    const _path = this.resolveAlias(path$$1);

    if (fsExtra.existsSync(_path)) {
      return _path
    }

    for (const ext of this.options.extensions) {
      if (fsExtra.existsSync(_path + '.' + ext)) {
        return _path + '.' + ext
      }
    }

    throw new Error(`Cannot resolve "${path$$1}" from "${_path}"`)
  }

  requireModule(_path, opts = {}) {
    const _resolvedPath = this.resolvePath(_path);
    const m = opts.esm === false ? require(_resolvedPath) : this.esm(_resolvedPath);
    return (m && m.default) || m
  }

  async close(callback) {
    await this.callHook('close', this);

    /* istanbul ignore if */
    if (typeof callback === 'function') {
      await callback();
    }
  }
}

var core = {
  Nuxt,
  Module: ModuleContainer,
  Renderer
};

// https://github.com/webpack-contrib/thread-loader
// https://github.com/webpack-contrib/cache-loader

class PerfLoader {
  constructor(options) {
    this.options = options;
    this.warmup = threadLoader.warmup;
    this.workerPools = {
      js: {
        name: 'js',
        poolTimeout: this.options.dev ? Infinity : 2000
      },
      css: {
        name: 'css',
        poolTimeout: this.options.dev ? Infinity : 2000
      }
    };
  }

  warmupAll() {
    this.warmup(this.workerPools.js, ['babel-loader', '@babel/preset-env']);
    this.warmup(this.workerPools.css, ['css-loader']);
  }

  pool(poolName, _loaders) {
    const loaders = [].concat(_loaders);

    if (this.options.build.parallel) {
      const pool = this.workerPools[poolName];

      if (pool) {
        loaders.unshift({
          loader: 'thread-loader',
          options: pool
        });
      }
    }

    if (this.options.build.cache) {
      loaders.unshift({
        loader: 'cache-loader',
        options: {
          cacheDirectory: path__default.resolve('node_modules/.cache/cache-loader')
        }
      });
    }

    return loaders
  }

  poolOneOf(poolName, oneOfRules) {
    return oneOfRules.map(rule => Object.assign({}, rule, {
      use: this.pool(poolName, rule.use)
    }))
  }
}

const prefix = `[vue-server-renderer-webpack-plugin]`;
const warn = msg => console.error(Chalk.red(`${prefix} ${msg}\n`)); // eslint-disable-line no-console
const tip = msg => console.log(Chalk.yellow(`${prefix} ${msg}\n`)); // eslint-disable-line no-console

const validate = (compiler) => {
  if (compiler.options.target !== 'node') {
    warn('webpack config `target` should be "node".');
  }

  if (compiler.options.output && compiler.options.output.libraryTarget !== 'commonjs2') {
    warn('webpack config `output.libraryTarget` should be "commonjs2".');
  }

  if (!compiler.options.externals) {
    tip(
      'It is recommended to externalize dependencies in the server build for ' +
      'better build performance.'
    );
  }
};

const onEmit = (compiler, name, hook) => {
  if (compiler.hooks) {
    // Webpack >= 4.0.0
    compiler.hooks.emit.tapAsync(name, hook);
  } else {
    // Webpack < 4.0.0
    compiler.plugin('emit', hook);
  }
};

const isJS = file => /\.js(\?[^.]+)?$/.test(file);

const isCSS = file => /\.css(\?[^.]+)?$/.test(file);

class VueSSRClientPlugin {
  constructor(options = {}) {
    this.options = Object.assign({
      filename: 'vue-ssr-client-manifest.json'
    }, options);
  }

  apply(compiler) {
    onEmit(compiler, 'vue-client-plugin', (compilation, cb) => {
      const stats = compilation.getStats().toJson();

      const allFiles = _.uniq(stats.assets
        .map(a => a.name));

      const initialFiles = _.uniq(Object.keys(stats.entrypoints)
        .map(name => stats.entrypoints[name].assets)
        .reduce((assets, all) => all.concat(assets), [])
        .filter(file => isJS(file) || isCSS(file)));

      const asyncFiles = allFiles
        .filter(file => isJS(file) || isCSS(file))
        .filter(file => !initialFiles.includes(file));

      const manifest = {
        publicPath: stats.publicPath,
        all: allFiles,
        initial: initialFiles,
        async: asyncFiles,
        modules: { /* [identifier: string]: Array<index: number> */ }
      };

      const assetModules = stats.modules.filter(m => m.assets.length);
      const fileToIndex = file => manifest.all.indexOf(file);
      stats.modules.forEach((m) => {
        // ignore modules duplicated in multiple chunks
        if (m.chunks.length === 1) {
          const cid = m.chunks[0];
          const chunk = stats.chunks.find(c => c.id === cid);
          if (!chunk || !chunk.files) {
            return
          }
          const id = m.identifier.replace(/\s\w+$/, ''); // remove appended hash
          const files = manifest.modules[hash(id)] = chunk.files.map(fileToIndex);
          // find all asset modules associated with the same chunk
          assetModules.forEach((m) => {
            if (m.chunks.some(id => id === cid)) {
              files.push.apply(files, m.assets.map(fileToIndex));
            }
          });
        }
      });

      // const debug = (file, obj) => {
      //   require('fs').writeFileSync(__dirname + '/' + file, JSON.stringify(obj, null, 2))
      // }
      // debug('stats.json', stats)
      // debug('client-manifest.json', manifest)

      const json = JSON.stringify(manifest, null, 2);
      compilation.assets[this.options.filename] = {
        source: () => json,
        size: () => json.length
      };
      cb();
    });
  }
}

class PostcssConfig {
  constructor(options, nuxt) {
    this.nuxt = nuxt;
    this.dev = options.dev;
    this.postcss = options.build.postcss;
    this.srcDir = options.srcDir;
    this.rootDir = options.rootDir;
    this.cssSourceMap = options.build.cssSourceMap;
    this.modulesDir = options.modulesDir;
  }

  get defaultConfig() {
    return {
      sourceMap: this.cssSourceMap,
      plugins: {
        // https://github.com/postcss/postcss-import
        'postcss-import': {
          resolve: createResolver({
            alias: {
              '~': path__default.join(this.srcDir),
              '~~': path__default.join(this.rootDir),
              '@': path__default.join(this.srcDir),
              '@@': path__default.join(this.rootDir)
            },
            modules: [
              this.srcDir,
              this.rootDir,
              ...this.modulesDir
            ]
          })
        },

        // https://github.com/postcss/postcss-url
        'postcss-url': {},

        // https://github.com/csstools/postcss-preset-env
        'postcss-preset-env': this.preset || {},
        'cssnano': this.dev ? false : { preset: 'default' }
      }
    }
  }

  searchConfigFile() {
    // Search for postCSS config file and use it if exists
    // https://github.com/michael-ciniawsky/postcss-load-config
    for (const dir of [this.srcDir, this.rootDir]) {
      for (const file of [
        'postcss.config.js',
        '.postcssrc.js',
        '.postcssrc',
        '.postcssrc.json',
        '.postcssrc.yaml'
      ]) {
        const configFile = path__default.resolve(dir, file);
        if (fs.existsSync(configFile)) {
          return configFile
        }
      }
    }
  }

  configFromFile() {
    const loaderConfig = (this.postcss && this.postcss.config) || {};
    loaderConfig.path = loaderConfig.path || this.searchConfigFile();

    if (loaderConfig.path) {
      return {
        sourceMap: this.cssSourceMap,
        config: loaderConfig
      }
    }
  }

  normalize(config) {
    if (Array.isArray(config)) {
      config = { plugins: config };
    }
    return config
  }

  loadPlugins(config) {
    const plugins = config.plugins;
    if (isPureObject(plugins)) {
      // Map postcss plugins into instances on object mode once
      config.plugins = Object.keys(plugins)
        .map((p) => {
          const plugin = require(p);
          const opts = plugins[p];
          if (opts === false) return // Disabled
          const instance = plugin(opts);
          return instance
        })
        .filter(e => e);
    }
  }

  config() {
    /* istanbul ignore if */
    if (!this.postcss) {
      return false
    }

    let config = this.configFromFile();
    if (config) {
      return config
    }

    config = this.normalize(___default.cloneDeep(this.postcss));

    // Apply default plugins
    if (isPureObject(config)) {
      if (config.preset) {
        this.preset = config.preset;
        delete config.preset;
      }
      if (Array.isArray(config.plugins)) {
        ___default.defaults(config, this.defaultConfig);
      } else {
        // Keep the order of default plugins
        config = ___default.merge({}, this.defaultConfig, config);
        this.loadPlugins(config);
      }
      return config
    }
  }
}

class StyleLoader {
  constructor(options, nuxt, { isServer }) {
    this.isServer = isServer;
    this.dev = options.dev;
    this.srcDir = options.srcDir;
    this.assetsDir = options.dir.assets;
    this.staticDir = options.dir.static;
    this.loaders = options.build.loaders;
    this.extractCSS = options.build.extractCSS;
    this.resources = options.build.styleResources;
    this.sourceMap = Boolean(options.build.cssSourceMap);

    if (options.build.postcss) {
      this.postcssConfig = new PostcssConfig(options, nuxt);
    }
  }

  normalize(loaders) {
    loaders = wrapArray(loaders);
    return loaders.map(loader => (typeof loader === 'string' ? { loader } : loader))
  }

  styleResource(ext) {
    const extResource = this.resources[ext];
    // style-resources-loader
    // https://github.com/yenshih/style-resources-loader
    if (extResource) {
      const patterns = wrapArray(extResource);

      return {
        loader: 'style-resources-loader',
        options: Object.assign(
          { patterns },
          this.resources.options || {}
        )
      }
    }
  }

  postcss() {
    // postcss-loader
    // https://github.com/postcss/postcss-loader
    if (this.postcssConfig) {
      const config = this.postcssConfig.config();
      if (config) {
        return {
          loader: 'postcss-loader',
          options: Object.assign({ sourceMap: this.sourceMap }, config)
        }
      }
    }
  }

  css(options) {
    return {
      loader: (this.isServer && this.extractCSS) ? 'css-loader/locals' : 'css-loader',
      options
    }
  }

  cssModules(options) {
    options.modules = true;
    return {
      loader: 'css-loader',
      options
    }
  }

  extract() {
    if (this.extractCSS && !this.isServer) {
      return MiniCssExtractPlugin.loader
    }
  }

  vueStyle() {
    // https://github.com/vuejs/vue-style-loader
    return {
      loader: 'vue-style-loader',
      options: this.loaders.vueStyle
    }
  }

  apply(ext, loaders = []) {
    const customLoaders = [].concat(
      this.postcss(loaders),
      this.normalize(loaders),
      this.styleResource(ext)
    ).filter(Boolean);

    const { css: cssOptions, cssModules: cssModulesOptions } = this.loaders;
    cssOptions.importLoaders = cssModulesOptions.importLoaders = customLoaders.length;

    const styleLoader = this.extract() || this.vueStyle();

    return [
      // This matches <style module>
      {
        resourceQuery: /module/,
        use: [].concat(
          styleLoader,
          this.cssModules(cssModulesOptions),
          customLoaders
        )
      },
      // This matches plain <style> or <style scoped>
      {
        use: [].concat(
          styleLoader,
          this.css(cssOptions),
          customLoaders
        )
      }
    ]
  }
}

class WarnFixPlugin {
  apply(compiler) /* istanbul ignore next */ {
    compiler.hooks.done.tap('warnfix-plugin', (stats) => {
      stats.compilation.warnings = stats.compilation.warnings.filter((warn) => {
        if (
          warn.name === 'ModuleDependencyWarning' &&
          warn.message.includes(`export 'default'`) &&
          warn.message.includes('nuxt_plugin_')
        ) {
          return false
        }
        return true
      });
    });
  }
}

class StatsPlugin {
  constructor(statsOptions) {
    this.statsOptions = statsOptions;
  }

  apply(compiler) {
    compiler.hooks.done.tap('stats-plugin', (stats) => {
      process.stdout.write(
        '\n' +
          stats.toString(this.statsOptions) +
          '\n'
      );
    });
  }
}

class WebpackBaseConfig {
  constructor(builder, options) {
    this.name = options.name;
    this.isServer = options.isServer;
    this.builder = builder;
    this.nuxt = this.builder.nuxt;
    this.isStatic = builder.isStatic;
    this.options = builder.options;
    this.spinner = builder.spinner;
    this.loaders = this.options.build.loaders;
  }

  get nuxtEnv() {
    return {
      isDev: this.options.dev,
      isServer: this.isServer,
      isClient: !this.isServer
    }
  }

  getBabelOptions() {
    const options = ___default.clone(this.options.build.babel);

    if (typeof options.presets === 'function') {
      options.presets = options.presets({ isServer: this.isServer });
    }

    if (!options.babelrc && !options.presets) {
      options.presets = [
        [
          require.resolve('@nuxtjs/babel-preset-app'),
          {
            buildTarget: this.isServer ? 'server' : 'client'
          }
        ]
      ];
    }

    return options
  }

  getFileName(key) {
    let fileName = this.options.build.filenames[key];
    if (typeof fileName === 'function') {
      fileName = fileName(this.nuxtEnv);
    }
    if (this.options.dev) {
      const hash$$1 = /\[(chunkhash|contenthash|hash)(?::(\d+))?\]/.exec(fileName);
      if (hash$$1) {
        consola.warn(`Notice: Please do not use ${hash$$1[1]} in dev mode to prevent memory leak`);
      }
    }
    return fileName
  }

  devtool() {
    return false
  }

  env() {
    const env$$1 = {
      'process.mode': JSON.stringify(this.options.mode),
      'process.static': this.isStatic
    };
    Object.entries(this.options.env).forEach(([key, value]) => {
      env$$1['process.env.' + key] =
        ['boolean', 'number'].includes(typeof value)
          ? value
          : JSON.stringify(value);
    });
    return env$$1
  }

  output() {
    return {
      path: path__default.resolve(this.options.buildDir, 'dist', this.isServer ? 'server' : 'client'),
      filename: this.getFileName('app'),
      chunkFilename: this.getFileName('chunk'),
      publicPath: isUrl(this.options.build.publicPath)
        ? this.options.build.publicPath
        : urlJoin(this.options.router.base, this.options.build.publicPath)
    }
  }

  optimization() {
    return this.options.build.optimization
  }

  alias() {
    const { srcDir, rootDir, dir: { assets: assetsDir, static: staticDir } } = this.options;

    return {
      '~': path__default.join(srcDir),
      '~~': path__default.join(rootDir),
      '@': path__default.join(srcDir),
      '@@': path__default.join(rootDir),
      [assetsDir]: path__default.join(srcDir, assetsDir),
      [staticDir]: path__default.join(srcDir, staticDir)
    }
  }

  rules() {
    const styleLoader = new StyleLoader(
      this.options,
      this.builder.nuxt,
      { isServer: this.isServer }
    );

    const perfLoader = this.builder.perfLoader;

    return [
      {
        test: /\.vue$/,
        loader: 'vue-loader',
        options: this.loaders.vue
      },
      {
        test: /\.pug$/,
        oneOf: [
          {
            resourceQuery: /^\?vue/,
            use: [{
              loader: 'pug-plain-loader',
              options: this.loaders.pugPlain
            }]
          },
          {
            use: [
              'raw-loader',
              {
                loader: 'pug-plain-loader',
                options: this.loaders.pugPlain
              }
            ]
          }
        ]
      },
      {
        test: /\.jsx?$/,
        exclude: (file) => {
          // not exclude files outside node_modules
          if (!/node_modules/.test(file)) {
            return false
          }

          // item in transpile can be string or regex object
          const modulesToTranspile = [/\.vue\.js/].concat(this.options.build.transpile);

          return !modulesToTranspile.some(module => module.test(file))
        },
        use: perfLoader.pool('js', {
          loader: 'babel-loader',
          options: this.getBabelOptions()
        })
      },
      {
        test: /\.css$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('css'))
      },
      {
        test: /\.less$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('less', {
          loader: 'less-loader',
          options: this.loaders.less
        }))
      },
      {
        test: /\.sass$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('sass', {
          loader: 'sass-loader',
          options: this.loaders.sass
        }))
      },
      {
        test: /\.scss$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('scss', {
          loader: 'sass-loader',
          options: this.loaders.scss
        }))
      },
      {
        test: /\.styl(us)?$/,
        oneOf: perfLoader.poolOneOf('css', styleLoader.apply('stylus', {
          loader: 'stylus-loader',
          options: this.loaders.stylus
        }))
      },
      {
        test: /\.(png|jpe?g|gif|svg|webp)$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: Object.assign(
            this.loaders.imgUrl,
            { name: this.getFileName('img') }
          )
        })
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        use: perfLoader.pool('assets', {
          loader: 'url-loader',
          options: Object.assign(
            this.loaders.fontUrl,
            { name: this.getFileName('font') }
          )
        })
      },
      {
        test: /\.(webm|mp4|ogv)$/,
        use: perfLoader.pool('assets', {
          loader: 'file-loader',
          options: Object.assign(
            this.loaders.file,
            { name: this.getFileName('video') }
          )
        })
      }
    ]
  }

  plugins() {
    const plugins = [ new VueLoader.VueLoaderPlugin() ];

    Array.prototype.push.apply(plugins, this.options.build.plugins || []);

    // Add timefix-plugin before others plugins
    if (this.options.dev) {
      plugins.unshift(new TimeFixPlugin());
    }

    // Hide warnings about plugins without a default export (#1179)
    plugins.push(new WarnFixPlugin());

    // Build progress indicator
    plugins.push(new WebpackBar({
      profile: this.options.build.profile,
      name: this.isServer ? 'server' : 'client',
      color: this.isServer ? 'orange' : 'green',
      compiledIn: false,
      done: (states) => {
        if (this.options.dev) {
          const hasErrors = Object.values(states).some(state => state.stats.hasErrors());

          if (!hasErrors) {
            this.nuxt.showReady(false);
          }
        }
      }
    }));

    // Add stats plugin
    if (!this.options.dev && this.options.build.stats) {
      plugins.push(new StatsPlugin(this.options.build.stats));
    }

    // CSS extraction
    // MiniCssExtractPlugin does not currently supports SSR
    // https://github.com/webpack-contrib/mini-css-extract-plugin/issues/48
    // So we use css-loader/locals as a fallback (utils/style-loader)
    if (this.options.build.extractCSS && !this.isServer) {
      plugins.push(new MiniCssExtractPlugin(Object.assign({
        filename: this.getFileName('css'),
        chunkFilename: this.getFileName('css')
      }, this.options.build.extractCSS)));
    }

    return plugins
  }

  extendConfig(config) {
    if (typeof this.options.build.extend === 'function') {
      const extendedConfig = this.options.build.extend.call(
        this.builder, config, { loaders: this.loaders, ...this.nuxtEnv }
      );
      // Only overwrite config when something is returned for backwards compatibility
      if (extendedConfig !== undefined) {
        return extendedConfig
      }
    }
    return config
  }

  config() {
    // Prioritize nested node_modules in webpack search path (#2558)
    const webpackModulesDir = ['node_modules'].concat(this.options.modulesDir);
    const config = {
      name: this.name,
      mode: this.options.dev ? 'development' : 'production',
      devtool: this.devtool(),
      optimization: this.optimization(),
      output: this.output(),
      performance: {
        maxEntrypointSize: 1000 * 1024,
        hints: this.options.dev ? false : 'warning'
      },
      resolve: {
        extensions: ['.wasm', '.mjs', '.js', '.json', '.vue', '.jsx'],
        alias: this.alias(),
        modules: webpackModulesDir
      },
      resolveLoader: {
        modules: webpackModulesDir
      },
      module: {
        rules: this.rules()
      },
      plugins: this.plugins()
    };

    const extendedConfig = this.extendConfig(config);

    // Clone deep avoid leaking config between Client and Server
    return ___default.cloneDeep(extendedConfig)
  }
}

class WebpackClientConfig extends WebpackBaseConfig {
  constructor(builder) {
    super(builder, { name: 'client', isServer: false });
  }

  getFileName(...args) {
    if (this.options.build.analyze) {
      const key = args[0];
      if (['app', 'chunk'].includes(key)) {
        return '[name].js'
      }
    }
    return super.getFileName(...args)
  }

  env() {
    return Object.assign(super.env(), {
      'process.env.VUE_ENV': JSON.stringify('client'),
      'process.browser': true,
      'process.client': true,
      'process.server': false
    })
  }

  optimization() {
    const optimization = super.optimization();

    // Small, known and common modules which are usually used project-wise
    // Sum of them may not be more than 244 KiB
    if (
      this.options.build.splitChunks.commons === true &&
      optimization.splitChunks.cacheGroups.commons === undefined
    ) {
      optimization.splitChunks.cacheGroups.commons = {
        test: /node_modules[\\/](vue|vue-loader|vue-router|vuex|vue-meta|core-js|@babel\/runtime|axios|webpack|setimmediate|timers-browserify|process|regenerator-runtime|cookie|js-cookie|is-buffer|dotprop|nuxt\.js)[\\/]/,
        chunks: 'all',
        priority: 10,
        name: true
      };
    }

    return optimization
  }

  plugins() {
    const plugins = super.plugins();

    // Generate output HTML for SSR
    if (this.options.build.ssr) {
      plugins.push(
        new HTMLPlugin({
          filename: '../server/index.ssr.html',
          template: this.options.appTemplatePath,
          minify: this.options.build.html.minify,
          inject: false // Resources will be injected using bundleRenderer
        })
      );
    }

    plugins.push(
      new HTMLPlugin({
        filename: '../server/index.spa.html',
        template: this.options.appTemplatePath,
        minify: this.options.build.html.minify,
        inject: true,
        chunksSortMode: 'dependency'
      }),
      new VueSSRClientPlugin({
        filename: '../server/vue-ssr-client-manifest.json'
      }),
      new webpack.DefinePlugin(this.env())
    );

    if (this.options.dev) {
      // TODO: webpackHotUpdate is not defined: https://github.com/webpack/webpack/issues/6693
      plugins.push(new webpack.HotModuleReplacementPlugin());
    }

    // Webpack Bundle Analyzer
    // https://github.com/webpack-contrib/webpack-bundle-analyzer
    if (!this.options.dev && this.options.build.analyze) {
      const statsDir = path__default.resolve(this.options.buildDir, 'stats');

      plugins.push(new BundleAnalyzer.BundleAnalyzerPlugin(Object.assign({
        analyzerMode: 'static',
        defaultSizes: 'gzip',
        generateStatsFile: true,
        openAnalyzer: !this.options.build.quiet,
        reportFilename: path__default.resolve(statsDir, 'client.html'),
        statsFilename: path__default.resolve(statsDir, 'client.json')
      }, this.options.build.analyze)));
    }

    return plugins
  }

  extendConfig() {
    const config = super.extendConfig(...arguments);

    // Add minimizer plugins
    if (config.optimization.minimize && config.optimization.minimizer === undefined) {
      config.optimization.minimizer = [];

      // https://github.com/webpack-contrib/terser-webpack-plugin
      if (this.options.build.terser) {
        config.optimization.minimizer.push(
          new TerserWebpackPlugin(Object.assign({
            parallel: true,
            cache: this.options.build.cache,
            sourceMap: config.devtool && /source-?map/.test(config.devtool),
            extractComments: {
              filename: 'LICENSES'
            },
            terserOptions: {
              output: {
                comments: /^\**!|@preserve|@license|@cc_on/
              }
            }
          }, this.options.build.terser))
        );
      }

      // https://github.com/NMFR/optimize-css-assets-webpack-plugin
      // https://github.com/webpack-contrib/mini-css-extract-plugin#minimizing-for-production
      // TODO: Remove OptimizeCSSAssetsPlugin when upgrading to webpack 5
      if (this.options.build.optimizeCSS) {
        config.optimization.minimizer.push(
          new OptimizeCSSAssetsPlugin(Object.assign({}, this.options.build.optimizeCSS))
        );
      }
    }

    return config
  }

  config() {
    const config = super.config();

    // Entry points
    config.entry = {
      app: [path__default.resolve(this.options.buildDir, 'client.js')]
    };

    // Add HMR support
    if (this.options.dev) {
      config.entry.app.unshift(
        // https://github.com/glenjamin/webpack-hot-middleware#config
        `webpack-hot-middleware/client?name=client&reload=true&timeout=30000&path=${
          this.options.router.base
        }/__webpack_hmr`.replace(/\/\//g, '/')
      );
    }

    // Add friendly error plugin
    if (this.options.dev && !this.options.build.quiet) {
      config.plugins.push(
        new FriendlyErrorsWebpackPlugin({
          clearConsole: true,
          logLevel: 'WARNING'
        })
      );
    }

    return config
  }
}

class VueSSRServerPlugin {
  constructor(options = {}) {
    this.options = Object.assign({
      filename: 'vue-ssr-server-bundle.json'
    }, options);
  }

  apply(compiler) {
    validate(compiler);

    onEmit(compiler, 'vue-server-plugin', (compilation, cb) => {
      const stats = compilation.getStats().toJson();
      const entryName = Object.keys(stats.entrypoints)[0];
      const entryInfo = stats.entrypoints[entryName];

      if (!entryInfo) {
        // #5553
        return cb()
      }

      const entryAssets = entryInfo.assets.filter(isJS);

      if (entryAssets.length > 1) {
        throw new Error(
          `Server-side bundle should have one single entry file. ` +
          `Avoid using CommonsChunkPlugin in the server config.`
        )
      }

      const entry = entryAssets[0];
      if (!entry || typeof entry !== 'string') {
        throw new Error(
          `Entry "${entryName}" not found. Did you specify the correct entry option?`
        )
      }

      const bundle = {
        entry,
        files: {},
        maps: {}
      };

      stats.assets.forEach((asset) => {
        if (isJS(asset.name)) {
          bundle.files[asset.name] = compilation.assets[asset.name].source();
        } else if (asset.name.match(/\.js\.map$/)) {
          bundle.maps[asset.name.replace(/\.map$/, '')] = JSON.parse(compilation.assets[asset.name].source());
        }
        // do not emit anything else for server
        delete compilation.assets[asset.name];
      });

      const json = JSON.stringify(bundle, null, 2);
      const filename = this.options.filename;

      compilation.assets[filename] = {
        source: () => json,
        size: () => json.length
      };

      cb();
    });
  }
}

class WebpackServerConfig extends WebpackBaseConfig {
  constructor(builder) {
    super(builder, { name: 'server', isServer: true });
  }

  devtool() {
    return 'cheap-module-inline-source-map'
  }

  env() {
    return Object.assign(super.env(), {
      'process.env.VUE_ENV': JSON.stringify('server'),
      'process.browser': false,
      'process.client': false,
      'process.server': true
    })
  }

  optimization() {
    return {
      splitChunks: false,
      minimizer: []
    }
  }

  plugins() {
    const plugins = super.plugins();
    plugins.push(
      new VueSSRServerPlugin({
        filename: 'server-bundle.json'
      }),
      new webpack.DefinePlugin(this.env())
    );
    return plugins
  }

  config() {
    const config = super.config();

    Object.assign(config, {
      target: 'node',
      node: false,
      entry: {
        app: [path__default.resolve(this.options.buildDir, 'server.js')]
      },
      output: Object.assign({}, config.output, {
        filename: 'server-bundle.js',
        libraryTarget: 'commonjs2'
      }),
      performance: {
        hints: false,
        maxAssetSize: Infinity
      },
      externals: []
    });

    // https://webpack.js.org/configuration/externals/#externals
    // https://github.com/liady/webpack-node-externals
    // https://vue-loader.vuejs.org/migrating.html#ssr-externals
    this.options.modulesDir.forEach((dir) => {
      if (fs.existsSync(dir)) {
        config.externals.push(
          nodeExternals({
            whitelist: [
              /\.css$/,
              /\?vue&type=style/,
              ...this.options.build.transpile
            ],
            modulesDir: dir
          })
        );
      }
    });

    return config
  }
}

const glob = pify(Glob);

class Builder {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.isStatic = false; // Flag to know if the build is for a generated app
    this.options = nuxt.options;
    this.globals = determineGlobals(nuxt.options.globalName, nuxt.options.globals);

    // Fields that set on build
    this.compilers = [];
    this.compilersWatching = [];
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;
    this.watchers = {
      files: null,
      custom: null,
      restart: null
    };
    this.perfLoader = null;

    // Helper to resolve build paths
    this.relativeToBuild = (...args) =>
      relativeTo(this.options.buildDir, ...args);

    this._buildStatus = STATUS.INITIAL;

    // Stop watching on nuxt.close()
    if (this.options.dev) {
      this.nuxt.hook('close', () => this.unwatch());
    }

    // Initialize shared FS and Cache
    if (this.options.dev) {
      this.mfs = new MFS();
    }

    if (this.options.build.analyze) {
      this.nuxt.hook('build:done', () => {
        consola.warn({
          message: 'Notice: Please do not deploy bundles built with analyze mode, it\'s only for analyzing purpose.',
          badge: true
        });
      });
    }

    // if(!this.options.dev) {
    // TODO: enable again when unsafe concern resolved.(common/options.js:42)
    // this.nuxt.hook('build:done', () => this.generateConfig())
    // }
  }

  normalizePlugins() {
    return ___default.uniqBy(
      this.options.plugins.map((p) => {
        if (typeof p === 'string') p = { src: p };
        const pluginBaseName = path__default.basename(p.src, path__default.extname(p.src)).replace(
          /[^a-zA-Z?\d\s:]/g,
          ''
        );
        return {
          src: this.nuxt.resolveAlias(p.src),
          ssr: p.ssr !== false,
          name: 'nuxt_plugin_' + pluginBaseName + '_' + hash(p.src)
        }
      }),
      p => p.name
    )
  }

  forGenerate() {
    this.isStatic = true;
  }

  async build() {
    // Avoid calling build() method multiple times when dev:true
    /* istanbul ignore if */
    if (this._buildStatus === STATUS.BUILD_DONE && this.options.dev) {
      return this
    }
    // If building
    /* istanbul ignore if */
    if (this._buildStatus === STATUS.BUILDING) {
      await waitFor(1000);
      return this.build()
    }
    this._buildStatus = STATUS.BUILDING;

    consola.info({
      message: 'Building project',
      badge: true,
      clear: !this.options.dev
    });

    // Wait for nuxt ready
    await this.nuxt.ready();

    // Call before hook
    await this.nuxt.callHook('build:before', this, this.options.build);

    // Check if pages dir exists and warn if not
    this._nuxtPages = typeof this.options.build.createRoutes !== 'function';
    if (this._nuxtPages) {
      if (!fsExtra.existsSync(path__default.join(this.options.srcDir, this.options.dir.pages))) {
        const dir = this.options.srcDir;
        if (fsExtra.existsSync(path__default.join(this.options.srcDir, '..', this.options.dir.pages))) {
          throw new Error(
            `No \`${this.options.dir.pages}\` directory found in ${dir}. Did you mean to run \`nuxt\` in the parent (\`../\`) directory?`
          )
        } else {
          this._defaultPage = true;
          consola.warn({
            message: `No \`${this.options.dir.pages}\` directory found in ${dir}.`,
            additional: 'Using the default built-in page.\n',
            additionalStyle: 'yellowBright',
            badge: true
          });
        }
      }
    }

    consola.success('Builder initialized');

    consola.debug(`App root: ${this.options.srcDir}`);

    // Create .nuxt/, .nuxt/components and .nuxt/dist folders
    await fsExtra.remove(r(this.options.buildDir));
    const buildDirs = [r(this.options.buildDir, 'components')];
    if (!this.options.dev) {
      buildDirs.push(
        r(this.options.buildDir, 'dist', 'client'),
        r(this.options.buildDir, 'dist', 'server')
      );
    }
    await Promise.all(buildDirs.map(dir => fsExtra.mkdirp(dir)));

    // Generate routes and interpret the template files
    await this.generateRoutesAndFiles();

    // Start webpack build
    await this.webpackBuild();

    // Flag to set that building is done
    this._buildStatus = STATUS.BUILD_DONE;

    // Call done hook
    await this.nuxt.callHook('build:done', this);

    return this
  }

  async generateRoutesAndFiles() {
    consola.debug(`Generating nuxt files`);

    this.plugins = this.normalizePlugins();

    // -- Templates --
    let templatesFiles = [
      'App.js',
      'client.js',
      'index.js',
      'middleware.js',
      'router.js',
      'server.js',
      'utils.js',
      'empty.js',
      'components/nuxt-error.vue',
      'components/nuxt-loading.vue',
      'components/nuxt-child.js',
      'components/nuxt-link.js',
      'components/nuxt.js',
      'components/no-ssr.js',
      'views/app.template.html',
      'views/error.html'
    ];
    const templateVars = {
      options: this.options,
      extensions: this.options.extensions
        .map(ext => ext.replace(/^\./, ''))
        .join('|'),
      messages: this.options.messages,
      splitChunks: this.options.build.splitChunks,
      uniqBy: ___default.uniqBy,
      isDev: this.options.dev,
      debug: this.options.debug,
      vue: { config: this.options.vue.config },
      mode: this.options.mode,
      router: this.options.router,
      env: this.options.env,
      head: this.options.head,
      middleware: fsExtra.existsSync(path__default.join(this.options.srcDir, this.options.dir.middleware)),
      store: this.options.store,
      globalName: this.options.globalName,
      globals: this.globals,
      css: this.options.css,
      plugins: this.plugins,
      appPath: './App.js',
      ignorePrefix: this.options.ignorePrefix,
      layouts: Object.assign({}, this.options.layouts),
      loading:
        typeof this.options.loading === 'string'
          ? this.relativeToBuild(this.options.srcDir, this.options.loading)
          : this.options.loading,
      transition: this.options.transition,
      layoutTransition: this.options.layoutTransition,
      dir: this.options.dir,
      components: {
        ErrorPage: this.options.ErrorPage
          ? this.relativeToBuild(this.options.ErrorPage)
          : null
      }
    };

    // -- Layouts --
    if (fsExtra.existsSync(path__default.resolve(this.options.srcDir, this.options.dir.layouts))) {
      const layoutsFiles = await glob(`${this.options.dir.layouts}/**/*.{vue,js}`, {
        cwd: this.options.srcDir,
        ignore: this.options.ignore
      });
      layoutsFiles.forEach((file) => {
        const name = file
          .split('/')
          .slice(1)
          .join('/')
          .replace(/\.(vue|js)$/, '');
        if (name === 'error') {
          if (!templateVars.components.ErrorPage) {
            templateVars.components.ErrorPage = this.relativeToBuild(
              this.options.srcDir,
              file
            );
          }
          return
        }
        if (!templateVars.layouts[name] || /\.vue$/.test(file)) {
          templateVars.layouts[name] = this.relativeToBuild(
            this.options.srcDir,
            file
          );
        }
      });
    }
    // If no default layout, create its folder and add the default folder
    if (!templateVars.layouts.default) {
      await fsExtra.mkdirp(r(this.options.buildDir, 'layouts'));
      templatesFiles.push('layouts/default.vue');
      templateVars.layouts.default = './layouts/default.vue';
    }

    // -- Routes --
    consola.debug('Generating routes...');

    if (this._defaultPage) {
      templateVars.router.routes = createRoutes(
        ['index.vue'],
        this.options.nuxtAppDir + '/pages'
      );
    } else if (this._nuxtPages) { // If user defined a custom method to create routes
      // Use nuxt.js createRoutes bases on pages/
      const files = {}
      ;(await glob(`${this.options.dir.pages}/**/*.{vue,js}`, {
        cwd: this.options.srcDir,
        ignore: this.options.ignore
      })).forEach((f) => {
        const key = f.replace(/\.(js|vue)$/, '');
        if (/\.vue$/.test(f) || !files[key]) {
          files[key] = f.replace(/('|")/g, '\\$1');
        }
      });
      templateVars.router.routes = createRoutes(
        Object.values(files),
        this.options.srcDir,
        this.options.dir.pages
      );
    } else {
      templateVars.router.routes = this.options.build.createRoutes(
        this.options.srcDir
      );
    }

    await this.nuxt.callHook(
      'build:extendRoutes',
      templateVars.router.routes,
      r
    );
    // router.extendRoutes method
    if (typeof this.options.router.extendRoutes === 'function') {
      // let the user extend the routes
      const extendedRoutes = this.options.router.extendRoutes(
        templateVars.router.routes,
        r
      );
      // Only overwrite routes when something is returned for backwards compatibility
      if (extendedRoutes !== undefined) {
        templateVars.router.routes = extendedRoutes;
      }
    }

    // Make routes accessible for other modules and webpack configs
    this.routes = templateVars.router.routes;

    // -- Store --
    // Add store if needed
    if (this.options.store) {
      templatesFiles.push('store.js');
    }

    // Resolve template files
    const customTemplateFiles = this.options.build.templates.map(
      t => t.dst || path__default.basename(t.src || t)
    );

    templatesFiles = templatesFiles
      .map((file) => {
        // Skip if custom file was already provided in build.templates[]
        if (customTemplateFiles.includes(file)) {
          return
        }
        // Allow override templates using a file with same name in ${srcDir}/app
        const customPath = r(this.options.srcDir, 'app', file);
        const customFileExists = fsExtra.existsSync(customPath);

        return {
          src: customFileExists ? customPath : r(this.options.nuxtAppDir, file),
          dst: file,
          custom: customFileExists
        }
      })
      .filter(i => !!i);

    // -- Custom templates --
    // Add custom template files
    templatesFiles = templatesFiles.concat(
      this.options.build.templates.map((t) => {
        return Object.assign(
          {
            src: r(this.options.srcDir, t.src || t),
            dst: t.dst || path__default.basename(t.src || t),
            custom: true
          },
          t
        )
      })
    );

    // -- Loading indicator --
    if (this.options.loadingIndicator.name) {
      const indicatorPath1 = path__default.resolve(
        this.options.nuxtAppDir,
        'views/loading',
        this.options.loadingIndicator.name + '.html'
      );
      const indicatorPath2 = this.nuxt.resolveAlias(
        this.options.loadingIndicator.name
      );
      const indicatorPath = fsExtra.existsSync(indicatorPath1)
        ? indicatorPath1
        : fsExtra.existsSync(indicatorPath2) ? indicatorPath2 : null;
      if (indicatorPath) {
        templatesFiles.push({
          src: indicatorPath,
          dst: 'loading.html',
          options: this.options.loadingIndicator
        });
      } else {
        /* istanbul ignore next */
        // eslint-disable-next-line no-console
        console.error(
          `Could not fetch loading indicator: ${
            this.options.loadingIndicator.name
          }`
        );
      }
    }

    await this.nuxt.callHook('build:templates', {
      templatesFiles,
      templateVars,
      resolve: r
    });

    // Interpret and move template files to .nuxt/
    await Promise.all(
      templatesFiles.map(async ({ src, dst, options, custom }) => {
        // Add template to watchers
        this.options.build.watch.push(src);
        // Render template to dst
        const fileContent = await fsExtra.readFile(src, 'utf8');
        let content;
        try {
          const template = ___default.template(fileContent, {
            imports: {
              serialize,
              devalue,
              hash,
              r,
              wp,
              wChunk,
              resolvePath: this.nuxt.resolvePath,
              resolveAlias: this.nuxt.resolveAlias,
              relativeToBuild: this.relativeToBuild
            },
            interpolate: /<%=([\s\S]+?)%>/g
          });
          content = template(
            Object.assign({}, templateVars, {
              options: options || {},
              custom,
              src,
              dst
            })
          );
        } catch (err) {
          /* istanbul ignore next */
          throw new Error(`Could not compile template ${src}: ${err.message}`)
        }
        const _path = r(this.options.buildDir, dst);
        // Ensure parent dir exits and write file
        await fsExtra.outputFile(_path, content, 'utf8');
      })
    );

    consola.success('Nuxt files generated');
  }

  async webpackBuild() {
    this.perfLoader = new PerfLoader(this.options);

    const compilersOptions = [];

    // Client
    const clientConfig = new WebpackClientConfig(this).config();
    compilersOptions.push(clientConfig);

    // Server
    let serverConfig = null;
    if (this.options.build.ssr) {
      serverConfig = new WebpackServerConfig(this).config();
      compilersOptions.push(serverConfig);
    }

    // Check plugins exist then set alias to their real path
    await Promise.all(this.plugins.map(async (p) => {
      const ext = path__default.extname(p.src) ? '' : '{.+([^.]),/index.+([^.])}';
      const pluginFiles = await glob(`${p.src}${ext}`);

      if (!pluginFiles || pluginFiles.length === 0) {
        throw new Error(`Plugin not found: ${p.src}`)
      } else if (pluginFiles.length > 1) {
        consola.warn({
          message: `Found ${pluginFiles.length} plugins that match the configuration, suggest to specify extension:`,
          additional: `  ${pluginFiles.join('\n  ')}`,
          badge: true
        });
      }

      const src = this.relativeToBuild(p.src);
      // Client config
      if (!clientConfig.resolve.alias[p.name]) {
        clientConfig.resolve.alias[p.name] = src;
      }

      // Server config
      if (serverConfig && !serverConfig.resolve.alias[p.name]) {
        // Alias to noop for ssr:false plugins
        serverConfig.resolve.alias[p.name] = p.ssr ? src : './empty.js';
      }
    }));

    // Configure compilers
    this.compilers = compilersOptions.map((compilersOption) => {
      const compiler = webpack(compilersOption);

      // In dev, write files in memory FS
      if (this.options.dev) {
        compiler.outputFileSystem = this.mfs;
      }

      return compiler
    });

    // Warmup perfLoader before build
    if (this.options.build.parallel) {
      consola.info('Warming up worker pools');
      this.perfLoader.warmupAll();
      consola.success('Worker pools ready');
    }

    // Start Builds
    const runner = this.options.dev ? parallel : sequence;

    await runner(this.compilers, (compiler) => {
      return this.webpackCompile(compiler)
    });
  }

  webpackCompile(compiler) {
    return new Promise(async (resolve, reject) => {
      const name = compiler.options.name;

      await this.nuxt.callHook('build:compile', { name, compiler });

      // Load renderer resources after build
      compiler.hooks.done.tap('load-resources', async (stats) => {
        await this.nuxt.callHook('build:compiled', {
          name,
          compiler,
          stats
        });

        // Reload renderer if available
        this.nuxt.renderer.loadResources(this.mfs || fs);

        // Resolve on next tick
        process.nextTick(resolve);
      });

      if (this.options.dev) {
        // --- Dev Build ---
        // Client Build, watch is started by dev-middleware
        if (compiler.options.name === 'client') {
          return this.webpackDev(compiler)
        }
        // Server, build and watch for changes
        this.compilersWatching.push(
          compiler.watch(this.options.watchers.webpack, (err) => {
            /* istanbul ignore if */
            if (err) return reject(err)
          })
        );
      } else {
        // --- Production Build ---
        compiler.run((err, stats) => {
          /* istanbul ignore next */
          if (err) {
            return reject(err)
          } else if (stats.hasErrors()) {
            if (this.options.build.quiet === true) {
              err = stats.toString(this.options.build.stats);
            }
            if (!err) {
              // actual errors will be printed by webpack itself
              err = 'Nuxt Build Error';
            }

            return reject(err)
          }

          resolve();
        });
      }
    })
  }

  webpackDev(compiler) {
    consola.debug('Adding webpack middleware...');

    // Create webpack dev middleware
    this.webpackDevMiddleware = pify(
      webpackDevMiddleware(
        compiler,
        Object.assign(
          {
            publicPath: this.options.build.publicPath,
            stats: false,
            logLevel: 'silent',
            watchOptions: this.options.watchers.webpack
          },
          this.options.build.devMiddleware
        )
      )
    );

    this.webpackDevMiddleware.close = pify(this.webpackDevMiddleware.close);

    this.webpackHotMiddleware = pify(
      webpackHotMiddleware(
        compiler,
        Object.assign(
          {
            log: false,
            heartbeat: 10000
          },
          this.options.build.hotMiddleware
        )
      )
    );

    // Inject to renderer instance
    if (this.nuxt.renderer) {
      this.nuxt.renderer.webpackDevMiddleware = this.webpackDevMiddleware;
      this.nuxt.renderer.webpackHotMiddleware = this.webpackHotMiddleware;
    }

    // Start watching client files
    this.watchClient();
  }

  watchClient() {
    const src = this.options.srcDir;
    let patterns = [
      r(src, this.options.dir.layouts),
      r(src, this.options.dir.store),
      r(src, this.options.dir.middleware),
      r(src, `${this.options.dir.layouts}/*.{vue,js}`),
      r(src, `${this.options.dir.layouts}/**/*.{vue,js}`)
    ];
    if (this._nuxtPages) {
      patterns.push(
        r(src, this.options.dir.pages),
        r(src, `${this.options.dir.pages}/*.{vue,js}`),
        r(src, `${this.options.dir.pages}/**/*.{vue,js}`)
      );
    }
    patterns = ___default.map(patterns, upath.normalizeSafe);

    const options = this.options.watchers.chokidar;
    /* istanbul ignore next */
    const refreshFiles = ___default.debounce(() => this.generateRoutesAndFiles(), 200);

    // Watch for src Files
    this.watchers.files = chokidar
      .watch(patterns, options)
      .on('add', refreshFiles)
      .on('unlink', refreshFiles);

    // Watch for custom provided files
    let customPatterns = ___default.concat(
      this.options.build.watch,
      ...___default.values(___default.omit(this.options.build.styleResources, ['options']))
    );
    customPatterns = ___default.map(___default.uniq(customPatterns), upath.normalizeSafe);
    this.watchers.custom = chokidar
      .watch(customPatterns, options)
      .on('change', refreshFiles);
  }

  watchServer() {
    const nuxtRestartWatch = ___default.concat(
      this.options.serverMiddleware
        .filter(i => typeof i === 'string')
        .map(this.nuxt.resolveAlias),
      this.options.watch.map(this.nuxt.resolveAlias),
      path__default.join(this.options.rootDir, 'nuxt.config.js')
    );

    this.watchers.restart = chokidar
      .watch(nuxtRestartWatch, this.options.watchers.chokidar)
      .on('change', (_path) => {
        this.watchers.restart.close();
        const { name, ext } = path__default.parse(_path);
        this.nuxt.callHook('watch:fileChanged', this, `${name}${ext}`);
      });
  }

  async unwatch() {
    for (const watcher in this.watchers) {
      if (this.watchers[watcher]) {
        this.watchers[watcher].close();
      }
    }

    this.compilersWatching.forEach(watching => watching.close());

    // Stop webpack middleware
    if (this.webpackDevMiddleware) {
      await this.webpackDevMiddleware.close();
    }
  }

  // TODO: remove ignore when generateConfig enabled again
  async generateConfig() /* istanbul ignore next */ {
    const config = path__default.resolve(this.options.buildDir, 'build.config.js');
    const options = ___default.omit(this.options, Options.unsafeKeys);
    await fsExtra.writeFile(
      config,
      `export default ${JSON.stringify(options, null, '  ')}`,
      'utf8'
    );
  }
}

const STATUS = {
  INITIAL: 1,
  BUILD_DONE: 2,
  BUILDING: 3
};

class Generator {
  constructor(nuxt, builder) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.builder = builder;

    // Set variables
    this.staticRoutes = path__default.resolve(this.options.srcDir, this.options.dir.static);
    this.srcBuiltPath = path__default.resolve(this.options.buildDir, 'dist', 'client');
    this.distPath = this.options.generate.dir;
    this.distNuxtPath = path__default.join(
      this.distPath,
      isUrl(this.options.build.publicPath) ? '' : this.options.build.publicPath
    );
  }

  async generate({ build = true, init = true } = {}) {
    consola.debug('Initializing generator...');

    await this.initiate({ build, init });

    consola.debug('Preparing routes for generate...');

    const routes = await this.initRoutes();

    consola.info({
      message: 'Generating pages',
      badge: true,
      clear: true
    });

    const errors = await this.generateRoutes(routes);

    await this.afterGenerate();

    // Done hook
    await this.nuxt.callHook('generate:done', this, errors);

    return { errors }
  }

  async initiate({ build = true, init = true } = {}) {
    // Wait for nuxt be ready
    await this.nuxt.ready();

    // Call before hook
    await this.nuxt.callHook('generate:before', this, this.options.generate);

    if (build) {
      // Add flag to set process.static
      this.builder.forGenerate();

      // Start build process
      await this.builder.build();
    }

    // Initialize dist directory
    if (init) {
      await this.initDist();
    }
  }

  async initRoutes(...args) {
    // Resolve config.generate.routes promises before generating the routes
    let generateRoutes = [];
    if (this.options.router.mode !== 'hash') {
      try {
        generateRoutes = await promisifyRoute(
          this.options.generate.routes || [],
          ...args
        );
      } catch (e) {
        consola.error('Could not resolve routes');
        throw e // eslint-disable-line no-unreachable
      }
    }
    // Generate only index.html for router.mode = 'hash'
    let routes =
      this.options.router.mode === 'hash'
        ? ['/']
        : flatRoutes(this.options.router.routes);
    routes = this.decorateWithPayloads(routes, generateRoutes);

    // extendRoutes hook
    await this.nuxt.callHook('generate:extendRoutes', routes);

    return routes
  }

  async generateRoutes(routes) {
    const errors = [];

    // Start generate process
    while (routes.length) {
      let n = 0;
      await Promise.all(
        routes
          .splice(0, this.options.generate.concurrency)
          .map(async ({ route, payload }) => {
            await waitFor(n++ * this.options.generate.interval);
            await this.generateRoute({ route, payload, errors });
          })
      );
    }

    // Improve string representation for errors
    errors.toString = () => this._formatErrors(errors);

    return errors
  }

  _formatErrors(errors) {
    return errors
      .map(({ type, route, error }) => {
        const isHandled = type === 'handled';
        const bgColor = isHandled ? 'bgYellow' : 'bgRed';
        const color = isHandled ? 'yellow' : 'red';

        let line =
          Chalk.black[bgColor](' GEN ERR ') + Chalk[color](` ${route}\n\n`);

        if (isHandled) {
          line += Chalk.grey(JSON.stringify(error, undefined, 2) + '\n');
        } else {
          line += Chalk.grey(error.stack);
        }

        return line
      })
      .join('\n')
  }

  async afterGenerate() {
    const { fallback } = this.options.generate;

    // Disable SPA fallback if value isn't a non-empty string
    if (typeof fallback !== 'string' || !fallback) return

    const fallbackPath = path__default.join(this.distPath, fallback);

    // Prevent conflicts
    if (fsExtra.existsSync(fallbackPath)) {
      consola.warn(`SPA fallback was configured, but the configured path (${fallbackPath}) already exists.`);
      return
    }

    // Render and write the SPA template to the fallback path
    const { html } = await this.nuxt.renderRoute('/', { spa: true });
    await fsExtra.writeFile(fallbackPath, html, 'utf8');
  }

  async initDist() {
    // Clean destination folder
    await fsExtra.remove(this.distPath);

    await this.nuxt.callHook('generate:distRemoved', this);

    // Copy static and built files
    /* istanbul ignore if */
    if (fsExtra.existsSync(this.staticRoutes)) {
      await fsExtra.copy(this.staticRoutes, this.distPath);
    }
    await fsExtra.copy(this.srcBuiltPath, this.distNuxtPath);

    // Add .nojekyll file to let GitHub Pages add the _nuxt/ folder
    // https://help.github.com/articles/files-that-start-with-an-underscore-are-missing/
    const nojekyllPath = path__default.resolve(this.distPath, '.nojekyll');
    fsExtra.writeFile(nojekyllPath, '');

    await this.nuxt.callHook('generate:distCopied', this);
  }

  decorateWithPayloads(routes, generateRoutes) {
    const routeMap = {};
    // Fill routeMap for known routes
    routes.forEach((route) => {
      routeMap[route] = { route, payload: null };
    });
    // Fill routeMap with given generate.routes
    generateRoutes.forEach((route) => {
      // route is either a string or like { route : '/my_route/1', payload: {} }
      const path$$1 = isString(route) ? route : route.route;
      routeMap[path$$1] = {
        route: path$$1,
        payload: route.payload || null
      };
    });
    return Object.values(routeMap)
  }

  async generateRoute({ route, payload = {}, errors = [] }) {
    let html;
    const pageErrors = [];

    try {
      const res = await this.nuxt.renderer.renderRoute(route, {
        _generate: true,
        payload
      });
      html = res.html;
      if (res.error) {
        pageErrors.push({ type: 'handled', route, error: res.error });
      }
    } catch (err) {
      /* istanbul ignore next */
      pageErrors.push({ type: 'unhandled', route, error: err });
      Array.prototype.push.apply(errors, pageErrors);

      await this.nuxt.callHook('generate:routeFailed', {
        route,
        errors: pageErrors
      });
      consola.error(this._formatErrors(pageErrors));

      return false
    }

    let minificationOptions = this.options.build.html.minify;

    // Legacy: Override minification options with generate.minify if present
    // TODO: Remove in Nuxt version 3
    if (typeof this.options.generate.minify !== 'undefined') {
      minificationOptions = this.options.generate.minify;
      consola.warn('generate.minify has been deprecated and will be removed in the next major version.' +
        ' Use build.html.minify instead!');
    }

    if (minificationOptions) {
      try {
        html = htmlMinifier.minify(html, minificationOptions);
      } catch (err) /* istanbul ignore next */ {
        const minifyErr = new Error(
          `HTML minification failed. Make sure the route generates valid HTML. Failed HTML:\n ${html}`
        );
        pageErrors.push({ type: 'unhandled', route, error: minifyErr });
      }
    }

    let _path;

    if (this.options.generate.subFolders) {
      _path = path__default.join(route, path__default.sep, 'index.html'); // /about -> /about/index.html
      _path = _path === '/404/index.html' ? '/404.html' : _path; // /404 -> /404.html
    } else {
      _path = route.length > 1 ? path__default.join(path__default.sep, route + '.html') : path__default.join(path__default.sep, 'index.html');
    }

    // Call hook to let user update the path & html
    const page = { route, path: _path, html };
    await this.nuxt.callHook('generate:page', page);

    page.path = path__default.join(this.distPath, page.path);

    // Make sure the sub folders are created
    await fsExtra.mkdirp(path__default.dirname(page.path));
    await fsExtra.writeFile(page.path, page.html, 'utf8');

    await this.nuxt.callHook('generate:routeCreated', {
      route,
      path: page.path,
      errors: pageErrors
    });

    if (pageErrors.length) {
      consola.error('Error generating ' + route);
      Array.prototype.push.apply(errors, pageErrors);
    } else {
      consola.success('Generated ' + route);
    }

    return true
  }
}

var builder = {
  Builder,
  Generator
};

var index = Object.assign({ Utils, Options }, core, builder);

module.exports = index;
//# sourceMappingURL=nuxt.js.map
