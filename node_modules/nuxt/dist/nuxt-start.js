/*!
 * nuxt-start v2.2.0 (c) 2016-2018
 * - Sebastien Chopin (@Atinux)
 * - Alexandre Chopin (@alexchopin)
 * - Pooya Parsa (@pi0)
 * - Clark Du (@clarkdo)
 * - Jonas Galvez (@galvez)
 * - Alexander Lichter (@manniL}
 * - All the amazing contributors
 * Released under the MIT License.
 * Website: https://nuxtjs.org
*/
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var _ = _interopDefault(require('lodash'));
var consola = _interopDefault(require('consola'));
var fs = _interopDefault(require('fs'));
var hash = _interopDefault(require('hash-sum'));
var env = _interopDefault(require('std-env'));
var Vue = _interopDefault(require('vue'));
var VueMeta = _interopDefault(require('vue-meta'));
var vueServerRenderer = require('vue-server-renderer');
var LRU = _interopDefault(require('lru-cache'));
var Youch = _interopDefault(require('@nuxtjs/youch'));
var fs$1 = _interopDefault(require('fs-extra'));
var generateETag = _interopDefault(require('etag'));
var fresh = _interopDefault(require('fresh'));
var crypto = _interopDefault(require('crypto'));
var devalue = _interopDefault(require('@nuxtjs/devalue'));
var serveStatic = _interopDefault(require('serve-static'));
var connect = _interopDefault(require('connect'));
var launchMiddleware = _interopDefault(require('launch-editor-middleware'));
var Module = _interopDefault(require('module'));
var https = _interopDefault(require('https'));
var enableDestroy = _interopDefault(require('server-destroy'));
var chalk = _interopDefault(require('chalk'));
var esm = _interopDefault(require('esm'));
var ip = _interopDefault(require('ip'));

const encodeHtml = function encodeHtml(str) {
  return str.replace(/</g, '&lt;').replace(/>/g, '&gt;')
};

const getContext = function getContext(req, res) {
  return { req, res }
};

const waitFor = function waitFor(ms) {
  return new Promise(resolve => setTimeout(resolve, ms || 0))
};

const isString = function isString(obj) {
  return typeof obj === 'string' || obj instanceof String
};
const startsWithAlias = aliasArray => str => aliasArray.some(c => str.startsWith(c));

const startsWithSrcAlias = startsWithAlias(['@', '~']);

const startsWithRootAlias = startsWithAlias(['@@', '~~']);

async function promiseFinally(fn, finalFn) {
  let result;
  try {
    if (typeof fn === 'function') {
      result = await fn();
    } else {
      result = await fn;
    }
  } finally {
    finalFn();
  }
  return result
}

const timeout = function timeout(fn, ms, msg) {
  let timerId;
  const warpPromise = promiseFinally(fn, () => clearTimeout(timerId));
  const timerPromise = new Promise((resolve, reject) => {
    timerId = setTimeout(() => reject(new Error(msg)), ms);
  });
  return Promise.race([warpPromise, timerPromise])
};

const urlJoin = function urlJoin() {
  return [].slice
    .call(arguments)
    .join('/')
    .replace(/\/+/g, '/')
    .replace(':/', '://')
};

const isUrl = function isUrl(url) {
  return ['http', '//'].some(str => url.startsWith(str))
};

const promisifyRoute = function promisifyRoute(fn, ...args) {
  // If routes is an array
  if (Array.isArray(fn)) {
    return Promise.resolve(fn)
  }
  // If routes is a function expecting a callback
  if (fn.length === arguments.length) {
    return new Promise((resolve, reject) => {
      fn((err, routeParams) => {
        if (err) {
          reject(err);
        }
        resolve(routeParams);
      }, ...args);
    })
  }
  let promise = fn(...args);
  if (
    !promise ||
    (!(promise instanceof Promise) && typeof promise.then !== 'function')
  ) {
    promise = Promise.resolve(promise);
  }
  return promise
};

const sequence = function sequence(tasks, fn) {
  return tasks.reduce(
    (promise, task) => promise.then(() => fn(task)),
    Promise.resolve()
  )
};

const parallel = function parallel(tasks, fn) {
  return Promise.all(tasks.map(fn))
};

const chainFn = function chainFn(base, fn) {
  /* istanbul ignore if */
  if (typeof fn !== 'function') {
    return base
  }
  return function () {
    if (typeof base !== 'function') {
      return fn.apply(this, arguments)
    }
    let baseResult = base.apply(this, arguments);
    // Allow function to mutate the first argument instead of returning the result
    if (baseResult === undefined) {
      baseResult = arguments[0];
    }
    const fnResult = fn.call(
      this,
      baseResult,
      ...Array.prototype.slice.call(arguments, 1)
    );
    // Return mutated argument if no result was returned
    if (fnResult === undefined) {
      return baseResult
    }
    return fnResult
  }
};

const isPureObject = function isPureObject(o) {
  return !Array.isArray(o) && typeof o === 'object'
};

const isWindows = /^win/.test(process.platform);

const wp = function wp(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\\/g, '\\\\')
  }
  return p
};

const wChunk = function wChunk(p = '') {
  /* istanbul ignore if */
  if (isWindows) {
    return p.replace(/\//g, '_')
  }
  return p
};

const reqSep = /\//g;
const sysSep = _.escapeRegExp(path__default.sep);
const normalize = string => string.replace(reqSep, sysSep);

const r = function r(...args) {
  const lastArg = args[args.length - 1];

  if (startsWithSrcAlias(lastArg)) {
    return wp(lastArg)
  }

  return wp(path__default.resolve(...args.map(normalize)))
};

const relativeTo = function relativeTo() {
  const args = Array.prototype.slice.apply(arguments);
  const dir = args.shift();

  // Keep webpack inline loader intact
  if (args[0].includes('!')) {
    const loaders = args.shift().split('!');

    return loaders.concat(relativeTo(dir, loaders.pop(), ...args)).join('!')
  }

  // Resolve path
  const _path = r(...args);

  // Check if path is an alias
  if (startsWithSrcAlias(_path)) {
    return _path
  }

  // Make correct relative path
  let rp = path__default.relative(dir, _path);
  if (rp[0] !== '.') {
    rp = './' + rp;
  }

  return wp(rp)
};

const flatRoutes = function flatRoutes(router, _path = '', routes = []) {
  router.forEach((r) => {
    if ([':', '*'].some(c => r.path.includes(c))) {
      return
    }
    /* istanbul ignore if */
    if (r.children) {
      if (_path === '' && r.path === '/') {
        routes.push('/');
      }
      return flatRoutes(r.children, _path + r.path + '/', routes)
    }
    _path = _path.replace(/^\/+$/, '/');
    routes.push(
      (r.path === '' && _path[_path.length - 1] === '/'
        ? _path.slice(0, -1)
        : _path) + r.path
    );
  });
  return routes
};

function cleanChildrenRoutes(routes, isChild = false) {
  let start = -1;
  const routesIndex = [];
  routes.forEach((route) => {
    if (/-index$/.test(route.name) || route.name === 'index') {
      // Save indexOf 'index' key in name
      const res = route.name.split('-');
      const s = res.indexOf('index');
      start = start === -1 || s < start ? s : start;
      routesIndex.push(res);
    }
  });
  routes.forEach((route) => {
    route.path = isChild ? route.path.replace('/', '') : route.path;
    if (route.path.includes('?')) {
      const names = route.name.split('-');
      const paths = route.path.split('/');
      if (!isChild) {
        paths.shift();
      } // clean first / for parents
      routesIndex.forEach((r) => {
        const i = r.indexOf('index') - start; //  children names
        if (i < paths.length) {
          for (let a = 0; a <= i; a++) {
            if (a === i) {
              paths[a] = paths[a].replace('?', '');
            }
            if (a < i && names[a] !== r[a]) {
              break
            }
          }
        }
      });
      route.path = (isChild ? '' : '/') + paths.join('/');
    }
    route.name = route.name.replace(/-index$/, '');
    if (route.children) {
      if (route.children.find(child => child.path === '')) {
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true);
    }
  });
  return routes
}

const createRoutes = function createRoutes(files, srcDir, pagesDir) {
  const routes = [];
  files.forEach((file) => {
    const keys = file
      .replace(RegExp(`^${pagesDir}`), '')
      .replace(/\.(vue|js)$/, '')
      .replace(/\/{2,}/g, '/')
      .split('/')
      .slice(1);
    const route = { name: '', path: '', component: r(srcDir, file) };
    let parent = routes;
    keys.forEach((key, i) => {
      // remove underscore only, if its the prefix
      const sanitizedKey = key.startsWith('_') ? key.substr(1) : key;

      route.name = route.name
        ? route.name + '-' + sanitizedKey
        : sanitizedKey;
      route.name += key === '_' ? 'all' : '';
      route.chunkName = file.replace(/\.(vue|js)$/, '');
      const child = parent.find(parentRoute => parentRoute.name === route.name);

      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = '';
      } else if (key === 'index' && i + 1 === keys.length) {
        route.path += i > 0 ? '' : '/';
      } else {
        route.path += '/' + getRoutePathExtension(key);

        if (key.startsWith('_') && key.length > 1) {
          route.path += '?';
        }
      }
    });
    // Order Routes path
    parent.push(route);
    parent.sort((a, b) => {
      if (!a.path.length) {
        return -1
      }
      if (!b.path.length) {
        return 1
      }
      // Order: /static, /index, /:dynamic
      // Match exact route before index: /login before /index/_slug
      if (a.path === '/') {
        return DYNAMIC_ROUTE_REGEX.test(b.path) ? -1 : 1
      }
      if (b.path === '/') {
        return DYNAMIC_ROUTE_REGEX.test(a.path) ? 1 : -1
      }

      let i;
      let res = 0;
      let y = 0;
      let z = 0;
      const _a = a.path.split('/');
      const _b = b.path.split('/');
      for (i = 0; i < _a.length; i++) {
        if (res !== 0) {
          break
        }
        y = _a[i] === '*' ? 2 : _a[i].includes(':') ? 1 : 0;
        z = _b[i] === '*' ? 2 : _b[i].includes(':') ? 1 : 0;
        res = y - z;
        // If a.length >= b.length
        if (i === _b.length - 1 && res === 0) {
          // change order if * found
          res = _a[i] === '*' ? -1 : 1;
        }
      }
      return res === 0 ? (_a[i - 1] === '*' && _b[i] ? 1 : -1) : res
    });
  });
  return cleanChildrenRoutes(routes)
};

// Guard dir1 from dir2 which can be indiscriminately removed
const guardDir = function guardDir(options, key1, key2) {
  const dir1 = _.get(options, key1, false);
  const dir2 = _.get(options, key2, false);

  if (
    dir1 &&
    dir2 &&
    (
      dir1 === dir2 ||
      (
        dir1.startsWith(dir2) &&
        !path__default.basename(dir1).startsWith(path__default.basename(dir2))
      )
    )
  ) {
    const errorMessage = `options.${key2} cannot be a parent of or same as ${key1}`;
    consola.fatal(errorMessage);
    throw new Error(errorMessage)
  }
};

const determineGlobals = function determineGlobals(globalName, globals) {
  const _globals = {};
  for (const global in globals) {
    if (typeof globals[global] === 'function') {
      _globals[global] = globals[global](globalName);
    } else {
      _globals[global] = globals[global];
    }
  }
  return _globals
};

const getRoutePathExtension = (key) => {
  if (key === '_') {
    return '*'
  }

  if (key.startsWith('_')) {
    return `:${key.substr(1)}`
  }

  return key
};

const DYNAMIC_ROUTE_REGEX = /^\/(:|\*)/;

/**
 * Wraps value in array if it is not already an array
 *
 * @param  {any} value
 * @return {array}
 */
const wrapArray = value => Array.isArray(value) ? value : [value];

var Utils = /*#__PURE__*/Object.freeze({
  encodeHtml: encodeHtml,
  getContext: getContext,
  waitFor: waitFor,
  isString: isString,
  startsWithAlias: startsWithAlias,
  startsWithSrcAlias: startsWithSrcAlias,
  startsWithRootAlias: startsWithRootAlias,
  timeout: timeout,
  urlJoin: urlJoin,
  isUrl: isUrl,
  promisifyRoute: promisifyRoute,
  sequence: sequence,
  parallel: parallel,
  chainFn: chainFn,
  isPureObject: isPureObject,
  isWindows: isWindows,
  wp: wp,
  wChunk: wChunk,
  r: r,
  relativeTo: relativeTo,
  flatRoutes: flatRoutes,
  createRoutes: createRoutes,
  guardDir: guardDir,
  determineGlobals: determineGlobals,
  wrapArray: wrapArray
});

class ModuleContainer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.requiredModules = {};
  }

  async ready() {
    // Call before hook
    await this.nuxt.callHook('modules:before', this, this.options.modules);

    // Load every module in sequence
    await sequence(this.options.modules, this.addModule.bind(this));

    // Call done hook
    await this.nuxt.callHook('modules:done', this);
  }

  addVendor() {
    consola.warn('addVendor has been deprecated due to webpack4 optimization');
  }

  addTemplate(template) {
    /* istanbul ignore if */
    if (!template) {
      throw new Error('Invalid template:' + JSON.stringify(template))
    }

    // Validate & parse source
    const src = template.src || template;
    const srcPath = path__default.parse(src);
    /* istanbul ignore if */
    if (typeof src !== 'string' || !fs.existsSync(src)) {
      throw new Error('Template src not found:' + src)
    }

    // Generate unique and human readable dst filename
    const dst =
      template.fileName ||
      path__default.basename(srcPath.dir) + `.${srcPath.name}.${hash(src)}` + srcPath.ext;

    // Add to templates list
    const templateObj = {
      src,
      dst,
      options: template.options
    };

    this.options.build.templates.push(templateObj);
    return templateObj
  }

  addPlugin(template) {
    const { dst } = this.addTemplate(template);

    // Add to nuxt plugins
    this.options.plugins.unshift({
      src: path__default.join(this.options.buildDir, dst),
      ssr: template.ssr
    });
  }

  addLayout(template, name) {
    const { dst, src } = this.addTemplate(template);

    // Add to nuxt layouts
    this.options.layouts[name || path__default.parse(src).name] = `./${dst}`;

    // If error layout, set ErrorPage
    if (name === 'error') {
      this.addErrorLayout(dst);
    }
  }

  addErrorLayout(dst) {
    const relativeBuildDir = path__default.relative(this.options.rootDir, this.options.buildDir);
    this.options.ErrorPage = `~/${relativeBuildDir}/${dst}`;
  }

  addServerMiddleware(middleware) {
    this.options.serverMiddleware.push(middleware);
  }

  extendBuild(fn) {
    this.options.build.extend = chainFn(this.options.build.extend, fn);
  }

  extendRoutes(fn) {
    this.options.router.extendRoutes = chainFn(
      this.options.router.extendRoutes,
      fn
    );
  }

  requireModule(moduleOpts) {
    return this.addModule(moduleOpts, true /* require once */)
  }

  addModule(moduleOpts, requireOnce) {
    let src;
    let options;
    let handler;

    // Type 1: String
    if (typeof moduleOpts === 'string') {
      src = moduleOpts;
    } else if (Array.isArray(moduleOpts)) {
      // Type 2: Babel style array
      src = moduleOpts[0];
      options = moduleOpts[1];
    } else if (typeof moduleOpts === 'object') {
      // Type 3: Pure object
      src = moduleOpts.src;
      options = moduleOpts.options;
      handler = moduleOpts.handler;
    }

    // Resolve handler
    if (!handler) {
      handler = this.nuxt.requireModule(src);
    }

    // Validate handler
    /* istanbul ignore if */
    if (typeof handler !== 'function') {
      throw new Error('Module should export a function: ' + src)
    }

    // Resolve module meta
    const key = (handler.meta && handler.meta.name) || handler.name || src;

    // Update requiredModules
    if (typeof key === 'string') {
      if (requireOnce && this.requiredModules[key]) {
        return
      }
      this.requiredModules[key] = { src, options, handler };
    }

    // Default module options to empty object
    if (options === undefined) {
      options = {};
    }

    return new Promise((resolve) => {
      // Call module with `this` context and pass options
      const result = handler.call(this, options);

      // If module send back a promise
      if (result && result.then) {
        return resolve(result)
      }

      // synchronous
      return resolve()
    })
  }
}

var modes = {
  universal: {
    build: {
      ssr: true
    },
    render: {
      ssr: true
    }
  },
  spa: {
    build: {
      ssr: false
    },
    render: {
      ssr: false
    }
  }
};

const nuxtDir = fs.existsSync(path__default.resolve(__dirname, '..', 'package.json'))
  ? path__default.resolve(__dirname, '..') // dist
  : path__default.resolve(__dirname, '..', '..'); // src

var defaults = {
  // Information about running environment
  dev: Boolean(env.dev),
  debug: undefined, // = dev

  // Mode
  mode: 'universal',

  // Global name
  globalName: `nuxt`,
  globals: {
    id: globalName => `__${globalName}`,
    nuxt: globalName => `$${globalName}`,
    context: globalName => `__${globalName.toUpperCase()}__`,
    pluginPrefix: globalName => globalName,
    readyCallback: globalName => `on${_.capitalize(globalName)}Ready`,
    loadedCallback: globalName => `_on${_.capitalize(globalName)}Loaded`
  },

  // Server options
  server: {
    https: false,
    port: process.env.NUXT_PORT ||
      process.env.PORT ||
      process.env.npm_package_config_nuxt_port,
    host: process.env.NUXT_HOST ||
      process.env.HOST ||
      process.env.npm_package_config_nuxt_host
  },

  // Dirs
  srcDir: undefined,
  buildDir: '.nuxt',
  nuxtDir,
  nuxtAppDir: path__default.resolve(nuxtDir, 'lib', 'app'),
  modulesDir: ['node_modules'], // ~> relative to options.rootDir

  // Ignore
  ignorePrefix: '-',
  ignore: [
    '**/*.test.*',
    '**/*.spec.*'
  ],

  extensions: [],

  build: {
    quiet: Boolean(env.ci || env.test),
    analyze: false,
    profile: process.argv.includes('--profile'),
    extractCSS: false,
    cssSourceMap: undefined,
    ssr: undefined,
    parallel: false,
    cache: false,
    publicPath: '/_nuxt/',
    filenames: {
      // { isDev, isClient, isServer }
      app: ({ isDev }) => isDev ? '[name].js' : '[chunkhash].js',
      chunk: ({ isDev }) => isDev ? '[name].js' : '[chunkhash].js',
      css: ({ isDev }) => isDev ? '[name].css' : '[contenthash].css',
      img: ({ isDev }) => isDev ? '[path][name].[ext]' : 'img/[hash:7].[ext]',
      font: ({ isDev }) => isDev ? '[path][name].[ext]' : 'fonts/[hash:7].[ext]',
      video: ({ isDev }) => isDev ? '[path][name].[ext]' : 'videos/[hash:7].[ext]'
    },
    loaders: {
      file: {},
      fontUrl: { limit: 1000 },
      imgUrl: { limit: 1000 },
      pugPlain: {},
      vue: {
        transformAssetUrls: {
          video: 'src',
          source: 'src',
          object: 'src',
          embed: 'src'
        }
      },
      css: {},
      cssModules: {
        localIdentName: '[local]_[hash:base64:5]'
      },
      less: {},
      sass: {
        indentedSyntax: true
      },
      scss: {},
      stylus: {},
      vueStyle: {}
    },
    styleResources: {},
    plugins: [],
    terser: {},
    optimizeCSS: undefined,
    optimization: {
      runtimeChunk: 'single',
      minimize: undefined,
      minimizer: undefined,
      splitChunks: {
        chunks: 'all',
        automaticNameDelimiter: '.',
        name: undefined,
        cacheGroups: {}
      }
    },
    splitChunks: {
      layouts: false,
      pages: true,
      commons: true
    },
    babel: {
      babelrc: false,
      cacheDirectory: undefined
    },
    transpile: [], // Name of NPM packages to be transpiled
    postcss: {
      preset: {
        // https://cssdb.org/#staging-process
        stage: 2
      }
    },
    html: {
      minify: {
        collapseBooleanAttributes: true,
        decodeEntities: true,
        minifyCSS: true,
        minifyJS: true,
        processConditionalComments: true,
        removeEmptyAttributes: true,
        removeRedundantAttributes: true,
        trimCustomFragments: true,
        useShortDoctype: true
      }
    },

    templates: [],
    watch: [],
    devMiddleware: {},
    hotMiddleware: {},
    stats: {
      chunks: false,
      children: false,
      modules: false,
      colors: true,
      warnings: true,
      errors: true,
      excludeAssets: [
        /.map$/,
        /index\..+\.html$/,
        /vue-ssr-client-manifest.json/
      ]
    }
  },
  generate: {
    dir: 'dist',
    routes: [],
    concurrency: 500,
    interval: 0,
    subFolders: true,
    fallback: '200.html'
  },
  env: {},
  head: {
    meta: [],
    link: [],
    style: [],
    script: []
  },
  plugins: [],
  css: [],
  modules: [],
  layouts: {},
  serverMiddleware: [],
  ErrorPage: null,
  loading: {
    color: 'black',
    failedColor: 'red',
    height: '2px',
    throttle: 200,
    duration: 5000,
    rtl: false
  },
  loadingIndicator: 'default',
  transition: {
    name: 'page',
    mode: 'out-in',
    appear: false,
    appearClass: 'appear',
    appearActiveClass: 'appear-active',
    appearToClass: 'appear-to'
  },
  layoutTransition: {
    name: 'layout',
    mode: 'out-in'
  },
  dir: {
    assets: 'assets',
    layouts: 'layouts',
    middleware: 'middleware',
    pages: 'pages',
    static: 'static',
    store: 'store'
  },
  vue: {
    config: {
      silent: undefined, // = !dev
      performance: undefined // = dev
    }
  },
  router: {
    mode: 'history',
    base: '/',
    routes: [],
    middleware: [],
    linkActiveClass: 'nuxt-link-active',
    linkExactActiveClass: 'nuxt-link-exact-active',
    extendRoutes: null,
    scrollBehavior: null,
    parseQuery: false,
    stringifyQuery: false,
    fallback: false
  },
  render: {
    bundleRenderer: {
      shouldPrefetch: () => false
    },
    resourceHints: true,
    ssr: undefined,
    http2: {
      push: false,
      shouldPush: null
    },
    static: {
      prefix: true
    },
    compressor: {
      threshold: 0
    },
    etag: {
      weak: false
    },
    csp: false,
    dist: {
      // Don't serve index.html template
      index: false,
      // 1 year in production
      maxAge: '1y'
    }
  },
  // User-defined changes
  watch: [],
  watchers: {
    webpack: {},
    chokidar: {
      ignoreInitial: true
    }
  },
  editor: undefined,
  hooks: null,
  messages: {
    loading: 'Loading...',
    error_404: 'This page could not be found',
    server_error: 'Server error',
    nuxtjs: 'Nuxt.js',
    back_to_home: 'Back to the home page',
    server_error_details:
      'An error occurred in the application and your page could not be served. If you are the application owner, check your logs for details.',
    client_error: 'Error',
    client_error_details:
      'An error occurred while rendering the page. Check developer tools console for details.'
  }
};

// hasValue utility
const hasValue = v => typeof v === 'string' && v;

const Options = {};

Options.from = function (_options) {
  // Clone options to prevent unwanted side-effects
  const options = Object.assign({}, _options);

  // Normalize options
  if (options.loading === true) {
    delete options.loading;
  }
  if (
    options.router &&
    options.router.middleware &&
    !Array.isArray(options.router.middleware)
  ) {
    options.router.middleware = [options.router.middleware];
  }
  if (options.router && typeof options.router.base === 'string') {
    options._routerBaseSpecified = true;
  }
  if (typeof options.transition === 'string') {
    options.transition = { name: options.transition };
  }
  if (typeof options.layoutTransition === 'string') {
    options.layoutTransition = { name: options.layoutTransition };
  }
  if (typeof options.extensions === 'string') {
    options.extensions = [options.extensions];
  }

  options.globalName = (_.isString(options.globalName) && /^[a-zA-Z]+$/.test(options.globalName))
    ? options.globalName.toLowerCase()
    : 'nuxt';

  // Resolve rootDir
  options.rootDir = hasValue(options.rootDir) ? path__default.resolve(options.rootDir) : process.cwd();

  // Apply defaults by ${buildDir}/dist/build.config.js
  // TODO: Unsafe operation.
  // const buildDir = options.buildDir || defaults.buildDir
  // const buildConfig = resolve(options.rootDir, buildDir, 'build.config.js')
  // if (existsSync(buildConfig)) {
  //   _.defaultsDeep(options, require(buildConfig))
  // }

  // Apply defaults
  _.defaultsDeep(options, defaults);

  // Check srcDir and generate.dir excistence
  const hasSrcDir = hasValue(options.srcDir);
  const hasGenerateDir = hasValue(options.generate.dir);

  // Resolve srcDir
  options.srcDir = hasSrcDir
    ? path__default.resolve(options.rootDir, options.srcDir)
    : options.rootDir;

  // Resolve buildDir
  options.buildDir = path__default.resolve(options.rootDir, options.buildDir);

  // Protect rootDir against buildDir
  guardDir(options, 'rootDir', 'buildDir');

  if (hasGenerateDir) {
    // Resolve generate.dir
    options.generate.dir = path__default.resolve(options.rootDir, options.generate.dir);

    // Protect rootDir against buildDir
    guardDir(options, 'rootDir', 'generate.dir');
  }

  if (hasSrcDir) {
    // Protect srcDir against buildDir
    guardDir(options, 'srcDir', 'buildDir');

    if (hasGenerateDir) {
      // Protect srcDir against generate.dir
      guardDir(options, 'srcDir', 'generate.dir');
    }
  }

  // Populate modulesDir
  options.modulesDir = []
    .concat(options.modulesDir)
    .concat(path__default.join(options.nuxtDir, 'node_modules')).filter(hasValue)
    .map(dir => path__default.resolve(options.rootDir, dir));

  const mandatoryExtensions = ['js', 'mjs'];

  options.extensions = mandatoryExtensions
    .filter(ext => !options.extensions.includes(ext))
    .concat(options.extensions);

  // If app.html is defined, set the template path to the user template
  if (options.appTemplatePath === undefined) {
    options.appTemplatePath = path__default.resolve(options.buildDir, 'views/app.template.html');
    if (fs.existsSync(path__default.join(options.srcDir, 'app.html'))) {
      options.appTemplatePath = path__default.join(options.srcDir, 'app.html');
    }
  } else {
    options.appTemplatePath = path__default.resolve(options.srcDir, options.appTemplatePath);
  }

  // Ignore publicPath on dev
  /* istanbul ignore if */
  if (options.dev && isUrl(options.build.publicPath)) {
    options.build.publicPath = defaults.build.publicPath;
  }

  // If store defined, update store options to true unless explicitly disabled
  if (
    options.store !== false &&
    fs.existsSync(path__default.join(options.srcDir, options.dir.store)) &&
    fs.readdirSync(path__default.join(options.srcDir, options.dir.store))
      .find(filename => filename !== 'README.md' && filename[0] !== '.')
  ) {
    options.store = true;
  }

  // SPA loadingIndicator
  if (options.loadingIndicator) {
    // Normalize loadingIndicator
    if (!isPureObject(options.loadingIndicator)) {
      options.loadingIndicator = { name: options.loadingIndicator };
    }

    // Apply defaults
    options.loadingIndicator = Object.assign(
      {
        name: 'default',
        color: (options.loading && options.loading.color) || '#D3D3D3',
        color2: '#F5F5F5',
        background: (options.manifest && options.manifest.theme_color) || 'white',
        dev: options.dev,
        loading: options.messages.loading
      },
      options.loadingIndicator
    );
  }

  // Debug errors
  if (options.debug === undefined) {
    options.debug = options.dev;
  }

  // Apply default hash to CSP option
  const csp = options.render.csp;
  const cspDefaults = {
    hashAlgorithm: 'sha256',
    allowedSources: undefined,
    policies: undefined,
    reportOnly: options.debug
  };
  if (csp) {
    options.render.csp = _.defaults(_.isObject(csp) ? csp : {}, cspDefaults);
  }

  // cssSourceMap
  if (options.build.cssSourceMap === undefined) {
    options.build.cssSourceMap = options.dev;
  }

  // babel cacheDirectory
  if (options.build.babel.cacheDirectory === undefined) {
    options.build.babel.cacheDirectory = options.dev;
  }

  // vue config
  const vueConfig = options.vue.config;

  if (vueConfig.silent === undefined) {
    vueConfig.silent = !options.dev;
  }
  if (vueConfig.performance === undefined) {
    vueConfig.performance = options.dev;
  }

  // merge custom env with variables
  const eligibleEnvVariables = _.pick(process.env, Object.keys(process.env).filter(k => k.startsWith('NUXT_ENV_')));
  Object.assign(options.env, eligibleEnvVariables);

  // Normalize ignore
  options.ignore = options.ignore ? [].concat(options.ignore) : [];

  // Append ignorePrefix glob to ignore
  if (typeof options.ignorePrefix === 'string') {
    options.ignore.push(`**/${options.ignorePrefix}*.*`);
  }

  // Compression middleware legacy
  if (options.render.gzip) {
    consola.warn('render.gzip is deprecated and will be removed in a future version! Please switch to render.compressor');
    options.render.compressor = options.render.gzip;
    delete options.render.gzip;
  }

  // Apply mode preset
  const modePreset = modes[options.mode || 'universal'] || modes.universal;
  _.defaultsDeep(options, modePreset);

  // If no server-side rendering, add appear true transition
  /* istanbul ignore if */
  if (options.render.ssr === false && options.transition) {
    options.transition.appear = true;
  }

  // We assume the SPA fallback path is 404.html (for GitHub Pages, Surge, etc.)
  if (options.generate.fallback === true) {
    options.generate.fallback = '404.html';
  }

  if (options.build.stats === 'none' || options.build.quiet === true) {
    options.build.stats = false;
  }

  // Vendor backward compatibility with nuxt 1.x
  if (typeof options.build.vendor !== 'undefined') {
    delete options.build.vendor;
    consola.warn('vendor has been deprecated due to webpack4 optimization');
  }

  // TODO: remove when mini-css-extract-plugin supports HMR
  if (options.dev) {
    options.build.extractCSS = false;
  }

  // Enable minimize for production builds
  if (options.build.optimization.minimize === undefined) {
    options.build.optimization.minimize = !options.dev;
  }

  // Enable optimizeCSS only when extractCSS is enabled
  if (options.build.optimizeCSS === undefined) {
    options.build.optimizeCSS = options.build.extractCSS ? {} : false;
  }

  const loaders = options.build.loaders;
  const vueLoader = loaders.vue;
  if (vueLoader.productionMode === undefined) {
    vueLoader.productionMode = !options.dev;
  }
  const styleLoaders = [
    'css', 'cssModules', 'less',
    'sass', 'scss', 'stylus', 'vueStyle'
  ];
  for (const name of styleLoaders) {
    const loader = loaders[name];
    if (loader && loader.sourceMap === undefined) {
      loader.sourceMap = Boolean(options.build.cssSourceMap);
    }
  }

  // include SFCs in node_modules
  options.build.transpile = [].concat(options.build.transpile || [])
    .map(module => module instanceof RegExp ? module : new RegExp(module));

  if (options.build.quiet === true) {
    consola.level = 0;
  }

  return options
};

var name = "nuxt";
var version = "2.2.0";
var description = "A minimalistic framework for server-rendered Vue.js applications (inspired by Next.js)";
var contributors = [
	{
		name: "Sebastien Chopin (@Atinux)"
	},
	{
		name: "Alexandre Chopin (@alexchopin)"
	},
	{
		name: "Pooya Parsa (@pi0)"
	},
	{
		name: "Clark Du (@clarkdo)"
	},
	{
		name: "Jonas Galvez (@galvez)"
	},
	{
		name: "Alexander Lichter (@manniL}"
	}
];
var main = "index.js";
var module$1 = "./lib/nuxt.js";
var license = "MIT";
var repository = {
	type: "git",
	url: "git+https://github.com/nuxt/nuxt.js"
};
var files = [
	"bin",
	"lib",
	"dist",
	"index.js"
];
var keywords = [
	"nuxt",
	"nuxt.js",
	"nuxtjs",
	"vue",
	"vue.js",
	"vuejs",
	"vue universal",
	"vue ssr",
	"vue server side",
	"ssr",
	"vue isomorphic",
	"vue versatile"
];
var homepage = "https://github.com/nuxt/nuxt.js#readme";
var bin = {
	nuxt: "./bin/nuxt"
};
var scripts = {
	build: "node -r esm ./packages/nuxt-pack/build.js",
	coverage: "codecov",
	lint: "eslint --ext .js,.mjs,.vue bin/** benchmarks examples lib packages test",
	postinstall: "opencollective || exit 0",
	test: "yarn test:fixtures && yarn test:unit",
	"test:fixtures": "jest test/fixtures",
	"test:e2e": "jest -i test/e2e",
	"test:lint": "yarn lint",
	"test:unit": "jest test/unit"
};
var engines = {
	node: ">=8.0.0",
	npm: ">=5.0.0"
};
var dependencies = {
	"@babel/core": "^7.1.2",
	"@babel/polyfill": "^7.0.0",
	"@nuxtjs/babel-preset-app": "^0.7.0",
	"@nuxtjs/devalue": "^1.0.0",
	"@nuxtjs/friendly-errors-webpack-plugin": "^2.0.2",
	"@nuxtjs/opencollective": "^0.1.0",
	"@nuxtjs/youch": "^4.2.3",
	"babel-loader": "^8.0.4",
	"cache-loader": "^1.2.2",
	"caniuse-lite": "^1.0.30000890",
	chalk: "^2.4.1",
	chokidar: "^2.0.4",
	compression: "^1.7.3",
	connect: "^3.6.6",
	consola: "^1.4.4",
	"css-loader": "^1.0.0",
	cssnano: "^4.1.4",
	debug: "^4.1.0",
	esm: "^3.0.84",
	etag: "^1.8.1",
	"file-loader": "^2.0.0",
	fresh: "^0.5.2",
	"fs-extra": "^7.0.0",
	glob: "^7.1.3",
	"hash-sum": "^1.0.2",
	"html-minifier": "^3.5.20",
	"html-webpack-plugin": "^3.2.0",
	ip: "^1.1.5",
	"launch-editor-middleware": "^2.2.1",
	lodash: "^4.17.11",
	"lru-cache": "^4.1.3",
	"memory-fs": "^0.4.1",
	"mini-css-extract-plugin": "^0.4.4",
	minimist: "^1.2.0",
	"optimize-css-assets-webpack-plugin": "^5.0.1",
	pify: "^4.0.0",
	postcss: "^7.0.5",
	"postcss-import": "^12.0.0",
	"postcss-import-resolver": "^1.1.0",
	"postcss-loader": "^3.0.0",
	"postcss-preset-env": "^6.1.1",
	"postcss-url": "^8.0.0",
	semver: "^5.6.0",
	"serialize-javascript": "^1.5.0",
	"serve-static": "^1.13.2",
	"server-destroy": "^1.0.1",
	"std-env": "^2.0.2",
	"style-resources-loader": "^1.2.1",
	"terser-webpack-plugin": "^1.1.0",
	"thread-loader": "^1.2.0",
	"time-fix-plugin": "^2.0.3",
	upath: "^1.1.0",
	"url-loader": "^1.1.2",
	vue: "^2.5.17",
	"vue-loader": "^15.4.2",
	"vue-meta": "^1.5.5",
	"vue-no-ssr": "^1.0.0",
	"vue-router": "^3.0.1",
	"vue-server-renderer": "^2.5.17",
	"vue-template-compiler": "^2.5.17",
	vuex: "^3.0.1",
	webpack: "^4.20.2",
	"webpack-bundle-analyzer": "^3.0.2",
	"webpack-dev-middleware": "^3.4.0",
	"webpack-hot-middleware": "^2.24.3",
	"webpack-node-externals": "^1.7.2",
	webpackbar: "^2.6.3"
};
var devDependencies = {
	"@babel/preset-env": "^7.1.0",
	"babel-core": "^7.0.0-bridge",
	"babel-eslint": "^10.0.1",
	"babel-jest": "^23.6.0",
	"babel-plugin-dynamic-import-node": "^2.2.0",
	codecov: "^3.1.0",
	"cross-env": "^5.2.0",
	"cross-spawn": "^6.0.5",
	eslint: "^5.7.0",
	"eslint-config-standard": "^12.0.0",
	"eslint-plugin-import": "^2.14.0",
	"eslint-plugin-jest": "^21.24.1",
	"eslint-plugin-node": "^7.0.1",
	"eslint-plugin-promise": "^4.0.1",
	"eslint-plugin-standard": "^4.0.0",
	"eslint-plugin-vue": "^5.0.0-beta.3",
	express: "^4.16.4",
	finalhandler: "^1.1.1",
	"get-port": "^4.0.0",
	jest: "^23.6.0",
	jsdom: "^12.2.0",
	"klaw-sync": "^6.0.0",
	pug: "^2.0.3",
	"pug-plain-loader": "^1.0.0",
	puppeteer: "^1.9.0",
	request: "^2.88.0",
	"request-promise-native": "^1.0.5",
	rimraf: "^2.6.2",
	rollup: "^0.66.6",
	"rollup-plugin-babel": "^4.0.3",
	"rollup-plugin-commonjs": "^9.2.0",
	"rollup-plugin-json": "^3.1.0",
	"rollup-plugin-license": "^0.7.0"
};
var collective = {
	url: "https://opencollective.com/nuxtjs",
	logoUrl: "https://opencollective.com/nuxtjs/logo.txt?reverse=true&variant=variant2"
};
var packageJSON = {
	name: name,
	version: version,
	description: description,
	contributors: contributors,
	main: main,
	module: module$1,
	license: license,
	repository: repository,
	files: files,
	keywords: keywords,
	homepage: homepage,
	bin: bin,
	scripts: scripts,
	engines: engines,
	dependencies: dependencies,
	devDependencies: devDependencies,
	collective: collective
};

class MetaRenderer {
  constructor(nuxt, renderer) {
    this.nuxt = nuxt;
    this.renderer = renderer;
    this.options = nuxt.options;
    this.vueRenderer = vueServerRenderer.createRenderer();
    this.cache = LRU({});

    // Add VueMeta to Vue (this is only for SPA mode)
    // See lib/app/index.js
    Vue.use(VueMeta, {
      keyName: 'head',
      attribute: 'data-n-head',
      ssrAttribute: 'data-n-head-ssr',
      tagIDKeyName: 'hid'
    });
  }

  async getMeta(url) {
    const vm = new Vue({
      render: h => h(), // Render empty html tag
      head: this.options.head || {}
    });
    await this.vueRenderer.renderToString(vm);
    return vm.$meta().inject()
  }

  async render({ url = '/' }) {
    let meta = this.cache.get(url);

    if (meta) {
      return meta
    }

    meta = {
      HTML_ATTRS: '',
      BODY_ATTRS: '',
      HEAD: '',
      BODY_SCRIPTS: ''
    };

    // Get vue-meta context
    const m = await this.getMeta(url);

    // HTML_ATTRS
    meta.HTML_ATTRS = m.htmlAttrs.text();

    // BODY_ATTRS
    meta.BODY_ATTRS = m.bodyAttrs.text();

    // HEAD tags
    meta.HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();

    // BODY_SCRIPTS
    meta.BODY_SCRIPTS = m.script.text({ body: true }) + m.noscript.text({ body: true });

    // Resources Hints

    meta.resourceHints = '';

    const clientManifest = this.renderer.resources.clientManifest;

    const shouldPreload = this.options.render.bundleRenderer.shouldPreload || (() => true);
    const shouldPrefetch = this.options.render.bundleRenderer.shouldPrefetch || (() => true);

    if (this.options.render.resourceHints && clientManifest) {
      const publicPath = clientManifest.publicPath || '/_nuxt/';

      // Preload initial resources
      if (Array.isArray(clientManifest.initial)) {
        meta.resourceHints += clientManifest.initial
          .filter(file => shouldPreload(file))
          .map(
            r => `<link rel="preload" href="${publicPath}${r}" as="script" />`
          )
          .join('');
      }

      // Prefetch async resources
      if (Array.isArray(clientManifest.async)) {
        meta.resourceHints += clientManifest.async
          .filter(file => shouldPrefetch(file))
          .map(r => `<link rel="prefetch" href="${publicPath}${r}" />`)
          .join('');
      }

      // Add them to HEAD
      if (meta.resourceHints) {
        meta.HEAD += meta.resourceHints;
      }
    }

    // Emulate getPreloadFiles from vue-server-renderer (works for JS chunks only)
    meta.getPreloadFiles = () =>
      clientManifest.initial
        .filter(file => shouldPreload(file))
        .map(r => ({
          file: r,
          fileWithoutQuery: r,
          asType: 'script',
          extension: 'js'
        }));

    // Set meta tags inside cache
    this.cache.set(url, meta);

    return meta
  }
}

function errorMiddleware(err, req, res, next) {
  // ensure statusCode, message and name fields
  err.statusCode = err.statusCode || 500;
  err.message = err.message || 'Nuxt Server Error';
  err.name = !err.name || err.name === 'Error' ? 'NuxtServerError' : err.name;

  // We hide actual errors from end users, so show them on server logs
  if (err.statusCode !== 404) {
    consola.error(err);
  }

  const sendResponse = (content, type = 'text/html') => {
    // Set Headers
    res.statusCode = err.statusCode;
    res.statusMessage = err.name;
    res.setHeader('Content-Type', type + '; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(content));
    res.setHeader('Cache-Control', 'no-cache, no-store, max-age=0, must-revalidate');

    // Send Response
    res.end(content, 'utf-8');
  };

  // Check if request accepts JSON
  const hasReqHeader = (header, includes) =>
    req.headers[header] && req.headers[header].toLowerCase().includes(includes);
  const isJson =
    hasReqHeader('accept', 'application/json') ||
    hasReqHeader('user-agent', 'curl/');

  // Use basic errors when debug mode is disabled
  if (!this.options.debug) {
    // Json format is compatible with Youch json responses
    const json = {
      status: err.statusCode,
      message: err.message,
      name: err.name
    };
    if (isJson) {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
      return
    }
    const html = this.resources.errorTemplate(json);
    sendResponse(html);
    return
  }

  // Show stack trace
  const youch = new Youch(
    err,
    req,
    readSource.bind(this),
    this.options.router.base,
    true
  );
  if (isJson) {
    youch.toJSON().then((json) => {
      sendResponse(JSON.stringify(json, undefined, 2), 'text/json');
    });
  } else {
    youch.toHTML().then(html => sendResponse(html));
  }
}

async function readSource(frame) {
  // Remove webpack:/// & query string from the end
  const sanitizeName = name =>
    name ? name.replace('webpack:///', '').split('?')[0] : null;
  frame.fileName = sanitizeName(frame.fileName);

  // Return if fileName is unknown
  /* istanbul ignore if */
  if (!frame.fileName) {
    return
  }

  // Possible paths for file
  const searchPath = [
    this.options.srcDir,
    this.options.rootDir,
    path__default.join(this.options.buildDir, 'dist', 'server'),
    this.options.buildDir,
    process.cwd()
  ];

  // Scan filesystem for real source
  for (const pathDir of searchPath) {
    const fullPath = path__default.resolve(pathDir, frame.fileName);
    const source = await fs$1.readFile(fullPath, 'utf-8').catch(() => null);
    if (source) {
      frame.contents = source;
      frame.fullPath = fullPath;
      if (path__default.isAbsolute(frame.fileName)) {
        frame.fileName = path__default.relative(this.options.rootDir, fullPath);
      }
      return
    }
  }

  // Fallback: use server bundle
  // TODO: restore to if after https://github.com/istanbuljs/nyc/issues/595 fixed
  /* istanbul ignore next */
  if (!frame.contents) {
    frame.contents = this.resources.serverBundle.files[frame.fileName];
  }
}

async function nuxtMiddleware(req, res, next) {
  // Get context
  const context = getContext(req, res);

  res.statusCode = 200;
  try {
    const result = await this.renderRoute(req.url, context);
    await this.nuxt.callHook('render:route', req.url, result, context);
    const {
      html,
      cspScriptSrcHashSet,
      error,
      redirected,
      getPreloadFiles
    } = result;

    if (redirected) {
      this.nuxt.callHook('render:routeDone', req.url, result, context);
      return html
    }
    if (error) {
      res.statusCode = context.nuxt.error.statusCode || 500;
    }

    // Add ETag header
    if (!error && this.options.render.etag) {
      const etag = generateETag(html, this.options.render.etag);
      if (fresh(req.headers, { etag })) {
        res.statusCode = 304;
        res.end();
        this.nuxt.callHook('render:routeDone', req.url, result, context);
        return
      }
      res.setHeader('ETag', etag);
    }

    // HTTP2 push headers for preload assets
    if (!error && this.options.render.http2.push) {
      // Parse resourceHints to extract HTTP.2 prefetch/push headers
      // https://w3c.github.io/preload/#server-push-http-2
      const pushAssets = [];
      const preloadFiles = getPreloadFiles();
      const { shouldPush } = this.options.render.http2;
      const { publicPath } = this.resources.clientManifest;

      preloadFiles.forEach(({ file, asType, fileWithoutQuery }) => {
        // By default, we only preload scripts or css
        /* istanbul ignore if */
        if (!shouldPush && asType !== 'script' && asType !== 'style') {
          return
        }

        // User wants to explicitly control what to preload
        if (shouldPush && !shouldPush(fileWithoutQuery, asType)) {
          return
        }

        pushAssets.push(`<${publicPath}${file}>; rel=preload; as=${asType}`);
      });

      // Pass with single Link header
      // https://blog.cloudflare.com/http-2-server-push-with-multiple-assets-per-link-header
      // https://www.w3.org/Protocols/9707-link-header.html
      res.setHeader('Link', pushAssets.join(','));
    }

    if (this.options.render.csp) {
      const { allowedSources, policies } = this.options.render.csp;
      const cspHeader = this.options.render.csp.reportOnly ? 'Content-Security-Policy-Report-Only' : 'Content-Security-Policy';

      res.setHeader(cspHeader, getCspString({ cspScriptSrcHashSet, allowedSources, policies, isDev: this.options.dev }));
    }

    // Send response
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(html));
    res.end(html, 'utf8');
    this.nuxt.callHook('render:routeDone', req.url, result, context);
    return html
  } catch (err) {
    /* istanbul ignore if */
    if (context && context.redirected) {
      consola.error(err);
      return err
    }

    next(err);
  }
}

const getCspString = ({ cspScriptSrcHashSet, allowedSources, policies, isDev }) => {
  const joinedHashSet = Array.from(cspScriptSrcHashSet).join(' ');
  const baseCspStr = `script-src 'self'${isDev ? ` 'unsafe-eval'` : ''} ${joinedHashSet}`;

  if (Array.isArray(allowedSources)) {
    return `${baseCspStr} ${allowedSources.join(' ')}`
  }

  const policyObjectAvailable = typeof policies === 'object' && policies !== null && !Array.isArray(policies);

  if (policyObjectAvailable) {
    const transformedPolicyObject = transformPolicyObject(policies, cspScriptSrcHashSet);

    return Object.entries(transformedPolicyObject).map(([k, v]) => `${k} ${v.join(' ')}`).join('; ')
  }

  return baseCspStr
};

const transformPolicyObject = (policies, cspScriptSrcHashSet) => {
  const userHasDefinedScriptSrc = policies['script-src'] && Array.isArray(policies['script-src']);

  // Self is always needed for inline-scripts, so add it, no matter if the user specified script-src himself.

  const hashAndPolicySet = cspScriptSrcHashSet;
  hashAndPolicySet.add(`'self'`);

  if (!userHasDefinedScriptSrc) {
    policies['script-src'] = Array.from(hashAndPolicySet);
    return policies
  }

  new Set(policies['script-src']).forEach(src => hashAndPolicySet.add(src));

  policies['script-src'] = Array.from(hashAndPolicySet);

  return policies
};

let jsdom = null;

class Renderer {
  constructor(nuxt) {
    this.nuxt = nuxt;
    this.options = nuxt.options;
    this.globals = determineGlobals(nuxt.options.globalName, nuxt.options.globals);

    // Will be set by createRenderer
    this.bundleRenderer = null;
    this.metaRenderer = null;

    // Will be available on dev
    this.webpackDevMiddleware = null;
    this.webpackHotMiddleware = null;

    // Create new connect instance
    this.app = connect();

    // Renderer runtime resources
    this.resources = {
      clientManifest: null,
      serverBundle: null,
      ssrTemplate: null,
      spaTemplate: null,
      errorTemplate: parseTemplate('Nuxt.js Internal Server Error')
    };
  }

  async ready() {
    await this.nuxt.callHook('render:before', this, this.options.render);
    // Setup nuxt middleware
    await this.setupMiddleware();

    // Production: Load SSR resources from fs
    if (!this.options.dev) {
      await this.loadResources();
    }

    // Call done hook
    await this.nuxt.callHook('render:done', this);
  }

  async loadResources(_fs = fs$1) {
    const distPath = path__default.resolve(this.options.buildDir, 'dist', 'server');
    const updated = [];

    resourceMap.forEach(({ key, fileName, transform }) => {
      const rawKey = '$$' + key;
      const _path = path__default.join(distPath, fileName);

      if (!_fs.existsSync(_path)) {
        return // Resource not exists
      }
      const rawData = _fs.readFileSync(_path, 'utf8');
      if (!rawData || rawData === this.resources[rawKey]) {
        return // No changes
      }
      this.resources[rawKey] = rawData;
      const data = transform(rawData);
      /* istanbul ignore if */
      if (!data) {
        return // Invalid data ?
      }
      this.resources[key] = data;
      updated.push(key);
    });

    // Reload error template
    const errorTemplatePath = path__default.resolve(this.options.buildDir, 'views/error.html');
    if (fs$1.existsSync(errorTemplatePath)) {
      this.resources.errorTemplate = parseTemplate(
        fs$1.readFileSync(errorTemplatePath, 'utf8')
      );
    }

    // Load loading template
    const loadingHTMLPath = path__default.resolve(this.options.buildDir, 'loading.html');
    if (fs$1.existsSync(loadingHTMLPath)) {
      this.resources.loadingHTML = fs$1.readFileSync(loadingHTMLPath, 'utf8');
      this.resources.loadingHTML = this.resources.loadingHTML
        .replace(/\r|\n|[\t\s]{3,}/g, '');
    } else {
      this.resources.loadingHTML = '';
    }

    // Call resourcesLoaded plugin
    await this.nuxt.callHook('render:resourcesLoaded', this.resources);

    if (updated.length > 0) {
      this.createRenderer();
    }
  }

  get noSSR() {
    return this.options.render.ssr === false
  }

  get isReady() {
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    return Boolean(this.bundleRenderer && this.resources.ssrTemplate)
  }

  get isResourcesAvailable() {
    // Required for both
    /* istanbul ignore if */
    if (!this.resources.clientManifest) {
      return false
    }

    // Required for SPA rendering
    if (this.noSSR) {
      return Boolean(this.resources.spaTemplate)
    }

    // Required for bundle renderer
    return Boolean(this.resources.ssrTemplate && this.resources.serverBundle)
  }

  createRenderer() {
    // Ensure resources are available
    if (!this.isResourcesAvailable) {
      return
    }

    // Create Meta Renderer
    this.metaRenderer = new MetaRenderer(this.nuxt, this);

    // Skip following steps if noSSR mode
    if (this.noSSR) {
      return
    }

    const hasModules = fs$1.existsSync(path__default.resolve(this.options.rootDir, 'node_modules'));
    // Create bundle renderer for SSR
    this.bundleRenderer = vueServerRenderer.createBundleRenderer(
      this.resources.serverBundle,
      Object.assign(
        {
          clientManifest: this.resources.clientManifest,
          runInNewContext: false,
          // for globally installed nuxt command, search dependencies in global dir
          basedir: hasModules ? this.options.rootDir : __dirname
        },
        this.options.render.bundleRenderer
      )
    );
  }

  useMiddleware(m) {
    // Resolve
    const $m = m;
    if (typeof m === 'string') {
      m = this.nuxt.requireModule(m);
    }
    if (typeof m.handler === 'string') {
      m.handler = this.nuxt.requireModule(m.handler);
    }

    const handler = m.handler || m;
    const path$$1 = (
      (m.prefix !== false ? this.options.router.base : '') +
      (typeof m.path === 'string' ? m.path : '')
    ).replace(/\/\//g, '/');

    handler.$m = $m;

    // Use middleware
    this.app.use(path$$1, handler);
  }

  get publicPath() {
    return isUrl(this.options.build.publicPath)
      ? defaults.build.publicPath
      : this.options.build.publicPath
  }

  async setupMiddleware() {
    // Apply setupMiddleware from modules first
    await this.nuxt.callHook('render:setupMiddleware', this.app);

    // Compression middleware for production
    if (!this.options.dev) {
      const compressor = this.options.render.compressor;
      if (typeof compressor === 'object') {
        // If only setting for `compression` are provided, require the module and insert
        // Prefer require instead of requireModule to keep dependency in nuxt-start
        const compression = require('compression');
        this.useMiddleware(compression(compressor));
      } else {
        // Else, require own compression middleware
        this.useMiddleware(compressor);
      }
    }

    // Add webpack middleware only for development
    if (this.options.dev) {
      this.useMiddleware(async (req, res, next) => {
        if (this.webpackDevMiddleware) {
          await this.webpackDevMiddleware(req, res);
        }
        if (this.webpackHotMiddleware) {
          await this.webpackHotMiddleware(req, res);
        }
        next();
      });
    }

    // open in editor for debug mode only
    if (this.options.debug && this.options.dev) {
      this.useMiddleware({
        path: '__open-in-editor',
        handler: launchMiddleware(this.options.editor)
      });
    }

    // For serving static/ files to /
    const staticMiddleware = serveStatic(
      path__default.resolve(this.options.srcDir, this.options.dir.static),
      this.options.render.static
    );
    staticMiddleware.prefix = this.options.render.static.prefix;
    this.useMiddleware(staticMiddleware);

    // Serve .nuxt/dist/ files only for production
    // For dev they will be served with devMiddleware
    if (!this.options.dev) {
      const distDir = path__default.resolve(this.options.buildDir, 'dist', 'client');
      this.useMiddleware({
        path: this.publicPath,
        handler: serveStatic(
          distDir,
          this.options.render.dist
        )
      });
    }

    // Add User provided middleware
    this.options.serverMiddleware.forEach((m) => {
      this.useMiddleware(m);
    });

    // Finally use nuxtMiddleware
    this.useMiddleware(nuxtMiddleware.bind(this));

    // Error middleware for errors that occurred in middleware that declared above
    // Middleware should exactly take 4 arguments
    // https://github.com/senchalabs/connect#error-middleware

    // Apply errorMiddleware from modules first
    await this.nuxt.callHook('render:errorMiddleware', this.app);

    // Apply errorMiddleware from Nuxt
    this.useMiddleware(errorMiddleware.bind(this));
  }

  renderTemplate(ssr, opts) {
    // Fix problem with HTMLPlugin's minify option (#3392)
    opts.html_attrs = opts.HTML_ATTRS;
    opts.body_attrs = opts.BODY_ATTRS;

    const fn = ssr ? this.resources.ssrTemplate : this.resources.spaTemplate;

    return fn(opts)
  }

  async renderRoute(url, context = {}) {
    /* istanbul ignore if */
    if (!this.isReady) {
      await waitFor(1000);
      return this.renderRoute(url, context)
    }

    // Log rendered url
    consola.debug(`Rendering url ${url}`);

    // Add url and isSever to the context
    context.url = url;

    // Basic response if SSR is disabled or spa data provided
    const spa = context.spa || (context.res && context.res.spa);
    const ENV = this.options.env;

    if (this.noSSR || spa) {
      const {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        BODY_SCRIPTS,
        getPreloadFiles
      } = await this.metaRenderer.render(context);
      const APP =
        `<div id="${this.globals.id}">${this.resources.loadingHTML}</div>` + BODY_SCRIPTS;

      // Detect 404 errors
      if (
        url.includes(this.options.build.publicPath) ||
        url.includes('__webpack')
      ) {
        const err = {
          statusCode: 404,
          message: this.options.messages.error_404,
          name: 'ResourceNotFound'
        };
        throw err
      }

      const html = this.renderTemplate(false, {
        HTML_ATTRS,
        BODY_ATTRS,
        HEAD,
        APP,
        ENV
      });

      return { html, getPreloadFiles }
    }

    // Call renderToString from the bundleRenderer and generate the HTML (will update the context as well)
    let APP = await this.bundleRenderer.renderToString(context);

    if (!context.nuxt.serverRendered) {
      APP = `<div id="${this.globals.id}"></div>`;
    }
    const m = context.meta.inject();
    let HEAD =
      m.title.text() +
      m.meta.text() +
      m.link.text() +
      m.style.text() +
      m.script.text() +
      m.noscript.text();
    if (this.options._routerBaseSpecified) {
      HEAD += `<base href="${this.options.router.base}">`;
    }

    if (this.options.render.resourceHints) {
      HEAD += context.renderResourceHints();
    }

    await this.nuxt.callHook('render:routeContext', context.nuxt);

    const serializedSession = `window.${this.globals.context}=${devalue(context.nuxt)};`;

    const cspScriptSrcHashSet = new Set();
    if (this.options.render.csp) {
      const { hashAlgorithm } = this.options.render.csp;
      const hash$$1 = crypto.createHash(hashAlgorithm);
      hash$$1.update(serializedSession);
      cspScriptSrcHashSet.add(`'${hashAlgorithm}-${hash$$1.digest('base64')}'`);
    }

    APP += `<script>${serializedSession}</script>`;
    APP += context.renderScripts();
    APP += m.script.text({ body: true });
    APP += m.noscript.text({ body: true });

    HEAD += context.renderStyles();

    const html = this.renderTemplate(true, {
      HTML_ATTRS: 'data-n-head-ssr ' + m.htmlAttrs.text(),
      BODY_ATTRS: m.bodyAttrs.text(),
      HEAD,
      APP,
      ENV
    });

    return {
      html,
      cspScriptSrcHashSet,
      getPreloadFiles: context.getPreloadFiles,
      error: context.nuxt.error,
      redirected: context.redirected
    }
  }

  async renderAndGetWindow(url, opts = {}) {
    /* istanbul ignore if */
    if (!jsdom) {
      try {
        jsdom = require('jsdom');
      } catch (e) /* istanbul ignore next */ {
        consola.error(`
         Fail when calling nuxt.renderAndGetWindow(url)
         jsdom module is not installed
         Please install jsdom with: npm install --save-dev jsdom
        `);
        throw e
      }
    }
    const options = Object.assign({
      resources: 'usable', // load subresources (https://github.com/tmpvar/jsdom#loading-subresources)
      runScripts: 'dangerously',
      virtualConsole: true,
      beforeParse(window) {
        // Mock window.scrollTo
        window.scrollTo = () => {};
      }
    }, opts);
    const jsdomErrHandler = (err) => { throw err };
    if (options.virtualConsole) {
      if (options.virtualConsole === true) {
        options.virtualConsole = new jsdom.VirtualConsole().sendTo(consola);
      }
      // throw error when window creation failed
      options.virtualConsole.on('jsdomError', jsdomErrHandler);
    }
    url = url || 'http://localhost:3000';
    const { window } = await jsdom.JSDOM.fromURL(url, options);
    // If Nuxt could not be loaded (error from the server-side)
    const nuxtExists = window.document.body.innerHTML.includes(
      this.options.render.ssr ? `window.${this.globals.context}` : `<div id="${this.globals.id}">`
    );
    /* istanbul ignore if */
    if (!nuxtExists) {
      const error = new Error('Could not load the nuxt app');
      error.body = window.document.body.innerHTML;
      throw error
    }
    // Used by nuxt.js to say when the components are loaded and the app ready
    const onNuxtLoaded = this.globals.loadedCallback;
    await timeout(new Promise((resolve) => {
      window[onNuxtLoaded] = () => resolve(window);
    }), 20000, 'Components loading in renderAndGetWindow was not completed in 20s');
    if (options.virtualConsole) {
      // after window initialized successfully
      options.virtualConsole.removeListener('jsdomError', jsdomErrHandler);
    }
    // Send back window object
    return window
  }
}

const parseTemplate = templateStr =>
  _.template(templateStr, {
    interpolate: /{{([\s\S]+?)}}/g
  });

const resourceMap = [
  {
    key: 'clientManifest',
    fileName: 'vue-ssr-client-manifest.json',
    transform: JSON.parse
  },
  {
    key: 'serverBundle',
    fileName: 'server-bundle.json',
    transform: JSON.parse
  },
  {
    key: 'ssrTemplate',
    fileName: 'index.ssr.html',
    transform: parseTemplate
  },
  {
    key: 'spaTemplate',
    fileName: 'index.spa.html',
    transform: parseTemplate
  }
];

class Nuxt {
  constructor(options = {}) {
    this.options = Options.from(options);

    this.readyMessage = null;
    this.initialized = false;

    // Hooks
    this._hooks = {};
    this.hook = this.hook.bind(this);

    // Create instance of core components
    this.moduleContainer = new ModuleContainer(this);
    this.renderer = new Renderer(this);

    // Backward compatibility
    this.render = this.renderer.app;
    this.renderRoute = this.renderer.renderRoute.bind(this.renderer);
    this.renderAndGetWindow = this.renderer.renderAndGetWindow.bind(
      this.renderer
    );
    this.resolvePath = this.resolvePath.bind(this);
    this.resolveAlias = this.resolveAlias.bind(this);

    // ESM Loader
    this.esm = esm(module, {});

    this._ready = this.ready().catch((err) => {
      consola.fatal(err);
    });
  }

  static get version() {
    return packageJSON.version
  }

  async ready() {
    if (this._ready) {
      return this._ready
    }

    // Add hooks
    if (_.isPlainObject(this.options.hooks)) {
      this.addHooks(this.options.hooks);
    } else if (typeof this.options.hooks === 'function') {
      this.options.hooks(this.hook);
    }

    // Await for modules
    await this.moduleContainer.ready();

    // Await for renderer to be ready
    await this.renderer.ready();

    this.initialized = true;

    // Call ready hook
    await this.callHook('ready', this);

    return this
  }

  hook(name$$1, fn) {
    if (!name$$1 || typeof fn !== 'function') {
      return
    }
    if (name$$1 === 'render:context') {
      name$$1 = 'render:routeContext';
      consola.warn('render:context hook has been deprecated, please use render:routeContext');
    }
    this._hooks[name$$1] = this._hooks[name$$1] || [];
    this._hooks[name$$1].push(fn);
  }

  async callHook(name$$1, ...args) {
    if (!this._hooks[name$$1]) {
      return
    }
    consola.debug(`Call ${name$$1} hooks (${this._hooks[name$$1].length})`);
    try {
      await sequence(this._hooks[name$$1], fn => fn(...args));
    } catch (err) {
      consola.error(err);
      this.callHook('error', err);
    }
  }

  clearHook(name$$1) {
    if (name$$1) {
      delete this._hooks[name$$1];
    }
  }

  flatHooks(configHooks, hooks = {}, parentName) {
    Object.keys(configHooks).forEach((key) => {
      const subHook = configHooks[key];
      const name$$1 = parentName ? `${parentName}:${key}` : key;
      if (typeof subHook === 'object' && subHook !== null) {
        this.flatHooks(subHook, hooks, name$$1);
      } else {
        hooks[name$$1] = subHook;
      }
    });
    return hooks
  }

  addHooks(configHooks) {
    const hooks = this.flatHooks(configHooks);
    Object.keys(hooks).filter(Boolean).forEach((key) => {
      [].concat(hooks[key]).forEach(h => this.hook(key, h));
    });
  }

  showReady(clear = true) {
    if (!this.readyMessage) {
      return
    }
    consola.ready({
      message: this.readyMessage,
      badge: true,
      clear
    });
    this.readyMessage = null;
  }

  listen(port, host, socket) {
    return this.ready().then(() => new Promise((resolve, reject) => {
      if (!socket && typeof this.options.server.socket === 'string') {
        socket = this.options.server.socket;
      }

      const args = { exclusive: false };

      if (socket) {
        args.path = socket;
      } else {
        args.port = port || this.options.server.port;
        args.host = host || this.options.server.host;
      }

      let appServer;
      const isHttps = Boolean(this.options.server.https);

      if (isHttps) {
        let httpsOptions;

        if (this.options.server.https === true) {
          httpsOptions = {};
        } else {
          httpsOptions = this.options.server.https;
        }

        appServer = https.createServer(httpsOptions, this.renderer.app);
      } else {
        appServer = this.renderer.app;
      }

      const server = appServer.listen(
        args,
        (err) => {
          /* istanbul ignore if */
          if (err) {
            return reject(err)
          }

          let listenURL;

          if (!socket) {
            ({ address: host, port } = server.address());
            if (host === '127.0.0.1') {
              host = 'localhost';
            } else if (host === '0.0.0.0') {
              host = ip.address();
            }

            listenURL = chalk.underline.blue(`http${isHttps ? 's' : ''}://${host}:${port}`);
            this.readyMessage = `Listening on ${listenURL}`;
          } else {
            listenURL = chalk.underline.blue(`unix+http://${socket}`);
            this.readyMessage = `Listening on ${listenURL}`;
          }

          // Close server on nuxt close
          this.hook(
            'close',
            () =>
              new Promise((resolve, reject) => {
                // Destroy server by forcing every connection to be closed
                server.listening && server.destroy((err) => {
                  consola.debug('server closed');
                  /* istanbul ignore if */
                  if (err) {
                    return reject(err)
                  }
                  resolve();
                });
              })
          );

          if (socket) {
            this.callHook('listen', server, { path: socket }).then(resolve);
          } else {
            this.callHook('listen', server, { port, host }).then(resolve);
          }
        }
      );

      // Add server.destroy(cb) method
      enableDestroy(server);
    }))
  }

  resolveModule(path$$1) {
    try {
      const resolvedPath = Module._resolveFilename(path$$1, {
        paths: this.options.modulesDir
      });

      return resolvedPath
    } catch (error) {
      if (error.code === 'MODULE_NOT_FOUND') {
        return null
      } else {
        throw error
      }
    }
  }

  resolveAlias(path$$1) {
    const modulePath = this.resolveModule(path$$1);

    // Try to resolve it as if it were a regular node_module
    // Package first. Fixes issue with @<org> scoped packages
    if (modulePath != null) {
      return modulePath
    }

    if (startsWithRootAlias(path$$1)) {
      return path.join(this.options.rootDir, path$$1.substr(2))
    }

    if (startsWithSrcAlias(path$$1)) {
      return path.join(this.options.srcDir, path$$1.substr(1))
    }

    return path.resolve(this.options.srcDir, path$$1)
  }

  resolvePath(path$$1) {
    const _path = this.resolveAlias(path$$1);

    if (fs$1.existsSync(_path)) {
      return _path
    }

    for (const ext of this.options.extensions) {
      if (fs$1.existsSync(_path + '.' + ext)) {
        return _path + '.' + ext
      }
    }

    throw new Error(`Cannot resolve "${path$$1}" from "${_path}"`)
  }

  requireModule(_path, opts = {}) {
    const _resolvedPath = this.resolvePath(_path);
    const m = opts.esm === false ? require(_resolvedPath) : this.esm(_resolvedPath);
    return (m && m.default) || m
  }

  async close(callback) {
    await this.callHook('close', this);

    /* istanbul ignore if */
    if (typeof callback === 'function') {
      await callback();
    }
  }
}

var core = {
  Nuxt,
  Module: ModuleContainer,
  Renderer
};

var index = Object.assign({ Utils }, core);

module.exports = index;
//# sourceMappingURL=nuxt-start.js.map
